"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BranchState = undefined;

var _realm = require("../realm.js");

var _index = require("../values/index.js");

require("../serializer/types.js");

var _utils = require("./utils");

var _errors = require("./errors.js");

var _invariant = require("../invariant");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Branch state is used to capture branched ReactElements so they can be analyzed and compared
// once all branches have been processed. This allows us to add keys to the respective ReactElement
// objects depending on various heuristics (if they have the same "type" for example)
// A new branch state is created on a branch status of "NEW_BRANCH" and is reset to null once the branch is no
// longer new


// Branch status is used for when Prepack returns an abstract value from a render
// that results in a conditional path occuring. This can be problematic for reconcilation
// as the reconciler then needs to understand if this is the start of a new branch, or if
// it's actually deep into an existing branch. If it's a new branch, we need to apply
// keys to the root JSX element so that it keeps it identity (because we're folding trees).
// Furthermore, we also need to bail-out of folding class components where they have lifecycle
// events, as we can't merge lifecycles of mutliple trees when branched reliably
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

class BranchState {
  constructor() {
    this._branchesToValidate = [];
  }


  _applyBranchedLogicValue(realm, reactSerializerState, value) {
    if (value instanceof _index.StringValue || value instanceof _index.NumberValue || value instanceof _index.BooleanValue || value instanceof _index.NullValue || value instanceof _index.UndefinedValue) {
      // terminal values
    } else if (value instanceof _index.ObjectValue && (0, _utils.isReactElement)(value)) {
      (0, _utils.addKeyToReactElement)(realm, reactSerializerState, value);
    } else if (value instanceof _index.ArrayValue) {
      (0, _utils.forEachArrayValue)(realm, value, elementValue => {
        this._applyBranchedLogicValue(realm, reactSerializerState, elementValue);
      });
    } else if (value instanceof _index.AbstractValue) {
      let length = value.args.length;
      if (length > 0) {
        for (let i = 0; i < length; i++) {
          this._applyBranchedLogicValue(realm, reactSerializerState, value.args[i]);
        }
      }
    } else {
      throw new _errors.ExpectedBailOut("Unsupported value encountered when applying branched logic to values");
    }
  }

  applyBranchedLogic(realm, reactSerializerState) {
    let reactElementType;
    let applyBranchedLogic = false;

    for (let i = 0; i < this._branchesToValidate.length; i++) {
      let { type } = this._branchesToValidate[i];
      if (reactElementType === undefined) {
        reactElementType = type;
      } else if (type !== reactElementType) {
        // the types of the ReactElements do not match, so apply branch logic
        applyBranchedLogic = true;
        break;
      }
    }
    if (applyBranchedLogic) {
      for (let i = 0; i < this._branchesToValidate.length; i++) {
        this._applyBranchedLogicValue(realm, reactSerializerState, this._branchesToValidate[i].value);
      }
    }
  }

  captureBranchedValue(type, value) {
    (0, _invariant2.default)(type instanceof _index.ECMAScriptSourceFunctionValue || type instanceof _index.StringValue);
    this._branchesToValidate.push({ type, value });
    return value;
  }
}
exports.BranchState = BranchState;
//# sourceMappingURL=branching.js.map