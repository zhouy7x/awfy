{"version":3,"sources":["../../src/react/hoisting.js"],"names":["canHoistFunction","canHoistReactElement","canHoistObject","realm","object","residualHeapVisitor","visitedValues","propName","properties","prop","canHoistValue","symbol","symbols","canHoistArray","array","lengthValue","length","value","i","element","func","react","hoistableFunctions","has","get","undefined","functionInstance","functionInstances","residualFunctionBindings","Map","residualBindings","declarativeEnvironmentRecord","set","canHoistAbstract","abstract","scopes","values","scope","currentAdditionalFunction","commonScope","parent","isPrimitive","intrinsics","null","add","canHoist","delete","reactElement","hoistableReactElements","type","ref","key","props","Set","String","isPartialObject"],"mappings":"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","file":"hoisting.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport {\n  Value,\n  NumberValue,\n  ObjectValue,\n  SymbolValue,\n  FunctionValue,\n  StringValue,\n  ArrayValue,\n  BooleanValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport { Get } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport { isReactElement } from \"./utils.js\";\nimport { ResidualHeapVisitor } from \"../serializer/ResidualHeapVisitor.js\";\n\n// a nested object of a React Element should be hoisted where all its properties are known\n// at evaluation time to be safe to hoist (because of the heuristics of a React render)\nfunction canHoistObject(\n  realm: Realm,\n  object: ObjectValue,\n  residualHeapVisitor: ResidualHeapVisitor,\n  visitedValues: Set<Value>\n): boolean {\n  if (isReactElement(object)) {\n    return canHoistReactElement(realm, object, residualHeapVisitor, visitedValues);\n  }\n  for (let [propName] of object.properties) {\n    let prop = Get(realm, object, propName);\n    if (!canHoistValue(realm, prop, residualHeapVisitor, visitedValues)) {\n      return false;\n    }\n  }\n  for (let [symbol] of object.symbols) {\n    let prop = Get(realm, object, symbol);\n    if (!canHoistValue(realm, prop, residualHeapVisitor, visitedValues)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction canHoistArray(\n  realm: Realm,\n  array: ArrayValue,\n  residualHeapVisitor: ResidualHeapVisitor,\n  visitedValues: Set<Value>\n): boolean {\n  let lengthValue = Get(realm, array, \"length\");\n  invariant(lengthValue instanceof NumberValue);\n  let length = lengthValue.value;\n  for (let i = 0; i < length; i++) {\n    let element = Get(realm, array, \"\" + i);\n\n    if (!canHoistValue(realm, element, residualHeapVisitor, visitedValues)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function canHoistFunction(\n  realm: Realm,\n  func: FunctionValue,\n  residualHeapVisitor?: ResidualHeapVisitor,\n  visitedValues: Set<Value>\n): boolean {\n  if (realm.react.hoistableFunctions.has(func)) {\n    // cast because Flow thinks that we may have set a value to be something other than a boolean?\n    return ((realm.react.hoistableFunctions.get(func): any): boolean);\n  }\n  if (residualHeapVisitor === undefined) {\n    return false;\n  }\n  // get the function instance\n  let functionInstance = residualHeapVisitor.functionInstances.get(func);\n  // we can safely hoist the function if the residual bindings hoistable too\n  if (functionInstance !== undefined) {\n    invariant(functionInstance.residualFunctionBindings instanceof Map);\n    let residualBindings = functionInstance.residualFunctionBindings;\n    for (let [, { declarativeEnvironmentRecord, value }] of residualBindings) {\n      // if declarativeEnvironmentRecord is null, it's likely a global binding\n      // so we can assume that we can still hoist this function\n      if (declarativeEnvironmentRecord !== null) {\n        invariant(value instanceof Value);\n        if (!canHoistValue(realm, value, residualHeapVisitor, visitedValues)) {\n          return false;\n        }\n      }\n    }\n    realm.react.hoistableFunctions.set(func, true);\n    return true;\n  }\n  realm.react.hoistableFunctions.set(func, false);\n  return false;\n}\n\nfunction canHoistAbstract(realm: Realm, abstract: AbstractValue, residualHeapVisitor: ResidualHeapVisitor): boolean {\n  // get the scopes for this abstract value\n  let scopes = residualHeapVisitor.values.get(abstract);\n  // we can safely hoist abstracts that are created in the common scope\n  if (scopes !== undefined) {\n    for (let scope of scopes) {\n      const currentAdditionalFunction = residualHeapVisitor.commonScope;\n      invariant(currentAdditionalFunction instanceof FunctionValue);\n      if (scope === currentAdditionalFunction.parent) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction isPrimitive(realm: Realm, value: Value) {\n  return (\n    value instanceof StringValue ||\n    value instanceof NumberValue ||\n    value instanceof SymbolValue ||\n    value instanceof BooleanValue ||\n    value === realm.intrinsics.null ||\n    value === realm.intrinsics.undefined\n  );\n}\n\nfunction canHoistValue(\n  realm: Realm,\n  value: Value,\n  residualHeapVisitor: ResidualHeapVisitor,\n  visitedValues: Set<Value>\n): boolean {\n  if (visitedValues.has(value)) {\n    // If there is a cycle, bail out.\n    // TODO: is there some way to *not* bail out in this case?\n    // Currently if we don't, the output is broken.\n    return false;\n  }\n  visitedValues.add(value);\n  const canHoist =\n    (value instanceof ArrayValue && canHoistArray(realm, value, residualHeapVisitor, visitedValues)) ||\n    (value instanceof FunctionValue && canHoistFunction(realm, value, residualHeapVisitor, visitedValues)) ||\n    (value instanceof ObjectValue && canHoistObject(realm, value, residualHeapVisitor, visitedValues)) ||\n    (value instanceof AbstractValue && canHoistAbstract(realm, value, residualHeapVisitor)) ||\n    isPrimitive(realm, value);\n  visitedValues.delete(value);\n  return canHoist;\n}\n\nexport function canHoistReactElement(\n  realm: Realm,\n  reactElement: ObjectValue,\n  residualHeapVisitor?: ResidualHeapVisitor,\n  visitedValues: Set<Value> | void\n): boolean {\n  if (realm.react.hoistableReactElements.has(reactElement)) {\n    // cast because Flow thinks that we may have set a value to be something other than a boolean?\n    return ((realm.react.hoistableReactElements.get(reactElement): any): boolean);\n  }\n  if (residualHeapVisitor === undefined) {\n    return false;\n  }\n  let type = Get(realm, reactElement, \"type\");\n  let ref = Get(realm, reactElement, \"ref\");\n  let key = Get(realm, reactElement, \"key\");\n  let props = Get(realm, reactElement, \"props\");\n\n  if (visitedValues === undefined) {\n    visitedValues = new Set();\n    visitedValues.add(reactElement);\n  }\n  if (\n    canHoistValue(realm, type, residualHeapVisitor, visitedValues) &&\n    // we can't hoist string \"refs\" or if they're abstract, as they might be abstract strings\n    !(ref instanceof String || ref instanceof AbstractValue) &&\n    canHoistValue(realm, ref, residualHeapVisitor, visitedValues) &&\n    canHoistValue(realm, key, residualHeapVisitor, visitedValues) &&\n    !props.isPartialObject() &&\n    canHoistValue(realm, props, residualHeapVisitor, visitedValues)\n  ) {\n    realm.react.hoistableReactElements.set(reactElement, true);\n    return true;\n  }\n  realm.react.hoistableReactElements.set(reactElement, false);\n  return false;\n}\n"]}