{"version":3,"sources":["../../src/react/branching.js"],"names":["BranchState","constructor","_branchesToValidate","_applyBranchedLogicValue","realm","reactSerializerState","value","elementValue","length","args","i","applyBranchedLogic","reactElementType","type","undefined","captureBranchedValue","push"],"mappings":";;;;;;;AAWA;;AACA;;AAYA;;AACA;;AACA;;AACA;;;;;;AAWA;AACA;AACA;AACA;AACA;;;AAbA;AACA;AACA;AACA;AACA;AACA;AACA;AAnCA;;;;;;;;;AA2CO,MAAMA,WAAN,CAAkB;AACvBC,gBAAc;AACZ,SAAKC,mBAAL,GAA2B,EAA3B;AACD;;;AAMDC,2BAAyBC,KAAzB,EAAuCC,oBAAvC,EAAmFC,KAAnF,EAAuG;AACrG,QACEA,uCACAA,mCADA,IAEAA,oCAFA,IAGAA,iCAHA,IAIAA,sCALF,EAME;AACA;AACD,KARD,MAQO,IAAIA,uCAAgC,2BAAeA,KAAf,CAApC,EAA2D;AAChE,uCAAqBF,KAArB,EAA4BC,oBAA5B,EAAkDC,KAAlD;AACD,KAFM,MAEA,IAAIA,kCAAJ,EAAiC;AACtC,oCAAkBF,KAAlB,EAAyBE,KAAzB,EAAgCC,gBAAgB;AAC9C,aAAKJ,wBAAL,CAA8BC,KAA9B,EAAqCC,oBAArC,EAA2DE,YAA3D;AACD,OAFD;AAGD,KAJM,MAIA,IAAID,qCAAJ,EAAoC;AACzC,UAAIE,SAASF,MAAMG,IAAN,CAAWD,MAAxB;AACA,UAAIA,SAAS,CAAb,EAAgB;AACd,aAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAIF,MAApB,EAA4BE,GAA5B,EAAiC;AAC/B,eAAKP,wBAAL,CAA8BC,KAA9B,EAAqCC,oBAArC,EAA2DC,MAAMG,IAAN,CAAWC,CAAX,CAA3D;AACD;AACF;AACF,KAPM,MAOA;AACL,YAAM,4BAAoB,sEAApB,CAAN;AACD;AACF;;AAEDC,qBAAmBP,KAAnB,EAAiCC,oBAAjC,EAAmF;AACjF,QAAIO,gBAAJ;AACA,QAAID,qBAAqB,KAAzB;;AAEA,SAAK,IAAID,IAAI,CAAb,EAAgBA,IAAI,KAAKR,mBAAL,CAAyBM,MAA7C,EAAqDE,GAArD,EAA0D;AACxD,UAAI,EAAEG,IAAF,KAAW,KAAKX,mBAAL,CAAyBQ,CAAzB,CAAf;AACA,UAAIE,qBAAqBE,SAAzB,EAAoC;AAClCF,2BAAmBC,IAAnB;AACD,OAFD,MAEO,IAAIA,SAASD,gBAAb,EAA+B;AACpC;AACAD,6BAAqB,IAArB;AACA;AACD;AACF;AACD,QAAIA,kBAAJ,EAAwB;AACtB,WAAK,IAAID,IAAI,CAAb,EAAgBA,IAAI,KAAKR,mBAAL,CAAyBM,MAA7C,EAAqDE,GAArD,EAA0D;AACxD,aAAKP,wBAAL,CAA8BC,KAA9B,EAAqCC,oBAArC,EAA2D,KAAKH,mBAAL,CAAyBQ,CAAzB,EAA4BJ,KAAvF;AACD;AACF;AACF;;AAEDS,uBAAqBF,IAArB,EAAkCP,KAAlC,EAAuD;AACrD,6BAAUO,wDAAiDA,kCAA3D;AACA,SAAKX,mBAAL,CAAyBc,IAAzB,CAA8B,EAAEH,IAAF,EAAQP,KAAR,EAA9B;AACA,WAAOA,KAAP;AACD;AA7DsB;QAAZN,W,GAAAA,W","file":"branching.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport {\n  ECMAScriptSourceFunctionValue,\n  Value,\n  UndefinedValue,\n  StringValue,\n  NumberValue,\n  BooleanValue,\n  NullValue,\n  AbstractValue,\n  ArrayValue,\n  ObjectValue,\n} from \"../values/index.js\";\nimport { type ReactSerializerState } from \"../serializer/types.js\";\nimport { isReactElement, addKeyToReactElement, forEachArrayValue } from \"./utils\";\nimport { ExpectedBailOut } from \"./errors.js\";\nimport invariant from \"../invariant\";\n\n// Branch status is used for when Prepack returns an abstract value from a render\n// that results in a conditional path occuring. This can be problematic for reconcilation\n// as the reconciler then needs to understand if this is the start of a new branch, or if\n// it's actually deep into an existing branch. If it's a new branch, we need to apply\n// keys to the root JSX element so that it keeps it identity (because we're folding trees).\n// Furthermore, we also need to bail-out of folding class components where they have lifecycle\n// events, as we can't merge lifecycles of mutliple trees when branched reliably\nexport type BranchStatusEnum = \"ROOT\" | \"NO_BRANCH\" | \"NEW_BRANCH\" | \"BRANCH\";\n\n// Branch state is used to capture branched ReactElements so they can be analyzed and compared\n// once all branches have been processed. This allows us to add keys to the respective ReactElement\n// objects depending on various heuristics (if they have the same \"type\" for example)\n// A new branch state is created on a branch status of \"NEW_BRANCH\" and is reset to null once the branch is no\n// longer new\nexport class BranchState {\n  constructor() {\n    this._branchesToValidate = [];\n  }\n  _branchesToValidate: Array<{\n    type: StringValue | ECMAScriptSourceFunctionValue,\n    value: Value,\n  }>;\n\n  _applyBranchedLogicValue(realm: Realm, reactSerializerState: ReactSerializerState, value: Value): void {\n    if (\n      value instanceof StringValue ||\n      value instanceof NumberValue ||\n      value instanceof BooleanValue ||\n      value instanceof NullValue ||\n      value instanceof UndefinedValue\n    ) {\n      // terminal values\n    } else if (value instanceof ObjectValue && isReactElement(value)) {\n      addKeyToReactElement(realm, reactSerializerState, value);\n    } else if (value instanceof ArrayValue) {\n      forEachArrayValue(realm, value, elementValue => {\n        this._applyBranchedLogicValue(realm, reactSerializerState, elementValue);\n      });\n    } else if (value instanceof AbstractValue) {\n      let length = value.args.length;\n      if (length > 0) {\n        for (let i = 0; i < length; i++) {\n          this._applyBranchedLogicValue(realm, reactSerializerState, value.args[i]);\n        }\n      }\n    } else {\n      throw new ExpectedBailOut(\"Unsupported value encountered when applying branched logic to values\");\n    }\n  }\n\n  applyBranchedLogic(realm: Realm, reactSerializerState: ReactSerializerState): void {\n    let reactElementType;\n    let applyBranchedLogic = false;\n\n    for (let i = 0; i < this._branchesToValidate.length; i++) {\n      let { type } = this._branchesToValidate[i];\n      if (reactElementType === undefined) {\n        reactElementType = type;\n      } else if (type !== reactElementType) {\n        // the types of the ReactElements do not match, so apply branch logic\n        applyBranchedLogic = true;\n        break;\n      }\n    }\n    if (applyBranchedLogic) {\n      for (let i = 0; i < this._branchesToValidate.length; i++) {\n        this._applyBranchedLogicValue(realm, reactSerializerState, this._branchesToValidate[i].value);\n      }\n    }\n  }\n\n  captureBranchedValue(type: Value, value: Value): Value {\n    invariant(type instanceof ECMAScriptSourceFunctionValue || type instanceof StringValue);\n    this._branchesToValidate.push({ type, value });\n    return value;\n  }\n}\n"]}