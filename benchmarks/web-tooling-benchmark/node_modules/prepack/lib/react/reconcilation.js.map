{"version":3,"sources":["../../src/react/reconcilation.js"],"names":["Reconciler","constructor","realm","moduleTracer","statistics","reactSerializerState","componentTreeConfig","logger","modules","componentTreeState","_createComponentTreeState","alreadyEvaluatedRootNodes","Map","render","componentType","props","context","isRoot","evaluatedRootNode","renderComponentTree","initialProps","initialContext","result","_renderComponent","optimizedTrees","set","error","logWarning","status","message","intrinsics","undefined","diagnostic","currentLocation","handleError","wrapInGlobalEnv","evaluatePure","evaluateForEffects","getName","clearComponentTreeState","_queueNewComponentTree","rootValue","evaluatedNode","nested","branchedComponentTrees","push","_renderComplexClassComponent","classMetadata","branchStatus","branchState","evaluatedComplexNode","get","instance","renderMethod","_renderSimpleClassComponent","_renderFunctionalComponent","_getClassComponentMetadata","react","classComponentMetadata","has","_renderRelayQueryRendererComponent","reactElement","renderResult","childContext","renderProp","$Call","_findReactComponentTrees","_renderClassComponent","value","instanceProperties","instanceSymbols","size","_renderClassComponentForFirstRenderOnly","componentWillMount","componentsEvaluated","firstRenderOnly","_resolveDeeply","_getRenderStrategy","fbLibraries","reactRelay","QueryRenderer","_resolveAbstractValue","length","args","newBranchState","i","applyBranchedLogic","_resolveArray","typeValue","propsValue","refValue","resolveChildren","properties","childrenValue","resolvedChildren","refuseSerialization","Set","evaluatedChildNode","children","bailOutMessage","_assignBailOutMessage","renderStrategy","inlinedComponents","captureBranchedValue","$BailOutReason","arrayValue","elementValue","elementPropertyDescriptor","hasEvaluatedRootNode","evaluateNode","alreadyEvaluatedNode","name","arg","propName","binding","descriptor","enumerable"],"mappings":"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","file":"reconcilation.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm, type Effects } from \"../realm.js\";\nimport { ModuleTracer } from \"../utils/modules.js\";\nimport {\n  AbstractValue,\n  ECMAScriptSourceFunctionValue,\n  Value,\n  UndefinedValue,\n  StringValue,\n  NumberValue,\n  BooleanValue,\n  NullValue,\n  ArrayValue,\n  ObjectValue,\n  AbstractObjectValue,\n} from \"../values/index.js\";\nimport { ReactStatistics, type ReactSerializerState, type ReactEvaluatedNode } from \"../serializer/types.js\";\nimport {\n  isReactElement,\n  valueIsClassComponent,\n  forEachArrayValue,\n  valueIsLegacyCreateClassComponent,\n  valueIsFactoryClassComponent,\n  valueIsKnownReactAbstraction,\n  getReactSymbol,\n  flattenChildren,\n  getProperty,\n  isRenderPropFunctionSelfContained,\n  createReactEvaluatedNode,\n  getComponentName,\n  sanitizeReactElementForFirstRenderOnly,\n  getValueFromRenderCall,\n} from \"./utils\";\nimport { Get } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport { Properties } from \"../singletons.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { BranchState, type BranchStatusEnum } from \"./branching.js\";\nimport {\n  getInitialProps,\n  getInitialContext,\n  createClassInstance,\n  createSimpleClassInstance,\n  evaluateClassConstructor,\n  createClassInstanceForFirstRenderOnly,\n} from \"./components.js\";\nimport { ExpectedBailOut, SimpleClassBailOut, NewComponentTreeBranch } from \"./errors.js\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport type { ClassComponentMetadata, ReactComponentTreeConfig } from \"../types.js\";\n\ntype RenderStrategy = \"NORMAL\" | \"FRAGMENT\" | \"RELAY_QUERY_RENDERER\";\n\nexport type BranchReactComponentTree = {\n  context: ObjectValue | AbstractObjectValue | null,\n  evaluatedNode: ReactEvaluatedNode,\n  nested: boolean,\n  props: ObjectValue | AbstractObjectValue | null,\n  rootValue: ECMAScriptSourceFunctionValue | AbstractValue,\n};\n\nexport type ComponentTreeState = {\n  branchedComponentTrees: Array<BranchReactComponentTree>,\n  componentType: void | ECMAScriptSourceFunctionValue,\n  status: \"SIMPLE\" | \"COMPLEX\",\n};\n\nexport class Reconciler {\n  constructor(\n    realm: Realm,\n    moduleTracer: ModuleTracer,\n    statistics: ReactStatistics,\n    reactSerializerState: ReactSerializerState,\n    componentTreeConfig: ReactComponentTreeConfig\n  ) {\n    this.realm = realm;\n    this.moduleTracer = moduleTracer;\n    this.statistics = statistics;\n    this.reactSerializerState = reactSerializerState;\n    this.logger = moduleTracer.modules.logger;\n    this.componentTreeState = this._createComponentTreeState();\n    this.alreadyEvaluatedRootNodes = new Map();\n    this.componentTreeConfig = componentTreeConfig;\n  }\n\n  realm: Realm;\n  moduleTracer: ModuleTracer;\n  statistics: ReactStatistics;\n  reactSerializerState: ReactSerializerState;\n  logger: Logger;\n  componentTreeState: ComponentTreeState;\n  alreadyEvaluatedRootNodes: Map<ECMAScriptSourceFunctionValue, ReactEvaluatedNode>;\n  componentTreeConfig: ReactComponentTreeConfig;\n\n  render(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractObjectValue | null,\n    context: ObjectValue | AbstractObjectValue | null,\n    isRoot: boolean,\n    evaluatedRootNode: ReactEvaluatedNode\n  ): Effects {\n    const renderComponentTree = () => {\n      // initialProps and initialContext are created from Flow types from:\n      // - if a functional component, the 1st and 2nd paramater of function\n      // - if a class component, use this.props and this.context\n      // if there are no Flow types for props or context, we will throw a\n      // FatalError, unless it's a functional component that has no paramater\n      // i.e let MyComponent = () => <div>Hello world</div>\n      try {\n        let initialProps = props || getInitialProps(this.realm, componentType);\n        let initialContext = context || getInitialContext(this.realm, componentType);\n        let { result } = this._renderComponent(\n          componentType,\n          initialProps,\n          initialContext,\n          \"ROOT\",\n          null,\n          evaluatedRootNode\n        );\n        this.statistics.optimizedTrees++;\n        this.alreadyEvaluatedRootNodes.set(componentType, evaluatedRootNode);\n        return result;\n      } catch (error) {\n        // if we get an error and we're not dealing with the root\n        // rather than throw a FatalError, we log the error as a warning\n        // and continue with the other tree roots\n        // TODO: maybe control what levels gets treated as warning/error?\n        if (!isRoot) {\n          if (error instanceof AbruptCompletion) {\n            this.logger.logWarning(\n              componentType,\n              `__optimizeReactComponentTree() React component tree (branch) failed due runtime runtime exception thrown`\n            );\n            evaluatedRootNode.status = \"ABRUPT_COMPLETION\";\n          } else {\n            this.logger.logWarning(\n              componentType,\n              `__optimizeReactComponentTree() React component tree (branch) failed due to - ${error.message}`\n            );\n            evaluatedRootNode.message = \"evaluation failed on new component tree branch\";\n            evaluatedRootNode.status = \"BAIL-OUT\";\n          }\n          return this.realm.intrinsics.undefined;\n        }\n        if (error instanceof ExpectedBailOut) {\n          let diagnostic = new CompilerDiagnostic(\n            `__optimizeReactComponentTree() React component tree (root) failed due to - ${error.message}`,\n            this.realm.currentLocation,\n            \"PP0020\",\n            \"FatalError\"\n          );\n          this.realm.handleError(diagnostic);\n          if (this.realm.handleError(diagnostic) === \"Fail\") throw new FatalError();\n        }\n        throw error;\n      }\n    };\n\n    return this.realm.wrapInGlobalEnv(() =>\n      this.realm.evaluatePure(() =>\n        // TODO: (sebmarkbage): You could use the return value of this to detect if there are any mutations on objects other\n        // than newly created ones. Then log those to the error logger. That'll help us track violations in\n        // components. :)\n        this.realm.evaluateForEffects(\n          renderComponentTree,\n          /*state*/ null,\n          `react component: ${componentType.getName()}`\n        )\n      )\n    );\n  }\n\n  clearComponentTreeState() {\n    this.componentTreeState = this._createComponentTreeState();\n  }\n\n  _queueNewComponentTree(\n    rootValue: Value,\n    evaluatedNode: ReactEvaluatedNode,\n    nested?: boolean = false,\n    props?: ObjectValue | AbstractObjectValue | null = null,\n    context?: ObjectValue | AbstractObjectValue | null = null\n  ) {\n    invariant(rootValue instanceof ECMAScriptSourceFunctionValue || rootValue instanceof AbstractValue);\n    this.componentTreeState.branchedComponentTrees.push({\n      context,\n      evaluatedNode,\n      nested,\n      props,\n      rootValue,\n    });\n  }\n\n  _renderComplexClassComponent(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    classMetadata: ClassComponentMetadata,\n    branchStatus: BranchStatusEnum,\n    branchState: BranchState | null,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value {\n    if (branchStatus !== \"ROOT\") {\n      // if the tree is simple and we're not in a branch, we can make this tree complex\n      // and make this complex component the root\n      let evaluatedComplexNode = this.alreadyEvaluatedRootNodes.get(componentType);\n      if (\n        branchStatus === \"NO_BRANCH\" &&\n        this.componentTreeState.status === \"SIMPLE\" &&\n        evaluatedComplexNode &&\n        evaluatedComplexNode.status !== \"RENDER_PROPS\"\n      ) {\n        this.componentTreeState.componentType = componentType;\n      } else {\n        this._queueNewComponentTree(componentType, evaluatedNode);\n        evaluatedNode.status = \"NEW_TREE\";\n        throw new NewComponentTreeBranch();\n      }\n    }\n    this.componentTreeState.status = \"COMPLEX\";\n    // create a new instance of this React class component\n    let instance = createClassInstance(this.realm, componentType, props, context, classMetadata);\n    // get the \"render\" method off the instance\n    let renderMethod = Get(this.realm, instance, \"render\");\n    invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n    // the render method doesn't have any arguments, so we just assign the context of \"this\" to be the instance\n    return getValueFromRenderCall(this.realm, renderMethod, instance, []);\n  }\n\n  _renderSimpleClassComponent(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    branchState: BranchState | null\n  ): Value {\n    // create a new simple instance of this React class component\n    let instance = createSimpleClassInstance(this.realm, componentType, props, context);\n    // get the \"render\" method off the instance\n    let renderMethod = Get(this.realm, instance, \"render\");\n    invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n    // the render method doesn't have any arguments, so we just assign the context of \"this\" to be the instance\n    return getValueFromRenderCall(this.realm, renderMethod, instance, []);\n  }\n\n  _renderFunctionalComponent(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue\n  ) {\n    return getValueFromRenderCall(this.realm, componentType, this.realm.intrinsics.undefined, [props, context]);\n  }\n\n  _getClassComponentMetadata(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue\n  ): ClassComponentMetadata {\n    if (this.realm.react.classComponentMetadata.has(componentType)) {\n      let classMetadata = this.realm.react.classComponentMetadata.get(componentType);\n      invariant(classMetadata);\n      return classMetadata;\n    }\n    // get all this assignments in the constructor\n    let classMetadata = evaluateClassConstructor(this.realm, componentType, props, context);\n    this.realm.react.classComponentMetadata.set(componentType, classMetadata);\n    return classMetadata;\n  }\n\n  _renderRelayQueryRendererComponent(\n    componentType: Value,\n    reactElement: ObjectValue,\n    props: ObjectValue | AbstractValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    let renderResult = {\n      result: reactElement,\n      childContext: context,\n    };\n\n    if (props instanceof ObjectValue || props instanceof AbstractObjectValue) {\n      // get the \"render\" method off the instance\n      let renderProp = Get(this.realm, props, \"render\");\n      if (renderProp instanceof ECMAScriptSourceFunctionValue && renderProp.$Call) {\n        // if the render prop function is self contained, we can make it a new component tree root\n        // and this also has a nice side-effect of hoisting the function up to the top scope\n        if (isRenderPropFunctionSelfContained(this.realm, componentType, renderProp, this.logger)) {\n          this._queueNewComponentTree(renderProp, evaluatedNode, true);\n          return renderResult;\n        } else {\n          // we don't have nested additional function support right now\n          // but the render prop is likely to have references to other components\n          // that we need to also evaluate. given we can't find those components\n          return renderResult;\n        }\n      } else {\n        this._findReactComponentTrees(props, evaluatedNode);\n      }\n    }\n    // this is the worst case, we were unable to find the render prop function\n    // and won't be able to find any further components to evaluate as trees\n    // because of that\n    return renderResult;\n  }\n\n  _renderClassComponent(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    branchState: BranchState | null,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value {\n    let value;\n\n    let classMetadata = this._getClassComponentMetadata(componentType, props, context);\n    let { instanceProperties, instanceSymbols } = classMetadata;\n\n    // if there were no this assignments we can try and render it as a simple class component\n    if (instanceProperties.size === 0 && instanceSymbols.size === 0) {\n      // We first need to know what type of class component we're dealing with.\n      // A \"simple\" class component is defined as:\n      //\n      // - having only a \"render\" method\n      // - having no lifecycle events\n      // - having no state\n      // - having no instance variables\n      //\n      // the only things a class component should be able to access on \"this\" are:\n      // - this.props\n      // - this.context\n      // - this._someRenderMethodX() etc\n      //\n      // Otherwise, the class component is a \"complex\" one.\n      // To begin with, we don't know what type of component it is, so we try and render it as if it were\n      // a simple component using the above heuristics. If an error occurs during this process, we assume\n      // that the class wasn't simple, then try again with the \"complex\" heuristics.\n      try {\n        value = this._renderSimpleClassComponent(componentType, props, context, branchStatus, branchState);\n      } catch (error) {\n        // if we get back a SimpleClassBailOut error, we know that this class component\n        // wasn't a simple one and is likely to be a complex class component instead\n        if (error instanceof SimpleClassBailOut) {\n          // the component was not simple, so we continue with complex case\n        } else {\n          // else we rethrow the error\n          throw error;\n        }\n      }\n    }\n    // handle the complex class component if there is not value\n    if (value === undefined) {\n      value = this._renderComplexClassComponent(\n        componentType,\n        props,\n        context,\n        classMetadata,\n        branchStatus,\n        branchState,\n        evaluatedNode\n      );\n    }\n    return value;\n  }\n\n  _renderClassComponentForFirstRenderOnly(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    branchState: BranchState | null,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value {\n    // create a new simple instance of this React class component\n    let instance = createClassInstanceForFirstRenderOnly(this.realm, componentType, props, context);\n    // get the \"componentWillMount\" and \"render\" methods off the instance\n    let componentWillMount = Get(this.realm, instance, \"componentWillMount\");\n    let renderMethod = Get(this.realm, instance, \"render\");\n\n    if (componentWillMount instanceof ECMAScriptSourceFunctionValue && componentWillMount.$Call) {\n      componentWillMount.$Call(instance, []);\n    }\n    invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n    // the render method doesn't have any arguments, so we just assign the context of \"this\" to be the instance\n    return getValueFromRenderCall(this.realm, renderMethod, instance, []);\n  }\n\n  _renderComponent(\n    componentType: Value,\n    props: ObjectValue | AbstractValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    branchState: BranchState | null,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    this.statistics.componentsEvaluated++;\n    if (valueIsKnownReactAbstraction(this.realm, componentType)) {\n      invariant(componentType instanceof AbstractValue);\n      this._queueNewComponentTree(componentType, evaluatedNode);\n      evaluatedNode.status = \"NEW_TREE\";\n      throw new NewComponentTreeBranch();\n    }\n    invariant(componentType instanceof ECMAScriptSourceFunctionValue);\n    let value;\n    let childContext = context;\n\n    // first we check if it's a legacy class component\n    if (valueIsLegacyCreateClassComponent(this.realm, componentType)) {\n      throw new ExpectedBailOut(\"components created with create-react-class are not supported\");\n    } else if (valueIsClassComponent(this.realm, componentType)) {\n      if (this.componentTreeConfig.firstRenderOnly) {\n        value = this._renderClassComponentForFirstRenderOnly(\n          componentType,\n          props,\n          context,\n          branchStatus,\n          branchState,\n          evaluatedNode\n        );\n      } else {\n        value = this._renderClassComponent(componentType, props, context, branchStatus, branchState, evaluatedNode);\n      }\n    } else {\n      value = this._renderFunctionalComponent(componentType, props, context);\n      if (valueIsFactoryClassComponent(this.realm, value)) {\n        invariant(value instanceof ObjectValue);\n        if (branchStatus !== \"ROOT\") {\n          throw new ExpectedBailOut(\"non-root factory class components are not suppoted\");\n        } else {\n          // TODO support factory components\n          return {\n            result: value,\n            childContext,\n          };\n        }\n      }\n    }\n    invariant(value !== undefined);\n    return {\n      result: this._resolveDeeply(\n        componentType,\n        value,\n        context,\n        branchStatus === \"ROOT\" ? \"NO_BRANCH\" : branchStatus,\n        branchState,\n        evaluatedNode\n      ),\n      childContext,\n    };\n  }\n\n  _createComponentTreeState(): ComponentTreeState {\n    return {\n      branchedComponentTrees: [],\n      componentType: undefined,\n      status: \"SIMPLE\",\n    };\n  }\n\n  _getRenderStrategy(value: Value): RenderStrategy {\n    // check if it's a ReactRelay.QueryRenderer\n    if (this.realm.fbLibraries.reactRelay !== undefined) {\n      let QueryRenderer = Get(this.realm, this.realm.fbLibraries.reactRelay, \"QueryRenderer\");\n      if (value === QueryRenderer) {\n        return \"RELAY_QUERY_RENDERER\";\n      }\n    } else if (value === getReactSymbol(\"react.fragment\", this.realm)) {\n      return \"FRAGMENT\";\n    }\n    return \"NORMAL\";\n  }\n\n  _resolveAbstractValue(\n    componentType: Value,\n    value: AbstractValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    branchState: BranchState | null,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    let length = value.args.length;\n    if (length > 0) {\n      let newBranchState = new BranchState();\n      // TODO investigate what other kinds than \"conditional\" might be safe to deeply resolve\n      for (let i = 0; i < length; i++) {\n        value.args[i] = this._resolveDeeply(\n          componentType,\n          value.args[i],\n          context,\n          \"NEW_BRANCH\",\n          newBranchState,\n          evaluatedNode\n        );\n      }\n      newBranchState.applyBranchedLogic(this.realm, this.reactSerializerState);\n    }\n    return value;\n  }\n\n  _resolveDeeply(\n    componentType: Value,\n    value: Value,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    branchState: BranchState | null,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    if (\n      value instanceof StringValue ||\n      value instanceof NumberValue ||\n      value instanceof BooleanValue ||\n      value instanceof NullValue ||\n      value instanceof UndefinedValue\n    ) {\n      // terminal values\n      return value;\n    } else if (value instanceof AbstractValue) {\n      return this._resolveAbstractValue(componentType, value, context, branchStatus, branchState, evaluatedNode);\n    }\n    // TODO investigate what about other iterables type objects\n    if (value instanceof ArrayValue) {\n      this._resolveArray(componentType, value, context, branchStatus, branchState, evaluatedNode);\n      return value;\n    }\n    if (value instanceof ObjectValue && isReactElement(value)) {\n      // we call value reactElement, to make it clearer what we're dealing with in this block\n      let reactElement = this.componentTreeConfig.firstRenderOnly\n        ? sanitizeReactElementForFirstRenderOnly(this.realm, value)\n        : value;\n      let typeValue = Get(this.realm, reactElement, \"type\");\n      let propsValue = Get(this.realm, reactElement, \"props\");\n      let refValue = Get(this.realm, reactElement, \"ref\");\n\n      const resolveChildren = () => {\n        // terminal host component. Start evaluating its children.\n        if (propsValue instanceof ObjectValue && propsValue.properties.has(\"children\")) {\n          let childrenValue = getProperty(this.realm, propsValue, \"children\");\n\n          if (childrenValue instanceof Value) {\n            let resolvedChildren = this._resolveDeeply(\n              componentType,\n              childrenValue,\n              context,\n              branchStatus,\n              branchState,\n              evaluatedNode\n            );\n            // we can optimize further and flatten arrays on non-composite components\n            if (resolvedChildren instanceof ArrayValue) {\n              resolvedChildren = flattenChildren(this.realm, resolvedChildren);\n            }\n            if (propsValue.properties.has(\"children\")) {\n              propsValue.refuseSerialization = true;\n              Properties.Set(this.realm, propsValue, \"children\", resolvedChildren, true);\n              propsValue.refuseSerialization = false;\n            }\n          }\n        }\n        return reactElement;\n      };\n\n      if (typeValue instanceof StringValue) {\n        return resolveChildren();\n      }\n      // we do not support \"ref\" on <Component /> ReactElements\n      if (!(refValue instanceof NullValue)) {\n        let evaluatedChildNode = createReactEvaluatedNode(\"BAIL-OUT\", getComponentName(this.realm, typeValue));\n        evaluatedNode.children.push(evaluatedChildNode);\n        let bailOutMessage = `refs are not supported on <Components />`;\n        evaluatedChildNode.message = bailOutMessage;\n        this._queueNewComponentTree(typeValue, evaluatedChildNode);\n        this._findReactComponentTrees(propsValue, evaluatedNode);\n        this._assignBailOutMessage(reactElement, bailOutMessage);\n        return reactElement;\n      }\n      if (\n        !(\n          propsValue instanceof ObjectValue ||\n          propsValue instanceof AbstractObjectValue ||\n          propsValue instanceof AbstractValue\n        )\n      ) {\n        this._assignBailOutMessage(\n          reactElement,\n          `props on <Component /> was not not an ObjectValue or an AbstractValue`\n        );\n        return reactElement;\n      }\n      let renderStrategy = this._getRenderStrategy(typeValue);\n\n      if (\n        renderStrategy === \"NORMAL\" &&\n        !(typeValue instanceof ECMAScriptSourceFunctionValue || valueIsKnownReactAbstraction(this.realm, typeValue))\n      ) {\n        this._findReactComponentTrees(propsValue, evaluatedNode);\n        if (typeValue instanceof AbstractValue) {\n          this._findReactComponentTrees(typeValue, evaluatedNode);\n          return reactElement;\n        } else {\n          let evaluatedChildNode = createReactEvaluatedNode(\"BAIL-OUT\", getComponentName(this.realm, typeValue));\n          evaluatedNode.children.push(evaluatedChildNode);\n          let bailOutMessage = `type on <Component /> was not a ECMAScriptSourceFunctionValue`;\n          evaluatedChildNode.message = bailOutMessage;\n          this._assignBailOutMessage(reactElement, bailOutMessage);\n          return reactElement;\n        }\n      } else if (renderStrategy === \"FRAGMENT\") {\n        return resolveChildren();\n      }\n      try {\n        let result;\n        switch (renderStrategy) {\n          case \"NORMAL\": {\n            let evaluatedChildNode = createReactEvaluatedNode(\"INLINED\", getComponentName(this.realm, typeValue));\n            evaluatedNode.children.push(evaluatedChildNode);\n            let render = this._renderComponent(\n              typeValue,\n              propsValue,\n              context,\n              branchStatus === \"NEW_BRANCH\" ? \"BRANCH\" : branchStatus,\n              null,\n              evaluatedChildNode\n            );\n            result = render.result;\n            this.statistics.inlinedComponents++;\n            break;\n          }\n          case \"RELAY_QUERY_RENDERER\": {\n            invariant(typeValue instanceof AbstractObjectValue);\n            let evaluatedChildNode = createReactEvaluatedNode(\"RENDER_PROPS\", getComponentName(this.realm, typeValue));\n            evaluatedNode.children.push(evaluatedChildNode);\n            let render = this._renderRelayQueryRendererComponent(\n              componentType,\n              reactElement,\n              propsValue,\n              context,\n              evaluatedChildNode\n            );\n            result = render.result;\n            break;\n          }\n          default:\n            invariant(false, \"unsupported render strategy\");\n        }\n\n        if (result instanceof UndefinedValue) {\n          let evaluatedChildNode = createReactEvaluatedNode(\"BAIL-OUT\", getComponentName(this.realm, typeValue));\n          evaluatedNode.children.push(evaluatedChildNode);\n          let bailOutMessage = `undefined was returned from render`;\n          evaluatedChildNode.message = bailOutMessage;\n          this._assignBailOutMessage(reactElement, bailOutMessage);\n          this._findReactComponentTrees(propsValue, evaluatedNode);\n          if (branchStatus === \"NEW_BRANCH\" && branchState) {\n            return branchState.captureBranchedValue(typeValue, reactElement);\n          }\n          return reactElement;\n        }\n        if (branchStatus === \"NEW_BRANCH\" && branchState) {\n          return branchState.captureBranchedValue(typeValue, result);\n        }\n        return result;\n      } catch (error) {\n        // assign a bail out message\n        if (error instanceof NewComponentTreeBranch) {\n          // NO-OP (we don't queue a newComponentTree as this was already done)\n        } else {\n          // handle abrupt completions\n          if (error instanceof AbruptCompletion) {\n            let evaluatedChildNode = createReactEvaluatedNode(\n              \"ABRUPT_COMPLETION\",\n              getComponentName(this.realm, typeValue)\n            );\n            evaluatedNode.children.push(evaluatedChildNode);\n          } else {\n            let evaluatedChildNode = createReactEvaluatedNode(\"BAIL-OUT\", getComponentName(this.realm, typeValue));\n            evaluatedNode.children.push(evaluatedChildNode);\n            this._queueNewComponentTree(typeValue, evaluatedChildNode);\n            this._findReactComponentTrees(propsValue, evaluatedNode);\n            if (error instanceof ExpectedBailOut) {\n              evaluatedChildNode.message = error.message;\n              this._assignBailOutMessage(reactElement, error.message);\n            } else if (error instanceof FatalError) {\n              let message = \"evaluation failed\";\n              evaluatedChildNode.message = message;\n              this._assignBailOutMessage(reactElement, message);\n            } else {\n              evaluatedChildNode.message = `unknown error`;\n              throw error;\n            }\n          }\n        }\n        // a child component bailed out during component folding, so return the function value and continue\n        if (branchStatus === \"NEW_BRANCH\" && branchState) {\n          return branchState.captureBranchedValue(typeValue, reactElement);\n        }\n        return reactElement;\n      }\n    } else {\n      throw new ExpectedBailOut(\"unsupported value type during reconcilation\");\n    }\n  }\n\n  _assignBailOutMessage(reactElement: ObjectValue, message: string): void {\n    // $BailOutReason is a field on ObjectValue that allows us to specify a message\n    // that gets serialized as a comment node during the ReactElement serialization stage\n    message = `Bail-out: ${message}`;\n    if (reactElement.$BailOutReason !== undefined) {\n      // merge bail out messages if one already exists\n      reactElement.$BailOutReason += `, ${message}`;\n    } else {\n      reactElement.$BailOutReason = message;\n    }\n  }\n\n  _resolveArray(\n    componentType: Value,\n    arrayValue: ArrayValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    branchState: BranchState | null,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    forEachArrayValue(this.realm, arrayValue, (elementValue, elementPropertyDescriptor) => {\n      elementPropertyDescriptor.value = this._resolveDeeply(\n        componentType,\n        elementValue,\n        context,\n        \"NEW_BRANCH\",\n        branchState,\n        evaluatedNode\n      );\n    });\n  }\n\n  hasEvaluatedRootNode(componentType: ECMAScriptSourceFunctionValue, evaluateNode: ReactEvaluatedNode): boolean {\n    if (this.alreadyEvaluatedRootNodes.has(componentType)) {\n      let alreadyEvaluatedNode = this.alreadyEvaluatedRootNodes.get(componentType);\n      invariant(alreadyEvaluatedNode);\n      evaluateNode.children = alreadyEvaluatedNode.children;\n      evaluateNode.status = alreadyEvaluatedNode.status;\n      evaluateNode.name = alreadyEvaluatedNode.name;\n      return true;\n    }\n    return false;\n  }\n\n  _findReactComponentTrees(value: Value, evaluatedNode: ReactEvaluatedNode): void {\n    if (value instanceof AbstractValue) {\n      for (let arg of value.args) {\n        this._findReactComponentTrees(arg, evaluatedNode);\n      }\n    } else if (value instanceof ObjectValue) {\n      for (let [propName, binding] of value.properties) {\n        if (binding && binding.descriptor && binding.enumerable) {\n          this._findReactComponentTrees(getProperty(this.realm, value, propName), evaluatedNode);\n        }\n      }\n    } else if (value instanceof ECMAScriptSourceFunctionValue || valueIsKnownReactAbstraction(this.realm, value)) {\n      let evaluatedChildNode = createReactEvaluatedNode(\"NEW_TREE\", getComponentName(this.realm, value));\n      evaluatedNode.children.push(evaluatedChildNode);\n      this._queueNewComponentTree(value, evaluatedChildNode);\n    }\n  }\n}\n"]}