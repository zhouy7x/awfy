{"version":3,"sources":["../../src/react/components.js"],"names":["getInitialProps","getInitialContext","createSimpleClassInstance","createClassInstanceForFirstRenderOnly","createClassInstance","evaluateClassConstructor","t","lifecycleMethods","Set","whitelistedProperties","realm","componentType","propsName","$FormalParameters","length","firstParam","isIdentifier","name","value","createAbstractObject","contextName","superTypeParameters","$SuperTypeParameters","undefined","secondParam","props","context","componentPrototype","instance","allowedPropertyAccess","properties","has","add","$GetOwnProperty","P","call","refuseSerialization","deeplyApplyInstancePrototypeProperties","classMetadata","instanceProperties","instanceSymbols","proto","$Prototype","intrinsics","ObjectPrototype","symbol","symbols","setState","_context","state","callback","stateToUpdate","currentState","$Call","key","binding","descriptor","enumerable","intrinsicName","constructorFunc","evaluatePure","evaluateForEffects","propertyName","getName"],"mappings":"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","file":"components.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport {\n  ECMAScriptSourceFunctionValue,\n  AbstractValue,\n  ObjectValue,\n  AbstractObjectValue,\n  SymbolValue,\n  NativeFunctionValue,\n} from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeIdentifier } from \"babel-types\";\nimport { valueIsClassComponent, deleteRefAndKeyFromProps, getProperty } from \"./utils\";\nimport { ExpectedBailOut, SimpleClassBailOut } from \"./errors.js\";\nimport { Get, Construct } from \"../methods/index.js\";\nimport { Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { ClassComponentMetadata } from \"../types.js\";\n\nconst lifecycleMethods = new Set([\n  \"componentWillUnmount\",\n  \"componentDidMount\",\n  \"componentWillMount\",\n  \"componentDidUpdate\",\n  \"componentWillUpdate\",\n  \"componentDidCatch\",\n  \"componentWillReceiveProps\",\n]);\n\nconst whitelistedProperties = new Set([\"props\", \"context\", \"refs\"]);\n\nexport function getInitialProps(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue | null\n): AbstractObjectValue {\n  let propsName = null;\n  if (componentType !== null) {\n    if (valueIsClassComponent(realm, componentType)) {\n      propsName = \"this.props\";\n    } else {\n      // otherwise it's a functional component, where the first paramater of the function is \"props\" (if it exists)\n      if (componentType.$FormalParameters.length > 0) {\n        let firstParam = componentType.$FormalParameters[0];\n        if (t.isIdentifier(firstParam)) {\n          propsName = ((firstParam: any): BabelNodeIdentifier).name;\n        }\n      }\n    }\n  }\n  let value = AbstractValue.createAbstractObject(realm, propsName || \"props\");\n  // props objects don't have a key and ref, so we remove them\n  deleteRefAndKeyFromProps(realm, value);\n  invariant(value instanceof AbstractObjectValue);\n  return value;\n}\n\nexport function getInitialContext(realm: Realm, componentType: ECMAScriptSourceFunctionValue): AbstractObjectValue {\n  let contextName = null;\n  if (valueIsClassComponent(realm, componentType)) {\n    // it's a class component, so we need to check the type on for context of the component prototype\n    let superTypeParameters = componentType.$SuperTypeParameters;\n    contextName = \"this.context\";\n\n    if (superTypeParameters !== undefined) {\n      throw new ExpectedBailOut(\"context on class components not yet supported\");\n    }\n  } else {\n    // otherwise it's a functional component, where the second paramater of the function is \"context\" (if it exists)\n    if (componentType.$FormalParameters.length > 1) {\n      let secondParam = componentType.$FormalParameters[1];\n      if (t.isIdentifier(secondParam)) {\n        contextName = ((secondParam: any): BabelNodeIdentifier).name;\n      }\n    }\n  }\n  let value = AbstractValue.createAbstractObject(realm, contextName || \"context\");\n  return value;\n}\n\nexport function createSimpleClassInstance(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue,\n  props: ObjectValue | AbstractValue,\n  context: ObjectValue | AbstractValue\n): AbstractObjectValue {\n  let componentPrototype = Get(realm, componentType, \"prototype\");\n  invariant(componentPrototype instanceof ObjectValue);\n  // create an instance object and disable serialization as we don't want to output the internals we set below\n  let instance = new ObjectValue(realm, componentPrototype, \"this\", true);\n  let allowedPropertyAccess = new Set([\"props\", \"context\"]);\n  for (let [name] of componentPrototype.properties) {\n    if (lifecycleMethods.has(name)) {\n      // this error will result in the simple class falling back to a complex class\n      throw new SimpleClassBailOut(\"lifecycle methods are not supported on simple classes\");\n    } else if (name !== \"constructor\") {\n      allowedPropertyAccess.add(name);\n      Properties.Set(realm, instance, name, Get(realm, componentPrototype, name), true);\n    }\n  }\n  // assign props\n  Properties.Set(realm, instance, \"props\", props, true);\n  // assign context\n  Properties.Set(realm, instance, \"context\", context, true);\n  // as this object is simple, we want to check if any access to anything other than\n  // \"this.props\" or \"this.context\" or methods on the class occur\n  let $GetOwnProperty = instance.$GetOwnProperty;\n  instance.$GetOwnProperty = P => {\n    if (!allowedPropertyAccess.has(P)) {\n      // this error will result in the simple class falling back to a complex class\n      throw new SimpleClassBailOut(\"access to basic class instance properties is not supported on simple classes\");\n    }\n    return $GetOwnProperty.call(instance, P);\n  };\n  // enable serialization to support simple instance variables properties\n  instance.refuseSerialization = false;\n  // return the instance\n  return instance;\n}\n\nfunction deeplyApplyInstancePrototypeProperties(\n  realm: Realm,\n  instance: ObjectValue,\n  componentPrototype: ObjectValue,\n  classMetadata: ClassComponentMetadata\n) {\n  let { instanceProperties, instanceSymbols } = classMetadata;\n  let proto = componentPrototype.$Prototype;\n\n  if (proto instanceof ObjectValue && proto !== realm.intrinsics.ObjectPrototype) {\n    deeplyApplyInstancePrototypeProperties(realm, instance, proto, classMetadata);\n  }\n\n  for (let [name] of componentPrototype.properties) {\n    // ensure we don't set properties that were defined on the instance\n    if (name !== \"constructor\" && !instanceProperties.has(name)) {\n      Properties.Set(realm, instance, name, Get(realm, componentPrototype, name), true);\n    }\n  }\n  for (let [symbol] of componentPrototype.symbols) {\n    // ensure we don't set symbols that were defined on the instance\n    if (!instanceSymbols.has(symbol)) {\n      Properties.Set(realm, instance, symbol, Get(realm, componentPrototype, symbol), true);\n    }\n  }\n}\n\nexport function createClassInstanceForFirstRenderOnly(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue,\n  props: ObjectValue | AbstractValue,\n  context: ObjectValue | AbstractValue\n): ObjectValue {\n  let instance = Construct(realm, componentType, [props, context]);\n  invariant(instance instanceof ObjectValue);\n  instance.refuseSerialization = true;\n  // assign props\n  Properties.Set(realm, instance, \"props\", props, true);\n  // assign context\n  Properties.Set(realm, instance, \"context\", context, true);\n  // assign a mocked setState\n  let setState = new NativeFunctionValue(realm, undefined, `setState`, 1, (_context, [state, callback]) => {\n    let stateToUpdate = state;\n    let currentState = Get(realm, instance, \"state\");\n    invariant(currentState instanceof ObjectValue);\n\n    if (state instanceof ECMAScriptSourceFunctionValue && state.$Call) {\n      stateToUpdate = state.$Call(instance, [currentState]);\n    }\n    if (stateToUpdate instanceof ObjectValue) {\n      for (let [key, binding] of stateToUpdate.properties) {\n        if (binding && binding.descriptor && binding.descriptor.enumerable) {\n          let value = getProperty(realm, stateToUpdate, key);\n          Properties.Set(realm, currentState, key, value, true);\n        }\n      }\n    }\n    if (callback instanceof ECMAScriptSourceFunctionValue && callback.$Call) {\n      callback.$Call(instance, []);\n    }\n    return realm.intrinsics.undefined;\n  });\n  setState.intrinsicName = \"this.setState\";\n  Properties.Set(realm, instance, \"setState\", setState, true);\n\n  instance.refuseSerialization = false;\n  return instance;\n}\n\nexport function createClassInstance(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue,\n  props: ObjectValue | AbstractValue,\n  context: ObjectValue | AbstractValue,\n  classMetadata: ClassComponentMetadata\n): AbstractObjectValue {\n  let componentPrototype = Get(realm, componentType, \"prototype\");\n  invariant(componentPrototype instanceof ObjectValue);\n  // create an instance object and disable serialization as we don't want to output the internals we set below\n  let instance = new ObjectValue(realm, componentPrototype, \"this\", true);\n  deeplyApplyInstancePrototypeProperties(realm, instance, componentPrototype, classMetadata);\n\n  // assign refs\n  Properties.Set(realm, instance, \"refs\", AbstractValue.createAbstractObject(realm, \"this.refs\"), true);\n  // assign props\n  Properties.Set(realm, instance, \"props\", props, true);\n  // assign context\n  Properties.Set(realm, instance, \"context\", context, true);\n  // enable serialization to support simple instance variables properties\n  instance.refuseSerialization = false;\n  // return the instance in an abstract object\n  let value = AbstractValue.createAbstractObject(realm, \"this\", instance);\n  invariant(value instanceof AbstractObjectValue);\n  return value;\n}\n\nexport function evaluateClassConstructor(\n  realm: Realm,\n  constructorFunc: ECMAScriptSourceFunctionValue,\n  props: ObjectValue | AbstractValue | AbstractObjectValue,\n  context: ObjectValue | AbstractObjectValue\n): { instanceProperties: Set<string>, instanceSymbols: Set<SymbolValue> } {\n  let instanceProperties = new Set();\n  let instanceSymbols = new Set();\n\n  realm.evaluatePure(() =>\n    realm.evaluateForEffects(\n      () => {\n        let instance = Construct(realm, constructorFunc, [props, context]);\n        invariant(instance instanceof ObjectValue);\n        for (let [propertyName] of instance.properties) {\n          if (!whitelistedProperties.has(propertyName)) {\n            instanceProperties.add(propertyName);\n          }\n        }\n        for (let [symbol] of instance.symbols) {\n          instanceSymbols.add(symbol);\n        }\n        return instance;\n      },\n      /*state*/ null,\n      `react component constructor: ${constructorFunc.getName()}`\n    )\n  );\n\n  return {\n    instanceProperties,\n    instanceSymbols,\n  };\n}\n"]}