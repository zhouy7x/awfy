"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMockReactRelay = createMockReactRelay;

var _index = require("../../values/index.js");

var _singletons = require("../../singletons.js");

var _utils = require("../prepack/utils.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _index2 = require("../../domains/index.js");

var _invariant = require("../../invariant");

var _invariant2 = _interopRequireDefault(_invariant);

var _utils2 = require("../../react/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function createReactRelayContainer(realm, reactRelay, containerName) {
  // we create a ReactRelay container function that returns an abstract object
  // allowing us to reconstruct this ReactReact.createSomeContainer(...) again
  // we also pass a reactHint so the reconciler can properly deal with this
  reactRelay.$DefineOwnProperty(containerName, {
    value: new _index.NativeFunctionValue(realm, undefined, containerName, 0, (context, args) => {
      let types = new _index2.TypesDomain(_index.FunctionValue);
      let values = new _index2.ValuesDomain();
      (0, _invariant2.default)(context.$Realm.generator);
      let value = context.$Realm.generator.derive(types, values, [reactRelay, ...args], _args => {
        let [reactRelayIdent, ...otherArgs] = _args;

        return t.callExpression(t.memberExpression(reactRelayIdent, t.identifier(containerName)), otherArgs);
      });
      realm.react.abstractHints.set(value, (0, _utils2.createReactHintObject)(reactRelay, containerName, args));
      return value;
    }),
    writable: false,
    enumerable: false,
    configurable: true
  });
}

function createMockReactRelay(realm, relayRequireName) {
  // we set refuseSerialization to true so we don't serialize the below properties straight away
  let reactRelay = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, `require("${relayRequireName}")`, true);
  // for QueryRenderer, we want to leave the component alone but process it's "render" prop
  let queryRendererComponent = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").QueryRenderer`);
  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "QueryRenderer", queryRendererComponent);

  let graphql = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").graphql`);
  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "graphql", graphql);

  let reactRelayContainers = ["createFragmentContainer", "createPaginationContainer", "createRefetchContainer"];
  for (let reactRelayContainer of reactRelayContainers) {
    createReactRelayContainer(realm, reactRelay, reactRelayContainer);
  }

  let commitLocalUpdate = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").commitLocalUpdate`);
  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "commitLocalUpdate", commitLocalUpdate);

  let commitMutation = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").commitMutation`);
  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "commitMutation", commitMutation);

  let fetchQuery = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").fetchQuery`);
  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "fetchQuery", fetchQuery);

  let requestSubscription = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").requestSubscription`);
  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "requestSubscription", requestSubscription);

  // we set refuseSerialization back to false
  reactRelay.refuseSerialization = false;
  return reactRelay;
}
//# sourceMappingURL=relay-mocks.js.map