{"version":3,"sources":["../../../src/intrinsics/fb-www/react-mocks.js"],"names":["createMockReact","reactCode","reactAst","plugins","realm","reactRequireName","reactFactory","GetValue","$GlobalEnv","evaluate","currentOwner","react","intrinsics","ObjectPrototype","factory","$Call","undefined","reactValue","intrinsicName","reactComponentValue","reactPureComponentValue","$FunctionKind","reactComponentPrototypeValue","reactPureComponentPrototypeValue","reactCloneElementValue","refuseSerialization","reactElementValue","context","type","config","children","Array","isArray","length","array","ArrayCreate","i","CreateDataPropertyOrThrow","$DefineOwnProperty","value","writable","enumerable","configurable","reactIsValidElementValue","reactChildrenValue","reactPropTypesValue"],"mappings":"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","file":"react-mocks.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport { parseExpression } from \"babylon\";\nimport {\n  ObjectValue,\n  ECMAScriptFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  NativeFunctionValue,\n  Value,\n  AbstractObjectValue,\n  AbstractValue,\n  NullValue,\n} from \"../../values/index.js\";\nimport { Get } from \"../../methods/index.js\";\nimport { Environment } from \"../../singletons.js\";\nimport { getReactSymbol } from \"../../react/utils.js\";\nimport { createReactElement } from \"../../react/elements.js\";\nimport { Create } from \"../../singletons.js\";\nimport invariant from \"../../invariant\";\n\n// most of the code here was taken from https://github.com/facebook/react/blob/master/packages/react/src/ReactElement.js\nlet reactCode = `\n  function createReact(REACT_ELEMENT_TYPE, REACT_FRAGMENT_TYPE, REACT_PORTAL_TYPE, ReactCurrentOwner) {\n    function makeEmptyFunction(arg) {\n      return function() {\n        return arg;\n      };\n    }\n    var emptyFunction = function() {};\n    \n    emptyFunction.thatReturns = makeEmptyFunction;\n    emptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n    emptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n    emptyFunction.thatReturnsNull = makeEmptyFunction(null);\n    emptyFunction.thatReturnsThis = function() { return this; };\n    emptyFunction.thatReturnsArgument = function(arg) { return arg; };\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true,\n    };\n\n    var ReactElement = function(type, key, ref, self, source, owner, props) {\n      return {\n        // This tag allow us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n    \n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n    \n        // Record the component responsible for creating this element.\n        _owner: owner,\n      };\n    };\n\n    function hasValidRef(config) {\n      return config.ref !== undefined;\n    }\n    \n    function hasValidKey(config) {\n      return config.key !== undefined;\n    }\n\n    function Component(props, context) {\n      this.props = props;\n      this.context = context;\n      this.refs = {};\n    }\n    \n    Component.prototype.isReactComponent = {};\n\n    function PureComponent(props, context) {\n      this.props = props;\n      this.context = context;\n      this.refs = {};\n    }\n\n    PureComponent.prototype.isReactComponent = {};\n    PureComponent.prototype.isPureReactComponent = true;\n\n    var userProvidedKeyEscapeRegex = /\\/+/g;\n\n    function escapeUserProvidedKey(text) {\n      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n    }\n\n    function escape(key) {\n      const escapeRegex = /[=:]/g;\n      const escaperLookup = {\n        '=': '=0',\n        ':': '=2',\n      };\n      const escapedString = ('' + key).replace(escapeRegex, function(match) {\n        return escaperLookup[match];\n      });\n    \n      return '$' + escapedString;\n    }\n\n    var SEPARATOR = '.';\n    var SUBSEPARATOR = ':';\n    var POOL_SIZE = 10;\n    var traverseContextPool = [];\n    function getPooledTraverseContext(\n      mapResult,\n      keyPrefix,\n      mapFunction,\n      mapContext,\n    ) {\n      if (traverseContextPool.length) {\n        const traverseContext = traverseContextPool.pop();\n        traverseContext.result = mapResult;\n        traverseContext.keyPrefix = keyPrefix;\n        traverseContext.func = mapFunction;\n        traverseContext.context = mapContext;\n        traverseContext.count = 0;\n        return traverseContext;\n      } else {\n        return {\n          result: mapResult,\n          keyPrefix: keyPrefix,\n          func: mapFunction,\n          context: mapContext,\n          count: 0,\n        };\n      }\n    }\n\n    function releaseTraverseContext(traverseContext) {\n      traverseContext.result = null;\n      traverseContext.keyPrefix = null;\n      traverseContext.func = null;\n      traverseContext.context = null;\n      traverseContext.count = 0;\n      if (traverseContextPool.length < POOL_SIZE) {\n        traverseContextPool.push(traverseContext);\n      }\n    }\n\n    function traverseAllChildren(children, callback, traverseContext) {\n      if (children == null) {\n        return 0;\n      }\n    \n      return traverseAllChildrenImpl(children, '', callback, traverseContext);\n    }\n\n    function getComponentKey(component, index) {\n      // Do some typechecking here since we call this blindly. We want to ensure\n      // that we don't block potential future ES APIs.\n      if (\n        typeof component === 'object' &&\n        component !== null &&\n        component.key != null\n      ) {\n        // Explicit key\n        return escape(component.key);\n      }\n      // Implicit key determined by the index in the set\n      return index.toString(36);\n    }\n\n    function traverseAllChildrenImpl(\n      children,\n      nameSoFar,\n      callback,\n      traverseContext,\n    ) {\n      const type = typeof children;\n    \n      if (type === 'undefined' || type === 'boolean') {\n        // All of the above are perceived as null.\n        children = null;\n      }\n    \n      let invokeCallback = false;\n    \n      if (children === null) {\n        invokeCallback = true;\n      } else {\n        switch (type) {\n          case 'string':\n          case 'number':\n            invokeCallback = true;\n            break;\n          case 'object':\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = true;\n            }\n        }\n      }\n    \n      if (invokeCallback) {\n        callback(\n          traverseContext,\n          children,\n          // If it's the only child, treat the name as if it was wrapped in an array\n          // so that it's consistent if the number of children grows.\n          nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,\n        );\n        return 1;\n      }\n    \n      let child;\n      let nextName;\n      let subtreeCount = 0; // Count of children found in the current subtree.\n      const nextNamePrefix =\n        nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n    \n      if (Array.isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n          child = children[i];\n          nextName = nextNamePrefix + getComponentKey(child, i);\n          subtreeCount += traverseAllChildrenImpl(\n            child,\n            nextName,\n            callback,\n            traverseContext,\n          );\n        }\n      } else {\n        const iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {    \n          var iterator = iteratorFn.call(children);\n          let step;\n          let ii = 0;\n          while (!(step = iterator.next()).done) {\n            child = step.value;\n            nextName = nextNamePrefix + getComponentKey(child, ii++);\n            subtreeCount += traverseAllChildrenImpl(\n              child,\n              nextName,\n              callback,\n              traverseContext,\n            );\n          }\n        } else if (type === 'object') {\n          let addendum = '';\n          var childrenString = '' + children;\n        }\n      }\n    \n      return subtreeCount;\n    }\n\n    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n      var escapedPrefix = '';\n      if (prefix != null) {\n        escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n      }\n      const traverseContext = getPooledTraverseContext(\n        array,\n        escapedPrefix,\n        func,\n        context,\n      );\n      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n      releaseTraverseContext(traverseContext);\n    }\n\n    function forEachSingleChild(bookKeeping, child, name) {\n      const {func, context} = bookKeeping;\n      func.call(context, child, bookKeeping.count++);\n    }\n\n    function forEachChildren(children, forEachFunc, forEachContext) {\n      if (children == null) {\n        return children;\n      }\n      var traverseContext = getPooledTraverseContext(\n        null,\n        null,\n        forEachFunc,\n        forEachContext,\n      );\n      traverseAllChildren(children, forEachSingleChild, traverseContext);\n      releaseTraverseContext(traverseContext);\n    }\n\n    function mapChildren(children, func, context) {\n      if (children == null) {\n        return children;\n      }\n      var result = [];\n      mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n      return result;\n    }\n\n    function countChildren(children) {\n      return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);\n    }\n\n    function onlyChild(children) {\n      return children;\n    }\n\n    function toArray(children) {\n      var result = [];\n      mapIntoWithKeyPrefixInternal(\n        children,\n        result,\n        null,\n        emptyFunction.thatReturnsArgument,\n      );\n      return result;\n    }\n\n    function cloneElement(element, config, children) {\n      var propName;\n      \n      // Original props are copied\n      var props = Object.assign({}, element.props);\n    \n      // Reserved names are extracted\n      var key = element.key;\n      var ref = element.ref;\n      // Self is preserved since the owner is preserved.\n      var self = element._self;\n      // Source is preserved since cloneElement is unlikely to be targeted by a\n      // transpiler, and the original source is probably a better indicator of the\n      // true owner.\n      var source = element._source;\n    \n      // Owner will be preserved, unless ref is overridden\n      var owner = element._owner;\n    \n      if (config != null) {\n        if (hasValidRef(config)) {\n          // Silently steal the ref from the parent.\n          ref = config.ref;\n          owner = ReactCurrentOwner.current;\n        }\n        if (hasValidKey(config)) {\n          key = '' + config.key;\n        }\n    \n        // Remaining properties override existing props\n        var defaultProps;\n        if (element.type && element.type.defaultProps) {\n          defaultProps = element.type.defaultProps;\n        }\n        for (propName in config) {\n          if (\n            hasOwnProperty.call(config, propName) &&\n            !RESERVED_PROPS.hasOwnProperty(propName)\n          ) {\n            if (config[propName] === undefined && defaultProps !== undefined) {\n              // Resolve default props\n              props[propName] = defaultProps[propName];\n            } else {\n              props[propName] = config[propName];\n            }\n          }\n        }\n      }\n    \n      // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        props.children = childArray;\n      }\n    \n      return ReactElement(element.type, key, ref, self, source, owner, props);\n    }\n\n    function isValidElement(object) {\n      return (\n        typeof object === 'object' &&\n        object !== null &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n\n    function shim() {\n\n    }\n    shim.isRequired = shim;\n\n    function getShim() {\n      return shim;\n    };\n\n    var ReactPropTypes = {\n      array: shim,\n      bool: shim,\n      func: shim,\n      number: shim,\n      object: shim,\n      string: shim,\n      symbol: shim,\n  \n      any: shim,\n      arrayOf: getShim,\n      element: shim,\n      instanceOf: getShim,\n      node: shim,\n      objectOf: getShim,\n      oneOf: getShim,\n      oneOfType: getShim,\n      shape: getShim,\n      exact: getShim\n    };\n\n    ReactPropTypes.checkPropTypes = shim;\n    ReactPropTypes.PropTypes = ReactPropTypes;\n\n    return {\n      Children: {\n        forEach: forEachChildren,\n        map: mapChildren,\n        count: countChildren,\n        only: onlyChild,\n        toArray,\n      },\n      Component,\n      PureComponent,\n      Fragment: REACT_FRAGMENT_TYPE,\n      cloneElement,\n      isValidElement,\n      version: \"16.2.0\",\n      PropTypes: ReactPropTypes,\n    };\n  }\n`;\nlet reactAst = parseExpression(reactCode, { plugins: [\"flow\"] });\n\nexport function createMockReact(realm: Realm, reactRequireName: string): ObjectValue {\n  let reactFactory = Environment.GetValue(realm, realm.$GlobalEnv.evaluate(reactAst, false));\n  invariant(reactFactory instanceof ECMAScriptSourceFunctionValue);\n\n  let currentOwner = (realm.react.currentOwner = new ObjectValue(\n    realm,\n    realm.intrinsics.ObjectPrototype,\n    \"currentOwner\"\n  ));\n  // this is to get around Flow getting confused\n  let factory = reactFactory.$Call;\n  invariant(factory !== undefined);\n\n  let reactValue = factory(realm.intrinsics.undefined, [\n    getReactSymbol(\"react.element\", realm),\n    getReactSymbol(\"react.fragment\", realm),\n    getReactSymbol(\"react.portal\", realm),\n    currentOwner,\n  ]);\n  invariant(reactValue instanceof ObjectValue);\n  reactValue.intrinsicName = `require(\"${reactRequireName}\")`;\n  invariant(reactValue instanceof ObjectValue);\n\n  let reactComponentValue = Get(realm, reactValue, \"Component\");\n  reactComponentValue.intrinsicName = `require(\"${reactRequireName}\").Component`;\n  invariant(reactComponentValue instanceof ECMAScriptFunctionValue);\n  let reactPureComponentValue = Get(realm, reactValue, \"PureComponent\");\n  reactPureComponentValue.intrinsicName = `require(\"${reactRequireName}\").PureComponent`;\n  invariant(reactPureComponentValue instanceof ECMAScriptFunctionValue);\n  reactComponentValue.$FunctionKind = \"normal\";\n  invariant(reactComponentValue instanceof ObjectValue);\n\n  let reactComponentPrototypeValue = Get(realm, reactComponentValue, \"prototype\");\n  reactComponentPrototypeValue.intrinsicName = `require(\"${reactRequireName}\").Component.prototype`;\n\n  let reactPureComponentPrototypeValue = Get(realm, reactPureComponentValue, \"prototype\");\n  reactPureComponentPrototypeValue.intrinsicName = `require(\"${reactRequireName}\").PureComponent.prototype`;\n\n  let reactCloneElementValue = Get(realm, reactValue, \"cloneElement\");\n  reactCloneElementValue.intrinsicName = `require(\"${reactRequireName}\").cloneElement`;\n\n  reactValue.refuseSerialization = true;\n  let reactElementValue = new NativeFunctionValue(\n    realm,\n    undefined,\n    `createElement`,\n    0,\n    (context, [type, config, ...children]) => {\n      invariant(type instanceof Value);\n      invariant(\n        config instanceof ObjectValue ||\n          config instanceof AbstractObjectValue ||\n          config instanceof AbstractValue ||\n          config instanceof NullValue\n      );\n\n      if (Array.isArray(children)) {\n        if (children.length === 0) {\n          children = realm.intrinsics.undefined;\n        } else if (children.length === 1) {\n          children = children[0];\n        } else {\n          let array = Create.ArrayCreate(realm, 0);\n          let length = children.length;\n\n          for (let i = 0; i < length; i++) {\n            Create.CreateDataPropertyOrThrow(realm, array, \"\" + i, children[i]);\n          }\n          children = array;\n        }\n      }\n      invariant(children instanceof Value);\n      return createReactElement(realm, type, config, children);\n    }\n  );\n  reactValue.$DefineOwnProperty(\"createElement\", {\n    value: reactElementValue,\n    writable: false,\n    enumerable: false,\n    configurable: true,\n  });\n  reactValue.refuseSerialization = false;\n  reactElementValue.intrinsicName = `require(\"${reactRequireName}\").createElement`;\n\n  let reactIsValidElementValue = Get(realm, reactValue, \"isValidElement\");\n  reactIsValidElementValue.intrinsicName = `require(\"${reactRequireName}\").isValidElement`;\n\n  let reactChildrenValue = Get(realm, reactValue, \"Children\");\n  reactChildrenValue.intrinsicName = `require(\"${reactRequireName}\").Children`;\n\n  let reactPropTypesValue = Get(realm, reactValue, \"PropTypes\");\n  reactPropTypesValue.intrinsicName = `require(\"${reactRequireName}\").PropTypes`;\n\n  return reactValue;\n}\n"]}