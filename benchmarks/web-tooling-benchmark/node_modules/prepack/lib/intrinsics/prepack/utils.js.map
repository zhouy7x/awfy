{"version":3,"sources":["../../../src/intrinsics/prepack/utils.js"],"names":["parseTypeNameOrTemplate","createAbstractArgument","createAbstract","throwTemplateSrc","throwTemplate","realm","typeNameOrTemplate","undefined","type","template","getTypeFromName","createErrorThrowCompletion","intrinsics","TypeError","typeNameString","ToStringPartial","hasFunctionResultType","startsWith","substring","functionResultType","name","location","useAbstractInterpretation","locString","locVal","kind","objectCount","result","createFromTemplate","intrinsicName","additionalValues","loc","executionContext","contextStack","slice","reverse","caller","function","lexicalEnvironment","isNameStringUnique","error","handleError","saveNameString","values","Set","makePartial","rebuildNestedProperties","length","createAbstractConcreteUnion"],"mappings":";;;;;QAkCgBA,uB,GAAAA,uB;QAgCAC,sB,GAAAA,sB;QAeAC,c,GAAAA,c;;AArEhB;;AASA;;;;AACA;;AACA;;AACA;;AACA;;;;AACA;;AACA;;AAEA;;;;;;AA7BA;;;;;;;;;AA+BA,MAAMC,mBAAmB,2EAAzB;AACA,MAAMC,gBAAgB,uBAAwBD,gBAAxB,CAAtB;;AAEO,SAASH,uBAAT,CACLK,KADK,EAELC,kBAFK,EAGoF;AACzF,MAAIA,uBAAuBC,SAAvB,IAAoCD,mDAAxC,EAAsF;AACpF,WAAO,EAAEE,kBAAF,EAAeC,UAAUF,SAAzB,EAAP;AACD,GAFD,MAEO,IAAI,OAAOD,kBAAP,KAA8B,QAAlC,EAA4C;AACjD,QAAIE,OAAO,mBAAME,eAAN,CAAsBJ,kBAAtB,CAAX;AACA,QAAIE,SAASD,SAAb,EAAwB;AACtB,YAAMF,MAAMM,0BAAN,CAAiCN,MAAMO,UAAN,CAAiBC,SAAlD,EAA6D,4BAA7D,CAAN;AACD;AACD,WAAO,EAAEL,IAAF,EAAQC,UAAUF,SAAlB,EAAP;AACD,GANM,MAMA,IAAID,gDAAJ,EAA+C;AACpD,QAAIQ,iBAAiB,eAAGC,eAAH,CAAmBV,KAAnB,EAA0BC,kBAA1B,CAArB;AACA,QAAIU,wBAAwBF,eAAeG,UAAf,CAA0B,GAA1B,CAA5B;AACA,QAAID,qBAAJ,EAA2BF,iBAAiBA,eAAeI,SAAf,CAAyB,CAAzB,CAAjB;AAC3B,QAAIV,OAAO,mBAAME,eAAN,CAAsBI,cAAtB,CAAX;AACA,QAAIN,SAASD,SAAb,EAAwB;AACtB,YAAMF,MAAMM,0BAAN,CAAiCN,MAAMO,UAAN,CAAiBC,SAAlD,EAA6D,4BAA7D,CAAN;AACD;AACD,WAAOG,wBACH,EAAER,0BAAF,EAAuBC,UAAUF,SAAjC,EAA4CY,oBAAoBX,IAAhE,EADG,GAEH,EAAEA,IAAF,EAAQC,UAAUF,SAAlB,EAFJ;AAGD,GAXM,MAWA,IAAID,kDAAJ,EAAiD;AACtD,WAAO,EAAEE,0BAAF,EAAuBC,UAAUH,kBAAjC,EAAP;AACD,GAFM,MAEA,IAAIA,gDAAJ,EAA+C;AACpD,WAAO,EAAEE,wBAAF,EAAqBC,UAAUH,kBAA/B,EAAP;AACD,GAFM,MAEA;AACL,UAAMD,MAAMM,0BAAN,CAAiCN,MAAMO,UAAN,CAAiBC,SAAlD,EAA6D,yCAA7D,CAAN;AACD;AACF;;AAEM,SAASZ,sBAAT,CAAgCI,KAAhC,EAA8Ce,IAA9C,EAA4DC,QAA5D,EAAgG;AACrG,MAAI,CAAChB,MAAMiB,yBAAX,EAAsC;AACpC,UAAMjB,MAAMM,0BAAN,CAAiCN,MAAMO,UAAN,CAAiBC,SAAlD,EAA6D,sBAA7D,CAAN;AACD;;AAED,MAAIU,SAAJ;AACA,MAAIF,QAAJ,EAAcE,YAAY,6BAAiBlB,KAAjB,EAAwBE,SAAxB,EAAmCA,SAAnC,EAA8Cc,QAA9C,CAAZ;AACd,MAAIG,SAAS,uBAAgBnB,KAAhB,EAAuBkB,aAAa,oBAApC,CAAb;AACA,MAAIE,OAAO,gBAAgBpB,MAAMqB,WAAN,EAA3B,CARqG,CAQrD;AAChD,MAAIC,SAAS,qBAAcC,kBAAd,CAAiCvB,KAAjC,EAAwC,uBAAwBe,IAAxB,CAAxC,gBAA8E,CAACI,MAAD,CAA9E,EAAwFC,IAAxF,CAAb;AACAE,SAAOE,aAAP,GAAuBT,IAAvB;;AAEA,SAAOO,MAAP;AACD;;AAEM,SAASzB,cAAT,CACLG,KADK,EAELC,kBAFK,EAGLc,IAHK,EAIL,GAAGU,gBAJE,EAKgC;AACrC,MAAI,CAACzB,MAAMiB,yBAAX,EAAsC;AACpC,UAAMjB,MAAMM,0BAAN,CAAiCN,MAAMO,UAAN,CAAiBC,SAAlD,EAA6D,sBAA7D,CAAN;AACD;;AAED,MAAI,EAAEL,IAAF,EAAQC,QAAR,EAAkBU,kBAAlB,KAAyCnB,wBAAwBK,KAAxB,EAA+BC,kBAA/B,CAA7C;;AAEA,MAAIqB,MAAJ;AACA,MAAIJ,SAAJ;AAAA,MACEQ,MAAM,IADR;AAEA,OAAK,IAAIC,gBAAT,IAA6B3B,MAAM4B,YAAN,CAAmBC,KAAnB,GAA2BC,OAA3B,EAA7B,EAAmE;AACjE,QAAIC,SAASJ,iBAAiBI,MAA9B;AACAL,UAAMC,iBAAiBD,GAAvB;AACAR,gBAAY,6BACVlB,KADU,EAEV+B,SAASA,OAAOC,QAAhB,GAA2B9B,SAFjB,EAGV6B,SAASA,OAAOE,kBAAhB,GAAqC/B,SAH3B,EAIVwB,GAJU,CAAZ;AAMA,QAAIR,cAAchB,SAAlB,EAA6B;AAC9B;AACD,MAAI,CAACa,IAAL,EAAW;AACT,QAAII,SAAS,uBAAgBnB,KAAhB,EAAuBkB,aAAa,oBAApC,CAAb;AACA,QAAIE,OAAO,gBAAgBpB,MAAMqB,WAAN,EAA3B,CAFS,CAEuC;AAChDC,aAAS,qBAAcC,kBAAd,CAAiCvB,KAAjC,EAAwCD,aAAxC,EAAuDI,IAAvD,EAA6D,CAACgB,MAAD,CAA7D,EAAuEC,IAAvE,CAAT;AACD,GAJD,MAIO;AACL,QAAIA,OAAO,gBAAgBL,IAA3B;AACA,QAAI,CAACf,MAAMkC,kBAAN,CAAyBnB,IAAzB,CAAL,EAAqC;AACnC,UAAIoB,QAAQ,+BAAuB,6CAAvB,EAAsET,GAAtE,EAA2E,QAA3E,EAAqF,YAArF,CAAZ;AACA1B,YAAMoC,WAAN,CAAkBD,KAAlB;AACA,YAAM,wBAAN;AACD,KAJD,MAIO;AACLnC,YAAMqC,cAAN,CAAqBtB,IAArB;AACD;AACDO,aAAS,qBAAcC,kBAAd,CAAiCvB,KAAjC,EAAwC,uBAAwBe,IAAxB,CAAxC,EAAuEZ,IAAvE,EAA6E,EAA7E,EAAiFiB,IAAjF,CAAT;AACAE,WAAOE,aAAP,GAAuBT,IAAvB;AACD;;AAED,MAAIX,QAAJ,EAAckB,OAAOgB,MAAP,GAAgB,yBAAiB,IAAIC,GAAJ,CAAQ,CAACnC,QAAD,CAAR,CAAjB,CAAhB;AACd,MAAIA,YAAY,EAAEA,wCAAF,CAAhB,EAAsD;AACpD;AACAA,aAASoC,WAAT;AACA,QAAIzB,IAAJ,EAAUf,MAAMyC,uBAAN,CAA8BnB,MAA9B,EAAsCP,IAAtC;AACX;AACD,MAAID,kBAAJ,EAAwB;AACtB,6BAAUQ,+CAAV;AACAA,WAAOR,kBAAP,GAA4BA,kBAA5B;AACD;;AAED,MAAIW,iBAAiBiB,MAAjB,GAA0B,CAA9B,EACEpB,SAAS,qBAAcqB,2BAAd,CAA0C3C,KAA1C,EAAiDsB,MAAjD,EAAyD,GAAGG,gBAA5D,CAAT;AACF,SAAOH,MAAP;AACD","file":"utils.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport {\n  Value,\n  AbstractValue,\n  ConcreteValue,\n  FunctionValue,\n  StringValue,\n  ObjectValue,\n  UndefinedValue,\n} from \"../../values/index.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\nimport { ValuesDomain } from \"../../domains/index.js\";\nimport { describeLocation } from \"../ecma262/Error.js\";\nimport { To } from \"../../singletons.js\";\nimport AbstractObjectValue from \"../../values/AbstractObjectValue\";\nimport { CompilerDiagnostic, FatalError } from \"../../errors.js\";\nimport { Utils } from \"../../singletons\";\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport invariant from \"../../invariant.js\";\n\nconst throwTemplateSrc = \"(function(){throw new global.Error('abstract value defined at ' + A);})()\";\nconst throwTemplate = buildExpressionTemplate(throwTemplateSrc);\n\nexport function parseTypeNameOrTemplate(\n  realm: Realm,\n  typeNameOrTemplate: void | Value | string\n): { type: typeof Value, template: void | ObjectValue, functionResultType?: typeof Value } {\n  if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof UndefinedValue) {\n    return { type: Value, template: undefined };\n  } else if (typeof typeNameOrTemplate === \"string\") {\n    let type = Utils.getTypeFromName(typeNameOrTemplate);\n    if (type === undefined) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n    }\n    return { type, template: undefined };\n  } else if (typeNameOrTemplate instanceof StringValue) {\n    let typeNameString = To.ToStringPartial(realm, typeNameOrTemplate);\n    let hasFunctionResultType = typeNameString.startsWith(\":\");\n    if (hasFunctionResultType) typeNameString = typeNameString.substring(1);\n    let type = Utils.getTypeFromName(typeNameString);\n    if (type === undefined) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n    }\n    return hasFunctionResultType\n      ? { type: FunctionValue, template: undefined, functionResultType: type }\n      : { type, template: undefined };\n  } else if (typeNameOrTemplate instanceof FunctionValue) {\n    return { type: FunctionValue, template: typeNameOrTemplate };\n  } else if (typeNameOrTemplate instanceof ObjectValue) {\n    return { type: ObjectValue, template: typeNameOrTemplate };\n  } else {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"typeNameOrTemplate has unsupported type\");\n  }\n}\n\nexport function createAbstractArgument(realm: Realm, name: string, location: ?BabelNodeSourceLocation) {\n  if (!realm.useAbstractInterpretation) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n  }\n\n  let locString;\n  if (location) locString = describeLocation(realm, undefined, undefined, location);\n  let locVal = new StringValue(realm, locString || \"(unknown location)\");\n  let kind = \"__abstract_\" + realm.objectCount++; // need not be an object, but must be unique\n  let result = AbstractValue.createFromTemplate(realm, buildExpressionTemplate(name), Value, [locVal], kind);\n  result.intrinsicName = name;\n\n  return result;\n}\n\nexport function createAbstract(\n  realm: Realm,\n  typeNameOrTemplate?: Value | string,\n  name?: string,\n  ...additionalValues: Array<ConcreteValue>\n): AbstractValue | AbstractObjectValue {\n  if (!realm.useAbstractInterpretation) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n  }\n\n  let { type, template, functionResultType } = parseTypeNameOrTemplate(realm, typeNameOrTemplate);\n\n  let result;\n  let locString,\n    loc = null;\n  for (let executionContext of realm.contextStack.slice().reverse()) {\n    let caller = executionContext.caller;\n    loc = executionContext.loc;\n    locString = describeLocation(\n      realm,\n      caller ? caller.function : undefined,\n      caller ? caller.lexicalEnvironment : undefined,\n      loc\n    );\n    if (locString !== undefined) break;\n  }\n  if (!name) {\n    let locVal = new StringValue(realm, locString || \"(unknown location)\");\n    let kind = \"__abstract_\" + realm.objectCount++; // need not be an object, but must be unique\n    result = AbstractValue.createFromTemplate(realm, throwTemplate, type, [locVal], kind);\n  } else {\n    let kind = \"__abstract_\" + name;\n    if (!realm.isNameStringUnique(name)) {\n      let error = new CompilerDiagnostic(\"An abstract value with the same name exists\", loc, \"PP0019\", \"FatalError\");\n      realm.handleError(error);\n      throw new FatalError();\n    } else {\n      realm.saveNameString(name);\n    }\n    result = AbstractValue.createFromTemplate(realm, buildExpressionTemplate(name), type, [], kind);\n    result.intrinsicName = name;\n  }\n\n  if (template) result.values = new ValuesDomain(new Set([template]));\n  if (template && !(template instanceof FunctionValue)) {\n    // why exclude functions?\n    template.makePartial();\n    if (name) realm.rebuildNestedProperties(result, name);\n  }\n  if (functionResultType) {\n    invariant(result instanceof AbstractObjectValue);\n    result.functionResultType = functionResultType;\n  }\n\n  if (additionalValues.length > 0)\n    result = AbstractValue.createAbstractConcreteUnion(realm, result, ...additionalValues);\n  return result;\n}\n"]}