{"version":3,"sources":["../../src/values/ArrayValue.js"],"names":["ArrayValue","constructor","realm","intrinsicName","intrinsics","ArrayPrototype","getKind","isSimpleObject","$TypedArrayName","undefined","$DefineOwnProperty","P","Desc","A","$Realm","value","ArraySetLength","oldLenDesc","OrdinaryGetOwnProperty","ThrowIfMightHaveBeenDeleted","oldLen","throwIfNotConcrete","index","ToUint32","writable","succeeded","OrdinaryDefineOwnProperty"],"mappings":";;;;;;AAaA;;AACA;;AACA;;AACA;;;;;;AAhBA;;;;;;;;;AAkBe,MAAMA,UAAN,4BAAqC;AAClDC,cAAYC,KAAZ,EAA0BC,aAA1B,EAAkD;AAChD,UAAMD,KAAN,EAAaA,MAAME,UAAN,CAAiBC,cAA9B,EAA8CF,aAA9C;AACD;;AAEDG,YAAsB;AACpB,WAAO,OAAP;AACD;;AAEDC,mBAA0B;AACxB,WAAO,KAAKC,eAAL,KAAyBC,SAAhC;AACD;;AAED;AACAC,qBAAmBC,CAAnB,EAAwCC,IAAxC,EAAmE;AACjE,QAAIC,IAAI,IAAR;;AAEA;AACA,6BAAU,uBAAc,KAAKC,MAAnB,EAA2BH,CAA3B,CAAV,EAAyC,yBAAzC;;AAEA;AACA,QAAIA,MAAM,QAAN,IAAmBA,mCAA4BA,EAAEI,KAAF,KAAY,QAA/D,EAA0E;AACxE;AACA,aAAO,uBAAWC,cAAX,CAA0B,KAAKF,MAA/B,EAAuCD,CAAvC,EAA0CD,IAA1C,CAAP;AACD,KAHD,MAGO,IAAI,sBAAa,KAAKE,MAAlB,EAA0BH,CAA1B,CAAJ,EAAkC;AACvC;;AAEA;AACA,UAAIM,aAAa,uBAAWC,sBAAX,CAAkC,KAAKJ,MAAvC,EAA+CD,CAA/C,EAAkD,QAAlD,CAAjB;;AAEA;AACA;AACA,+BACEI,eAAeR,SAAf,IAA4B,CAAC,8BAAqB,KAAKK,MAA1B,EAAkCG,UAAlC,CAD/B,EAEE,+CAFF;AAIA,6BAAWE,2BAAX,CAAuCF,WAAWF,KAAlD;;AAEA;AACA,UAAIK,SAASH,WAAWF,KAAxB;AACA,+BAAUK,8BAAV;AACAA,eAASA,OAAOC,kBAAP,EAAT;AACA,+BAAUD,oCAAV,EAAyC,uBAAzC;AACAA,eAASA,OAAOL,KAAhB;;AAEA;AACA,UAAIO,QAAQ,eAAGC,QAAH,CAAY,KAAKT,MAAjB,EAAyB,OAAOH,CAAP,KAAa,QAAb,GAAwB,uBAAgB,KAAKG,MAArB,EAA6BH,CAA7B,CAAxB,GAA0DA,CAAnF,CAAZ;;AAEA;AACA,UAAIW,SAASF,MAAT,IAAmBH,WAAWO,QAAX,KAAwB,KAA/C,EAAsD,OAAO,KAAP;;AAEtD;AACA,UAAIC,YAAY,uBAAWC,yBAAX,CAAqC,KAAKZ,MAA1C,EAAkDD,CAAlD,EAAqDF,CAArD,EAAwDC,IAAxD,CAAhB;;AAEA;AACA,UAAIa,cAAc,KAAlB,EAAyB,OAAO,KAAP;;AAEzB;AACA,UAAIH,SAASF,MAAb,EAAqB;AACnB;AACAH,mBAAWF,KAAX,GAAmB,uBAAgB,KAAKD,MAArB,EAA6BQ,QAAQ,CAArC,CAAnB;;AAEA;AACAG,oBAAY,uBAAWC,yBAAX,CAAqC,KAAKZ,MAA1C,EAAkDD,CAAlD,EAAqD,QAArD,EAA+DI,UAA/D,CAAZ;;AAEA;AACA,iCAAUQ,SAAV,EAAqB,uCAArB;AACD;;AAED;AACA,aAAO,IAAP;AACD;;AAED;AACA,WAAO,uBAAWC,yBAAX,CAAqC,KAAKZ,MAA1C,EAAkDD,CAAlD,EAAqDF,CAArD,EAAwDC,IAAxD,CAAP;AACD;AA3EiD;kBAA/BZ,U","file":"ArrayValue.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue, Descriptor, ObjectKind } from \"../types.js\";\nimport { ObjectValue, StringValue, NumberValue, Value } from \"./index.js\";\nimport { IsAccessorDescriptor, IsPropertyKey, IsArrayIndex } from \"../methods/is.js\";\nimport { Properties, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\n\nexport default class ArrayValue extends ObjectValue {\n  constructor(realm: Realm, intrinsicName?: string) {\n    super(realm, realm.intrinsics.ArrayPrototype, intrinsicName);\n  }\n\n  getKind(): ObjectKind {\n    return \"Array\";\n  }\n\n  isSimpleObject(): boolean {\n    return this.$TypedArrayName === undefined;\n  }\n\n  // ECMA262 9.4.2.1\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    let A = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"expected a property key\");\n\n    // 2. If P is \"length\", then\n    if (P === \"length\" || (P instanceof StringValue && P.value === \"length\")) {\n      // a. Return ? ArraySetLength(A, Desc).\n      return Properties.ArraySetLength(this.$Realm, A, Desc);\n    } else if (IsArrayIndex(this.$Realm, P)) {\n      // 3. Else if P is an array index, then\n\n      // a. Let oldLenDesc be OrdinaryGetOwnProperty(A, \"length\").\n      let oldLenDesc = Properties.OrdinaryGetOwnProperty(this.$Realm, A, \"length\");\n\n      // b. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are\n      //    created with a length data property that cannot be deleted or reconfigured.\n      invariant(\n        oldLenDesc !== undefined && !IsAccessorDescriptor(this.$Realm, oldLenDesc),\n        \"cannot be undefined or an accessor descriptor\"\n      );\n      Properties.ThrowIfMightHaveBeenDeleted(oldLenDesc.value);\n\n      // c. Let oldLen be oldLenDesc.[[Value]].\n      let oldLen = oldLenDesc.value;\n      invariant(oldLen instanceof Value);\n      oldLen = oldLen.throwIfNotConcrete();\n      invariant(oldLen instanceof NumberValue, \"expected number value\");\n      oldLen = oldLen.value;\n\n      // d. Let index be ! ToUint32(P).\n      let index = To.ToUint32(this.$Realm, typeof P === \"string\" ? new StringValue(this.$Realm, P) : P);\n\n      // e. If index ≥ oldLen and oldLenDesc.[[Writable]] is false, return false.\n      if (index >= oldLen && oldLenDesc.writable === false) return false;\n\n      // f. Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).\n      let succeeded = Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);\n\n      // g. If succeeded is false, return false.\n      if (succeeded === false) return false;\n\n      // h. If index ≥ oldLen, then\n      if (index >= oldLen) {\n        // i. Set oldLenDesc.[[Value]] to index + 1.\n        oldLenDesc.value = new NumberValue(this.$Realm, index + 1);\n\n        // ii. Let succeeded be OrdinaryDefineOwnProperty(A, \"length\", oldLenDesc).\n        succeeded = Properties.OrdinaryDefineOwnProperty(this.$Realm, A, \"length\", oldLenDesc);\n\n        // iii. Assert: succeeded is true.\n        invariant(succeeded, \"expected length definition to succeed\");\n      }\n\n      // i. Return true.\n      return true;\n    }\n\n    // 1. Return OrdinaryDefineOwnProperty(A, P, Desc).\n    return Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);\n  }\n}\n"]}