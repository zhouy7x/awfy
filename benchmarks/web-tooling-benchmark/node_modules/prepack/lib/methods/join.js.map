{"version":3,"sources":["../../src/methods/join.js"],"names":["joinGenerators","realm","joinCondition","generator1","generator2","result","empty","joinArrays","v1","v2","getAbstractValue","e","joinArraysOfValues","joinArrayOfsMapEntries","a1","a2","intrinsics","n","Math","max","length","i","$Key","key1","$Value","val1","key2","val2","undefined","key3","val3","JoinImplementation","stopEffectCaptureJoinApplyAndReturnCompletion","c1","c2","getCapturedEffects","stopEffectCaptureAndUndoEffects","joined_effects","joinPossiblyNormalCompletionWithAbruptCompletion","applyEffects","unbundleNormalCompletion","completionOrValue","completion","value","composeNormalCompletions","leftCompletion","rightCompletion","resultValue","updatePossiblyNormalCompletionWithValue","composePossiblyNormalCompletions","pnc","c","savedEffects","composedPath","pathConditions","concat","savedPathConditions","consequent","alternate","g","b","p","o","alternateEffects","newAlternateEffects","consequentEffects","new_alternate","newConsequentEffects","new_consequent","updatePossiblyNormalCompletionWithSubsequentEffects","subsequentEffects","v","composeEffects","ac","joinEffects","alternate_effects","composedEffects","consequent_effects","joinPossiblyNormalCompletionWithValue","joinValuesAsConditional","joinValueWithPossiblyNormalCompletion","joinPossiblyNormalCompletions","a","rJoinCondition","cp","ap","createFromLogicalOp","notA","createFromUnaryOp","notC","ce1","ce2","ae1","ae2","rce","rae","rc","ra","rv","joinEffectsAndPromoteNestedReturnCompletions","nested_effects","e1","e2","currentLocation","r1","r2","r1jr2c","or","r1jr2a","notR2jc","r2jr1c","r2jr1a","notR1jc","e3","r3","joinedEffects","possiblyNormalCompletion","unbundleReturnCompletion","composeWithSavedCompletion","empty_effects","negation","removeNormalEffects","result1","gen1","bindings1","properties1","createdObj1","result2","gen2","bindings2","properties2","createdObj2","joinResults","bindings","joinBindings","properties","joinPropertyBindings","createdObjects","Set","forEach","add","generator","reportIntrospectionError","target","expressionLocation","val","joinValues","location","composeGenerators","joinMaps","m1","m2","join","m3","Map","key","map1","get","set","map2","has","b1","b2","l1","hasLeaked","l2","Array","isArray","throwIfNotConcrete","condition","createFromConditionalOp","d1","d2","object","descriptor","joinDescriptors","clone_with_abstract_value","d","d3","dc","dcValue","elem0","map","descriptor2","descriptor1"],"mappings":"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","file":"join.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Binding } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport type {\n  Bindings,\n  BindingEntry,\n  Effects,\n  EvaluationResult,\n  PropertyBindings,\n  CreatedObjects,\n  Realm,\n} from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\n\nimport {\n  AbruptCompletion,\n  BreakCompletion,\n  Completion,\n  ContinueCompletion,\n  PossiblyNormalCompletion,\n  JoinedAbruptCompletions,\n  NormalCompletion,\n  ReturnCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { cloneDescriptor, equalDescriptors, IsDataDescriptor, StrictEqualityComparison } from \"../methods/index.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport { AbstractValue, ObjectValue, Value } from \"../values/index.js\";\n\nimport invariant from \"../invariant.js\";\n\nfunction joinGenerators(\n  realm: Realm,\n  joinCondition: AbstractValue,\n  generator1: Generator,\n  generator2: Generator\n): Generator {\n  let result = new Generator(realm);\n  if (!generator1.empty() || !generator2.empty()) {\n    result.joinGenerators(joinCondition, generator1, generator2);\n  }\n  return result;\n}\n\nfunction joinArrays(\n  realm: Realm,\n  v1: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n  v2: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n  let e = (v1 && v1[0]) || (v2 && v2[0]);\n  if (e instanceof Value) return joinArraysOfValues(realm, (v1: any), (v2: any), getAbstractValue);\n  else return joinArrayOfsMapEntries(realm, (v1: any), (v2: any), getAbstractValue);\n}\n\nfunction joinArrayOfsMapEntries(\n  realm: Realm,\n  a1: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n  a2: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<{ $Key: void | Value, $Value: void | Value }> {\n  let empty = realm.intrinsics.empty;\n  let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n  let result = [];\n  for (let i = 0; i < n; i++) {\n    let { $Key: key1, $Value: val1 } = (a1 && a1[i]) || { $Key: empty, $Value: empty };\n    let { $Key: key2, $Value: val2 } = (a2 && a2[i]) || { $Key: empty, $Value: empty };\n    if (key1 === undefined && key2 === undefined) {\n      result[i] = { $Key: undefined, $Value: undefined };\n    } else {\n      let key3 = getAbstractValue(key1, key2);\n      let val3 = getAbstractValue(val1, val2);\n      result[i] = { $Key: key3, $Value: val3 };\n    }\n  }\n  return result;\n}\n\nfunction joinArraysOfValues(\n  realm: Realm,\n  a1: void | Array<Value>,\n  a2: void | Array<Value>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<Value> {\n  let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n  let result = [];\n  for (let i = 0; i < n; i++) {\n    result[i] = getAbstractValue((a1 && a1[i]) || undefined, (a2 && a2[i]) || undefined);\n  }\n  return result;\n}\n\nexport class JoinImplementation {\n  stopEffectCaptureJoinApplyAndReturnCompletion(\n    c1: PossiblyNormalCompletion,\n    c2: AbruptCompletion,\n    realm: Realm\n  ): AbruptCompletion {\n    let e = realm.getCapturedEffects(c1);\n    invariant(e !== undefined);\n    realm.stopEffectCaptureAndUndoEffects(c1);\n    let joined_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, c1, c2, e);\n    realm.applyEffects(joined_effects);\n    let result = joined_effects[0];\n    invariant(result instanceof AbruptCompletion);\n    return result;\n  }\n\n  unbundleNormalCompletion(\n    completionOrValue: Completion | Value | Reference\n  ): [void | NormalCompletion, Value | Reference] {\n    let completion, value;\n    if (completionOrValue instanceof PossiblyNormalCompletion) {\n      completion = completionOrValue;\n      value = completionOrValue.value;\n    } else {\n      invariant(completionOrValue instanceof Value || completionOrValue instanceof Reference);\n      value = completionOrValue;\n    }\n    return [completion, value];\n  }\n\n  composeNormalCompletions(\n    leftCompletion: void | NormalCompletion,\n    rightCompletion: void | NormalCompletion,\n    resultValue: Value,\n    realm: Realm\n  ): PossiblyNormalCompletion | Value {\n    if (leftCompletion instanceof PossiblyNormalCompletion) {\n      if (rightCompletion instanceof PossiblyNormalCompletion) {\n        this.updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);\n        return this.composePossiblyNormalCompletions(realm, leftCompletion, rightCompletion);\n      }\n      this.updatePossiblyNormalCompletionWithValue(realm, leftCompletion, resultValue);\n      return leftCompletion;\n    } else if (rightCompletion instanceof PossiblyNormalCompletion) {\n      this.updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);\n      return rightCompletion;\n    } else {\n      invariant(leftCompletion === undefined && rightCompletion === undefined);\n      return resultValue;\n    }\n  }\n\n  composePossiblyNormalCompletions(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    c: PossiblyNormalCompletion\n  ): PossiblyNormalCompletion {\n    invariant(c.savedEffects === undefined); // the caller should ensure this\n    //merge the two pathConditions\n    let composedPath = [];\n    composedPath = pnc.pathConditions.concat(c.pathConditions);\n    let savedPathConditions = pnc.savedPathConditions;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        let [, g, b, p, o] = pnc.alternateEffects;\n        let newAlternateEffects = [c, g, b, p, o];\n        return new PossiblyNormalCompletion(\n          c.value,\n          pnc.joinCondition,\n          pnc.consequent,\n          pnc.consequentEffects,\n          c,\n          newAlternateEffects,\n          composedPath,\n          savedPathConditions,\n          pnc.savedEffects\n        );\n      }\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      let new_alternate = this.composePossiblyNormalCompletions(realm, pnc.alternate, c);\n      let [, g, b, p, o] = pnc.alternateEffects;\n      let newAlternateEffects = [new_alternate, g, b, p, o];\n      return new PossiblyNormalCompletion(\n        new_alternate.value,\n        pnc.joinCondition,\n        pnc.consequent,\n        pnc.consequentEffects,\n        new_alternate,\n        newAlternateEffects,\n        composedPath,\n        savedPathConditions,\n        pnc.savedEffects\n      );\n    } else {\n      invariant(pnc.alternate instanceof AbruptCompletion);\n      if (pnc.consequent instanceof Value) {\n        let [, g, b, p, o] = pnc.consequentEffects;\n        let newConsequentEffects = [c, g, b, p, o];\n        return new PossiblyNormalCompletion(\n          c.value,\n          pnc.joinCondition,\n          c,\n          newConsequentEffects,\n          pnc.alternate,\n          pnc.alternateEffects,\n          composedPath,\n          savedPathConditions,\n          pnc.savedEffects\n        );\n      }\n      invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n      let new_consequent = this.composePossiblyNormalCompletions(realm, pnc.consequent, c);\n      let [, g, b, p, o] = pnc.consequentEffects;\n      let newConsequentEffects = [new_consequent, g, b, p, o];\n      return new PossiblyNormalCompletion(\n        new_consequent.value,\n        pnc.joinCondition,\n        new_consequent,\n        newConsequentEffects,\n        pnc.alternate,\n        pnc.alternateEffects,\n        composedPath,\n        savedPathConditions,\n        pnc.savedEffects\n      );\n    }\n  }\n\n  updatePossiblyNormalCompletionWithSubsequentEffects(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    subsequentEffects: Effects\n  ) {\n    let v = subsequentEffects[0];\n    invariant(v instanceof Value);\n    pnc.value = v;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = v;\n        pnc.alternateEffects[0] = v;\n        pnc.alternateEffects = realm.composeEffects(pnc.alternateEffects, subsequentEffects);\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithSubsequentEffects(realm, pnc.alternate, subsequentEffects);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = v;\n        pnc.consequentEffects[0] = v;\n        pnc.consequentEffects = realm.composeEffects(pnc.consequentEffects, subsequentEffects);\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithSubsequentEffects(realm, pnc.consequent, subsequentEffects);\n      }\n    }\n  }\n\n  updatePossiblyNormalCompletionWithValue(realm: Realm, pnc: PossiblyNormalCompletion, v: Value) {\n    pnc.value = v;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = v;\n        pnc.alternateEffects[0] = v;\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithValue(realm, pnc.alternate, v);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = v;\n        pnc.consequentEffects[0] = v;\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithValue(realm, pnc.consequent, v);\n      }\n    }\n  }\n\n  // Returns the joined effects of all of the paths in pnc.\n  // The normal path in pnc is modified to become terminated by ac,\n  // so the overall completion will always be an instance of JoinedAbruptCompletions\n  joinPossiblyNormalCompletionWithAbruptCompletion(\n    realm: Realm,\n    // a forked path with a non abrupt (normal) component\n    pnc: PossiblyNormalCompletion,\n    // an abrupt completion that completes the normal path\n    ac: AbruptCompletion,\n    // effects collected after pnc was constructed\n    e: Effects\n  ): Effects {\n    // set up e with ac as the completion. It's OK to do this repeatedly since ac is not changed by recursive calls.\n    e[0] = ac;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        return this.joinEffects(\n          realm,\n          pnc.joinCondition,\n          pnc.consequentEffects,\n          realm.composeEffects(pnc.alternateEffects, e)\n        );\n      }\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      let alternate_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.alternate, ac, e);\n      let composedEffects = realm.composeEffects(pnc.alternateEffects, alternate_effects);\n      invariant(pnc.consequent instanceof AbruptCompletion);\n      return this.joinEffects(realm, pnc.joinCondition, pnc.consequentEffects, composedEffects);\n    } else {\n      invariant(pnc.alternate instanceof AbruptCompletion);\n      if (pnc.consequent instanceof Value) {\n        return this.joinEffects(\n          realm,\n          pnc.joinCondition,\n          realm.composeEffects(pnc.consequentEffects, e),\n          pnc.alternateEffects\n        );\n      }\n      invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n      let consequent_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.consequent, ac, e);\n      let composedEffects = realm.composeEffects(pnc.consequentEffects, consequent_effects);\n      invariant(pnc.alternate instanceof AbruptCompletion);\n      return this.joinEffects(realm, pnc.joinCondition, composedEffects, pnc.alternateEffects);\n    }\n  }\n\n  joinPossiblyNormalCompletionWithValue(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    v: Value\n  ) {\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = this.joinValuesAsConditional(realm, joinCondition, pnc.alternate, v);\n        pnc.alternateEffects[0] = pnc.alternate;\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, pnc.alternate, v);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = this.joinValuesAsConditional(realm, joinCondition, pnc.consequent, v);\n        pnc.consequentEffects[0] = pnc.consequent;\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, pnc.consequent, v);\n      }\n    }\n  }\n\n  joinValueWithPossiblyNormalCompletion(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    v: Value\n  ) {\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = this.joinValuesAsConditional(realm, joinCondition, v, pnc.alternate);\n        pnc.alternateEffects[0] = pnc.alternate;\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, pnc.alternate, v);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = this.joinValuesAsConditional(realm, joinCondition, v, pnc.consequent);\n        pnc.consequentEffects[0] = pnc.consequent;\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, pnc.consequent, v);\n      }\n    }\n  }\n\n  joinPossiblyNormalCompletions(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    c: PossiblyNormalCompletion,\n    a: PossiblyNormalCompletion\n  ): PossiblyNormalCompletion {\n    let rJoinCondition: Value;\n    let cp: [Effects, Effects];\n    let ap: [Effects, Effects];\n    if (c.consequent instanceof AbruptCompletion) {\n      if (a.consequent instanceof AbruptCompletion) {\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", c.joinCondition, a.joinCondition);\n        cp = [c.consequentEffects, a.consequentEffects];\n        ap = [c.alternateEffects, a.alternateEffects];\n      } else {\n        let notA = AbstractValue.createFromUnaryOp(realm, \"!\", a.joinCondition);\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", c.joinCondition, notA);\n        cp = [c.consequentEffects, a.alternateEffects];\n        ap = [c.alternateEffects, a.consequentEffects];\n      }\n    } else {\n      let notC = AbstractValue.createFromUnaryOp(realm, \"!\", c.joinCondition);\n      if (a.consequent instanceof AbruptCompletion) {\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", notC, a.joinCondition);\n        cp = [c.alternateEffects, a.consequentEffects];\n        ap = [c.consequentEffects, a.alternateEffects];\n      } else {\n        let notA = AbstractValue.createFromUnaryOp(realm, \"!\", a.joinCondition);\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", notC, notA);\n        cp = [c.alternateEffects, a.alternateEffects];\n        ap = [c.consequentEffects, a.consequentEffects];\n      }\n    }\n    invariant(rJoinCondition instanceof AbstractValue); // the transformations will not result in tautologies\n    let [ce1, ce2] = cp;\n    let [ae1, ae2] = ap;\n    let rce = this.joinEffects(realm, joinCondition, ce1, ce2);\n    let rae = this.joinEffects(realm, joinCondition, ae1, ae2);\n    let rc = rce[0];\n    invariant(rc instanceof Value || rc instanceof Completion);\n    let ra = rae[0];\n    invariant(ra instanceof Value || ra instanceof Completion);\n    let rv = ra instanceof PossiblyNormalCompletion ? ra.value : ra;\n    invariant(rv instanceof Value);\n    return new PossiblyNormalCompletion(rv, rJoinCondition, rc, rce, ra, rae, [], []);\n  }\n\n  joinEffectsAndPromoteNestedReturnCompletions(\n    realm: Realm,\n    c: Completion | Value,\n    e: Effects,\n    nested_effects?: Effects\n  ): Effects {\n    if (c instanceof Value) {\n      // If not undefined, the nested effects were captured when evaluating a conditional code block that ended normally.\n      // e represent effects that were captured since reaching the join point where the normal and abrupt\n      // completions came together into the completion supplied to the outermost call to this recursive function.\n      if (nested_effects !== undefined) e = realm.composeEffects(nested_effects, e);\n      return e;\n    }\n    if (c instanceof AbruptCompletion && !(c instanceof JoinedAbruptCompletions)) {\n      // The nested effects were captured when evaluating a conditional code block that ended abruptly.\n      // An abrupt completion does not care about the effects that were collected since the join point.\n      invariant(nested_effects !== undefined);\n      return nested_effects;\n    }\n    if (c instanceof PossiblyNormalCompletion) {\n      let e1 = this.joinEffectsAndPromoteNestedReturnCompletions(realm, c.consequent, e, c.consequentEffects);\n      let e2 = this.joinEffectsAndPromoteNestedReturnCompletions(realm, c.alternate, e, c.alternateEffects);\n      if (e1[0] instanceof AbruptCompletion) {\n        if (e2[0] instanceof Value) e2[0] = new ReturnCompletion(realm.intrinsics.undefined, realm.currentLocation);\n        return this.joinEffects(realm, c.joinCondition, e1, e2);\n      } else if (e2[0] instanceof AbruptCompletion) {\n        if (e1[0] instanceof Value) e1[0] = new ReturnCompletion(realm.intrinsics.undefined, realm.currentLocation);\n        return this.joinEffects(realm, c.joinCondition, e1, e2);\n      }\n    }\n    invariant(c instanceof JoinedAbruptCompletions);\n    // e will be ignored in the calls below since the branches are all abrupt.\n    let e1 = this.joinEffectsAndPromoteNestedReturnCompletions(realm, c.consequent, e, c.consequentEffects);\n    let e2 = this.joinEffectsAndPromoteNestedReturnCompletions(realm, c.alternate, e, c.alternateEffects);\n    let [r1, r2] = [e1[0], e2[0]];\n    if (r1 instanceof ReturnCompletion) {\n      // this can happen because joinEffectsAndPromoteNestedReturnCompletions above both had nested ReturnCompletions\n      if (r2 instanceof ReturnCompletion) {\n        return this.joinEffects(realm, c.joinCondition, e1, e2);\n      }\n      if (r2 instanceof JoinedAbruptCompletions) {\n        if (r2.consequent instanceof ReturnCompletion) {\n          let r1jr2c = this.joinEffects(realm, c.joinCondition, e1, r2.consequentEffects);\n          invariant(r1jr2c[0] instanceof ReturnCompletion);\n          let or = AbstractValue.createFromLogicalOp(realm, \"||\", c.joinCondition, r2.joinCondition);\n          invariant(or instanceof AbstractValue);\n          return this.joinEffects(realm, or, r1jr2c, r2.alternateEffects);\n        }\n        if (r2.alternate instanceof ReturnCompletion) {\n          let r1jr2a = this.joinEffects(realm, c.joinCondition, e1, r2.alternateEffects);\n          invariant(r1jr2a[0] instanceof ReturnCompletion);\n          let notR2jc = AbstractValue.createFromUnaryOp(realm, \"!\", r2.joinCondition);\n          let or = AbstractValue.createFromLogicalOp(realm, \"||\", c.joinCondition, notR2jc);\n          invariant(or instanceof AbstractValue);\n          return this.joinEffects(realm, or, r1jr2a, r2.consequentEffects);\n        }\n      }\n    } else if (r2 instanceof ReturnCompletion) {\n      invariant(!(r1 instanceof ReturnCompletion)); // Otherwise their values should have been joined\n      if (r1 instanceof JoinedAbruptCompletions) {\n        if (r1.consequent instanceof ReturnCompletion) {\n          let r2jr1c = this.joinEffects(realm, c.joinCondition, r1.consequentEffects, e2);\n          invariant(r2jr1c[0] instanceof ReturnCompletion);\n          let or = AbstractValue.createFromLogicalOp(realm, \"||\", c.joinCondition, r1.joinCondition);\n          invariant(or instanceof AbstractValue);\n          return this.joinEffects(realm, or, r2jr1c, r1.alternateEffects);\n        }\n        if (r1.alternate instanceof ReturnCompletion) {\n          let r2jr1a = this.joinEffects(realm, c.joinCondition, r1.alternateEffects, e2);\n          let notR1jc = AbstractValue.createFromUnaryOp(realm, \"!\", r1.joinCondition);\n          invariant(r2jr1a[0] instanceof ReturnCompletion);\n          let or = AbstractValue.createFromLogicalOp(realm, \"||\", c.joinCondition, notR1jc);\n          invariant(or instanceof AbstractValue);\n          return this.joinEffects(realm, or, r2jr1a, r1.consequentEffects);\n        }\n      }\n    }\n    let e3 = this.joinEffects(realm, c.joinCondition, e1, e2);\n    let [r3] = e3;\n    if (r3 instanceof JoinedAbruptCompletions) {\n      let [joinedEffects, possiblyNormalCompletion] = this.unbundleReturnCompletion(realm, r3);\n      realm.composeWithSavedCompletion(possiblyNormalCompletion);\n      return joinedEffects;\n    }\n    return e3;\n  }\n\n  unbundleReturnCompletion(realm: Realm, c: JoinedAbruptCompletions): [Effects, PossiblyNormalCompletion] {\n    let empty_effects = construct_empty_effects(realm);\n    let v = realm.intrinsics.empty;\n    if (c.consequent instanceof ReturnCompletion) {\n      let negation = AbstractValue.createFromUnaryOp(realm, \"!\", c.joinCondition);\n      // Simply negating the (known to be abstract) join condition should\n      // not become a concrete value\n      invariant(negation instanceof AbstractValue);\n      let pathConditions = [negation];\n      let pnc = new PossiblyNormalCompletion(\n        v,\n        c.joinCondition,\n        v,\n        empty_effects,\n        c.alternate,\n        c.alternateEffects,\n        pathConditions,\n        []\n      );\n      return [c.consequentEffects, pnc];\n    } else if (c.alternate instanceof ReturnCompletion) {\n      let pnc = new PossiblyNormalCompletion(\n        v,\n        c.joinCondition,\n        c.consequent,\n        c.consequentEffects,\n        v,\n        empty_effects,\n        [c.joinCondition],\n        []\n      );\n      return [c.alternateEffects, pnc];\n    } else {\n      invariant(false, \"unbundleReturnCompletion needs an argument that contains a non nested return completion\");\n    }\n  }\n\n  removeNormalEffects(realm: Realm, c: PossiblyNormalCompletion): Effects {\n    if (c.consequent instanceof AbruptCompletion) {\n      if (c.alternate instanceof Value) {\n        let result = c.alternateEffects;\n        c.alternateEffects = construct_empty_effects(realm);\n        return result;\n      } else {\n        invariant(c.alternate instanceof PossiblyNormalCompletion);\n        let result = realm.composeEffects(c.alternateEffects, this.removeNormalEffects(realm, c.alternate));\n        c.alternateEffects = construct_empty_effects(realm);\n        return result;\n      }\n    } else {\n      if (c.consequent instanceof Value) {\n        let result = c.consequentEffects;\n        c.consequentEffects = construct_empty_effects(realm);\n        return result;\n      } else {\n        invariant(c.consequent instanceof PossiblyNormalCompletion);\n        let result = realm.composeEffects(c.consequentEffects, this.removeNormalEffects(realm, c.consequent));\n        c.consequentEffects = construct_empty_effects(realm);\n        return result;\n      }\n    }\n  }\n\n  joinEffects(realm: Realm, joinCondition: AbstractValue, e1: Effects, e2: Effects): Effects {\n    let [result1, gen1, bindings1, properties1, createdObj1] = e1;\n    let [result2, gen2, bindings2, properties2, createdObj2] = e2;\n\n    let result = this.joinResults(realm, joinCondition, result1, result2, e1, e2);\n    if (result1 instanceof AbruptCompletion) {\n      if (!(result2 instanceof AbruptCompletion)) {\n        invariant(result instanceof PossiblyNormalCompletion);\n        return [result, gen2, bindings2, properties2, createdObj2];\n      }\n    } else if (result2 instanceof AbruptCompletion) {\n      invariant(result instanceof PossiblyNormalCompletion);\n      return [result, gen1, bindings1, properties1, createdObj1];\n    }\n\n    let bindings = this.joinBindings(realm, joinCondition, bindings1, bindings2);\n    let properties = this.joinPropertyBindings(\n      realm,\n      joinCondition,\n      properties1,\n      properties2,\n      createdObj1,\n      createdObj2\n    );\n    let createdObjects = new Set();\n    createdObj1.forEach(o => {\n      createdObjects.add(o);\n    });\n    createdObj2.forEach(o => {\n      createdObjects.add(o);\n    });\n\n    let generator = joinGenerators(realm, joinCondition, gen1, gen2);\n\n    return [result, generator, bindings, properties, createdObjects];\n  }\n\n  joinResults(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    result1: EvaluationResult,\n    result2: EvaluationResult,\n    e1: Effects,\n    e2: Effects\n  ): AbruptCompletion | PossiblyNormalCompletion | Value {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);\n    };\n    if (result1 instanceof Reference || result2 instanceof Reference) {\n      AbstractValue.reportIntrospectionError(joinCondition);\n      throw new FatalError();\n    }\n    if (result1 instanceof BreakCompletion && result2 instanceof BreakCompletion && result1.target === result2.target) {\n      return new BreakCompletion(realm.intrinsics.empty, joinCondition.expressionLocation, result1.target);\n    }\n    if (\n      result1 instanceof ContinueCompletion &&\n      result2 instanceof ContinueCompletion &&\n      result1.target === result2.target\n    ) {\n      return new ContinueCompletion(realm.intrinsics.empty, joinCondition.expressionLocation, result1.target);\n    }\n    if (result1 instanceof ReturnCompletion && result2 instanceof ReturnCompletion) {\n      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);\n      invariant(val instanceof Value);\n      return new ReturnCompletion(val, joinCondition.expressionLocation);\n    }\n    if (result1 instanceof ThrowCompletion && result2 instanceof ThrowCompletion) {\n      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);\n      invariant(val instanceof Value);\n      return new ThrowCompletion(val, result1.location);\n    }\n    if (result1 instanceof AbruptCompletion && result2 instanceof AbruptCompletion) {\n      return new JoinedAbruptCompletions(realm, joinCondition, result1, e1, result2, e2);\n    }\n    if (result1 instanceof Value && result2 instanceof Value) {\n      let val = this.joinValues(realm, result1, result2, getAbstractValue);\n      invariant(val instanceof Value);\n      return val;\n    }\n    if (result1 instanceof PossiblyNormalCompletion && result2 instanceof PossiblyNormalCompletion) {\n      return this.joinPossiblyNormalCompletions(realm, joinCondition, result1, result2);\n    }\n    if (result1 instanceof AbruptCompletion) {\n      let value = result2;\n      let savedEffects;\n      let pathConditions;\n      let savedPathConditions = [];\n      if (result2 instanceof PossiblyNormalCompletion) {\n        value = result2.value;\n        savedEffects = result2.savedEffects;\n        pathConditions = [joinCondition].concat(result2.pathConditions);\n        savedPathConditions = result2.savedPathConditions;\n      } else {\n        pathConditions = [joinCondition];\n      }\n      invariant(value instanceof Value);\n      return new PossiblyNormalCompletion(\n        value,\n        joinCondition,\n        result1,\n        e1,\n        result2,\n        e2,\n        pathConditions,\n        savedPathConditions,\n        savedEffects\n      );\n    }\n    if (result2 instanceof AbruptCompletion) {\n      let value = result1;\n      let savedEffects;\n      let pathConditions;\n      let savedPathConditions = [];\n      if (result1 instanceof PossiblyNormalCompletion) {\n        value = result1.value;\n        savedEffects = result1.savedEffects;\n        pathConditions = [joinCondition].concat(result1.pathConditions);\n        savedPathConditions = result1.savedPathConditions;\n      } else {\n        pathConditions = [joinCondition];\n      }\n      invariant(value instanceof Value);\n      return new PossiblyNormalCompletion(\n        value,\n        joinCondition,\n        result1,\n        e1,\n        result2,\n        e2,\n        pathConditions,\n        savedPathConditions,\n        savedEffects\n      );\n    }\n    if (result1 instanceof PossiblyNormalCompletion) {\n      invariant(result2 instanceof Value);\n      this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, result1, result2);\n      return result1;\n    }\n    if (result2 instanceof PossiblyNormalCompletion) {\n      invariant(result1 instanceof Value);\n      this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, result2, result1);\n      return result2;\n    }\n    invariant(false);\n  }\n\n  composeGenerators(realm: Realm, generator1: Generator, generator2: Generator): Generator {\n    let result = new Generator(realm);\n    if (!generator1.empty() || !generator2.empty()) {\n      result.composeGenerators(generator1, generator2);\n    }\n    return result;\n  }\n\n  // Creates a single map that joins together maps m1 and m2 using the given join\n  // operator. If an entry is present in one map but not the other, the missing\n  // entry is treated as if it were there and its value were undefined.\n  joinMaps<K, V>(m1: Map<K, V>, m2: Map<K, V>, join: (K, void | V, void | V) => V): Map<K, V> {\n    let m3: Map<K, V> = new Map();\n    m1.forEach((val1, key, map1) => {\n      let val2 = m2.get(key);\n      let val3 = join(key, val1, val2);\n      m3.set(key, val3);\n    });\n    m2.forEach((val2, key, map2) => {\n      if (!m1.has(key)) {\n        m3.set(key, join(key, undefined, val2));\n      }\n    });\n    return m3;\n  }\n\n  // Creates a single map that has an key, value pair for the union of the key\n  // sets of m1 and m2. The value of a pair is the join of m1[key] and m2[key]\n  // where the join is defined to be just m1[key] if m1[key] === m2[key] and\n  // and abstract value with expression \"joinCondition ? m1[key] : m2[key]\" if not.\n  joinBindings(realm: Realm, joinCondition: AbstractValue, m1: Bindings, m2: Bindings): Bindings {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);\n    };\n    let join = (b: Binding, b1: void | BindingEntry, b2: void | BindingEntry) => {\n      let l1 = b1 === undefined ? b.hasLeaked : b1.hasLeaked;\n      let l2 = b2 === undefined ? b.hasLeaked : b2.hasLeaked;\n      let v1 = b1 === undefined ? b.value : b1.value;\n      let v2 = b2 === undefined ? b.value : b2.value;\n      let hasLeaked = l1 || l2; // If either has leaked, then this binding has leaked.\n      let value = this.joinValues(realm, v1, v2, getAbstractValue);\n      invariant(value instanceof Value);\n      return { hasLeaked, value };\n    };\n    return this.joinMaps(m1, m2, join);\n  }\n\n  // If v1 is known and defined and v1 === v2 return v1,\n  // otherwise return getAbstractValue(v1, v2)\n  joinValues(\n    realm: Realm,\n    v1: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    getAbstractValue: (void | Value, void | Value) => Value\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    if (Array.isArray(v1) || Array.isArray(v2)) {\n      invariant(v1 === undefined || Array.isArray(v1));\n      invariant(v2 === undefined || Array.isArray(v2));\n      return joinArrays(realm, ((v1: any): void | Array<Value>), ((v2: any): void | Array<Value>), getAbstractValue);\n    }\n    invariant(v1 === undefined || v1 instanceof Value);\n    invariant(v2 === undefined || v2 instanceof Value);\n    if (\n      v1 !== undefined &&\n      v2 !== undefined &&\n      !(v1 instanceof AbstractValue) &&\n      !(v2 instanceof AbstractValue) &&\n      StrictEqualityComparison(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())\n    ) {\n      return v1;\n    } else {\n      return getAbstractValue(v1, v2);\n    }\n  }\n\n  joinValuesAsConditional(realm: Realm, condition: AbstractValue, v1: void | Value, v2: void | Value): Value {\n    return AbstractValue.createFromConditionalOp(realm, condition, v1, v2);\n  }\n\n  joinPropertyBindings(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): PropertyBindings {\n    let join = (b: PropertyBinding, d1: void | Descriptor, d2: void | Descriptor) => {\n      // If the PropertyBinding object has been freshly allocated do not join\n      if (d1 === undefined) {\n        if (b.object instanceof ObjectValue && c2.has(b.object)) return d2; // no join\n        if (b.descriptor !== undefined && m1.has(b)) {\n          // property was deleted\n          d1 = cloneDescriptor(b.descriptor);\n          invariant(d1 !== undefined);\n          d1.value = realm.intrinsics.empty;\n        } else {\n          // no write to property\n          d1 = b.descriptor; //Get value of property before the split\n        }\n      }\n      if (d2 === undefined) {\n        if (b.object instanceof ObjectValue && c1.has(b.object)) return d1; // no join\n        if (b.descriptor !== undefined && m2.has(b)) {\n          // property was deleted\n          d2 = cloneDescriptor(b.descriptor);\n          invariant(d2 !== undefined);\n          d2.value = realm.intrinsics.empty;\n        } else {\n          // no write to property\n          d2 = b.descriptor; //Get value of property before the split\n        }\n      }\n      return this.joinDescriptors(realm, joinCondition, d1, d2);\n    };\n    return this.joinMaps(m1, m2, join);\n  }\n\n  joinDescriptors(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    d1: void | Descriptor,\n    d2: void | Descriptor\n  ): void | Descriptor {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);\n    };\n    let clone_with_abstract_value = (d: Descriptor) => {\n      if (!IsDataDescriptor(realm, d)) {\n        let d3: Descriptor = {};\n        d3.joinCondition = joinCondition;\n        return d3;\n      }\n      let dc = cloneDescriptor(d);\n      invariant(dc !== undefined);\n      let dcValue = dc.value;\n      if (Array.isArray(dcValue)) {\n        invariant(dcValue.length > 0);\n        let elem0 = dcValue[0];\n        if (elem0 instanceof Value) {\n          dc.value = dcValue.map(e => getAbstractValue((e: any), realm.intrinsics.empty));\n        } else {\n          dc.value = dcValue.map(e => {\n            let { $Key: key1, $Value: val1 } = (e: any);\n            let key3 = getAbstractValue(key1, realm.intrinsics.empty);\n            let val3 = getAbstractValue(val1, realm.intrinsics.empty);\n            return { $Key: key3, $Value: val3 };\n          });\n        }\n      } else {\n        invariant(dcValue === undefined || dcValue instanceof Value);\n        dc.value = getAbstractValue(dcValue, realm.intrinsics.empty);\n      }\n      return dc;\n    };\n    if (d1 === undefined) {\n      if (d2 === undefined) return undefined;\n      // d2 is a new property created in only one branch, join with empty\n      let d3 = clone_with_abstract_value(d2);\n      if (!IsDataDescriptor(realm, d2)) d3.descriptor2 = d2;\n      return d3;\n    } else if (d2 === undefined) {\n      invariant(d1 !== undefined);\n      // d1 is a new property created in only one branch, join with empty\n      let d3 = clone_with_abstract_value(d1);\n      if (!IsDataDescriptor(realm, d1)) d3.descriptor1 = d1;\n      return d3;\n    } else {\n      if (equalDescriptors(d1, d2) && IsDataDescriptor(realm, d1)) {\n        let dc = cloneDescriptor(d1);\n        invariant(dc !== undefined);\n        dc.value = this.joinValues(realm, d1.value, d2.value, getAbstractValue);\n        return dc;\n      }\n      let d3: Descriptor = {};\n      d3.joinCondition = joinCondition;\n      d3.descriptor1 = d1;\n      d3.descriptor2 = d2;\n      return d3;\n    }\n  }\n}\n"]}