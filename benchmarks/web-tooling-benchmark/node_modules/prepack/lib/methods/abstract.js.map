{"version":3,"sources":["../../src/methods/abstract.js"],"names":["SplitMatch","RequireObjectCoercible","HasSameType","AbstractRelationalComparison","AbstractEqualityComparison","StrictEqualityComparison","StrictEqualityComparisonPartial","SameValueZero","SameValueZeroPartial","SameValue","SameValuePartial","SameValueNonNumber","SamePropertyKey","Add","InstanceofOperator","OrdinaryHasInstance","Type","SymbolDescriptiveString","UpdateEmpty","URIReserved","URIAlpha","DecimalDigit","URIMark","URIUnescaped","realm","S","q","R","r","length","s","i","arg","argLoc","mightBeNull","mightBeUndefined","isInPureScope","error","describe","handleError","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","x","y","xType","getType","yType","LeftFirst","px","py","ToPrimitive","value","startsWith","false","true","k","charCodeAt","m","n","nx","ToNumber","ny","isNaN","undefined","Object","is","a","b","subtract","NaN","anum","bnum","createFromNumberValue","O","C","mightBeObject","instOfHandler","SymbolHasInstance","ToBooleanPartial","BC","$BoundTargetFunction","P","$GetPrototypeOf","val","mightNotBeObject","reportIntrospectionError","sym","desc","$Description","throwIfNotConcreteString","completionRecord"],"mappings":"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","file":"abstract.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport {\n  BoundFunctionValue,\n  EmptyValue,\n  NumberValue,\n  IntegralValue,\n  SymbolValue,\n  StringValue,\n  NullValue,\n  ObjectValue,\n  Value,\n  BooleanValue,\n  UndefinedValue,\n  ConcreteValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport { Call } from \"./call.js\";\nimport { IsCallable } from \"./is.js\";\nimport { Completion, ReturnCompletion, ThrowCompletion } from \"../completions.js\";\nimport { GetMethod, Get } from \"./get.js\";\nimport { HasCompatibleType } from \"./has.js\";\nimport { To } from \"../singletons.js\";\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport const URIReserved = \";/?:@&=+$,\";\nexport const URIAlpha = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nexport const DecimalDigit = \"0123456789\";\nexport const URIMark = \"-_.!~*'()\";\nexport const URIUnescaped = URIAlpha + DecimalDigit + URIMark;\n\n// ECMA262 21.1.3.17.1\nexport function SplitMatch(realm: Realm, S: string, q: number, R: string): false | number {\n  // 1. Assert: Type(R) is String.\n  invariant(typeof R === \"string\", \"expected a string\");\n\n  // 2. Let r be the number of code units in R.\n  let r = R.length;\n\n  // 3. Let s be the number of code units in S.\n  let s = S.length;\n\n  // 4. If q+r > s, return false.\n  if (q + r > s) return false;\n\n  // 5. If there exists an integer i between 0 (inclusive) and r (exclusive) such that the code unit at index\n  //    q+i of S is different from the code unit at index i of R, return false.\n  for (let i = 0; i < r; i++) {\n    if (S[q + i] !== R[i]) {\n      return false;\n    }\n  }\n\n  // 6. Return q+r.\n  return q + r;\n}\n\n// ECMA262 7.2.1\nexport function RequireObjectCoercible(\n  realm: Realm,\n  arg: Value,\n  argLoc?: ?BabelNodeSourceLocation\n): AbstractValue | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue {\n  if (arg instanceof AbstractValue && (arg.mightBeNull() || arg.mightBeUndefined())) {\n    if (realm.isInPureScope()) {\n      // In a pure function it is ok to throw if this happens to be null or undefined.\n      return arg;\n    }\n    if (argLoc) {\n      let error = new CompilerDiagnostic(\n        `member expression object ${AbstractValue.describe(arg)} is unknown`,\n        argLoc,\n        \"PP0012\",\n        \"FatalError\"\n      );\n      realm.handleError(error);\n      throw new FatalError();\n    }\n    arg.throwIfNotConcrete();\n  }\n  if (arg instanceof NullValue || arg instanceof UndefinedValue) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"null or undefined\");\n  } else {\n    return (arg: any);\n  }\n}\n\nexport function HasSameType(x: ConcreteValue, y: ConcreteValue): boolean {\n  const xType = x.getType();\n  const yType = y.getType();\n  return (\n    xType === yType ||\n    ((xType === IntegralValue || xType === NumberValue) && (yType === IntegralValue || yType === NumberValue))\n  );\n}\n\n// ECMA262 7.2.12 Abstract Relational Comparison\nexport function AbstractRelationalComparison(\n  realm: Realm,\n  x: ConcreteValue,\n  y: ConcreteValue,\n  LeftFirst: boolean\n): BooleanValue | UndefinedValue {\n  let px, py;\n\n  // 1. If the LeftFirst flag is true, then\n  if (LeftFirst) {\n    // a. Let px be ? ToPrimitive(x, hint Number).\n    px = To.ToPrimitive(realm, x, \"number\");\n\n    // b. Let py be ? ToPrimitive(y, hint Number).\n    py = To.ToPrimitive(realm, y, \"number\");\n  } else {\n    // 2. Else the order of evaluation needs to be reversed to preserve left to right evaluation\n    // a. Let py be ? ToPrimitive(y, hint Number).\n    py = To.ToPrimitive(realm, y, \"number\");\n\n    // b. Let px be ? ToPrimitive(x, hint Number).\n    px = To.ToPrimitive(realm, x, \"number\");\n  }\n\n  // 3. If both px and py are Strings, then\n  if (px instanceof StringValue && py instanceof StringValue) {\n    // a. If py is a prefix of px, return false. (A String value p is a prefix of String value q if q can be the result of concatenating p and some other String r. Note that any String is a prefix of itself, because r may be the empty String.)\n    if (px.value.startsWith(py.value)) return realm.intrinsics.false;\n\n    // b. If px is a prefix of py, return true.\n    if (py.value.startsWith(px.value)) return realm.intrinsics.true;\n\n    // c. Let k be the smallest nonnegative integer such that the code unit at index k within px is different from the code unit at index k within py. (There must be such a k, for neither String is a prefix of the other.)\n    let k = 0;\n    while (px.value.charCodeAt(k) === py.value.charCodeAt(k)) {\n      k += 1;\n    }\n\n    // d. Let m be the integer that is the code unit value at index k within px.\n    let m = px.value.charCodeAt(k);\n\n    // e. Let n be the integer that is the code unit value at index k within py.\n    let n = py.value.charCodeAt(k);\n\n    // f. If m < n, return true. Otherwise, return false.\n    return m < n ? realm.intrinsics.true : realm.intrinsics.false;\n  } else {\n    // 4. Else,\n    // a. Let nx be ? ToNumber(px). Because px and py are primitive values evaluation order is not important.\n    let nx = To.ToNumber(realm, px);\n\n    // b. Let ny be ? ToNumber(py).\n    let ny = To.ToNumber(realm, py);\n\n    // c. If nx is NaN, return undefined.\n    if (isNaN(nx)) return realm.intrinsics.undefined;\n\n    // d. If ny is NaN, return undefined.\n    if (isNaN(ny)) return realm.intrinsics.undefined;\n\n    // e. If nx and ny are the same Number value, return false.\n    if (Object.is(nx, ny)) {\n      return realm.intrinsics.false;\n    }\n\n    // f. If nx is +0 and ny is -0, return false.\n    if (Object.is(nx, +0) && Object.is(ny, -0)) {\n      return realm.intrinsics.false;\n    }\n\n    // g. If nx is -0 and ny is +0, return false.\n    if (Object.is(nx, -0) && Object.is(ny, +0)) {\n      return realm.intrinsics.false;\n    }\n\n    // h. If nx is +∞, return false.\n    // i. If ny is +∞, return true.\n    // j. If ny is -∞, return false.\n    // k. If nx is -∞, return true.\n\n    // i. If the mathematical value of nx is less than the mathematical value of ny —note that these\n    //    mathematical values are both finite and not both zero—return true. Otherwise, return false.\n    if (nx < ny) {\n      return realm.intrinsics.true;\n    } else {\n      return realm.intrinsics.false;\n    }\n  }\n}\n\n// ECMA262 7.2.13\nexport function AbstractEqualityComparison(realm: Realm, x: ConcreteValue, y: ConcreteValue): boolean {\n  // 1. If Type(x) is the same as Type(y), then\n  if (HasSameType(x, y)) {\n    // a. Return the result of performing Strict Equality Comparison x === y.\n    return StrictEqualityComparison(realm, x, y);\n  }\n\n  // 2. If x is null and y is undefined, return true.\n  if (x instanceof NullValue && y instanceof UndefinedValue) {\n    return true;\n  }\n\n  // 3. If x is undefined and y is null, return true.\n  if (x instanceof UndefinedValue && y instanceof NullValue) {\n    return true;\n  }\n\n  // 4. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ToNumber(y).\n  if (x instanceof NumberValue && y instanceof StringValue) {\n    return AbstractEqualityComparison(realm, x, new NumberValue(realm, To.ToNumber(realm, y)));\n  }\n\n  // 5. If Type(x) is String and Type(y) is Number, return the result of the comparison ToNumber(x) == y.\n  if (x instanceof StringValue && y instanceof NumberValue) {\n    return AbstractEqualityComparison(realm, new NumberValue(realm, To.ToNumber(realm, x)), y);\n  }\n\n  // 6. If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.\n  if (x instanceof BooleanValue) {\n    return AbstractEqualityComparison(realm, new NumberValue(realm, To.ToNumber(realm, x)), y);\n  }\n\n  // 7. If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).\n  if (y instanceof BooleanValue) {\n    return AbstractEqualityComparison(realm, x, new NumberValue(realm, To.ToNumber(realm, y)));\n  }\n\n  // 8. If Type(x) is either String, Number, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).\n  if ((x instanceof StringValue || x instanceof NumberValue || x instanceof SymbolValue) && y instanceof ObjectValue) {\n    return AbstractEqualityComparison(realm, x, To.ToPrimitive(realm, y));\n  }\n\n  // 9. If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.\n  if (x instanceof ObjectValue && (y instanceof StringValue || y instanceof NumberValue || y instanceof SymbolValue)) {\n    return AbstractEqualityComparison(realm, To.ToPrimitive(realm, x), y);\n  }\n\n  // 10. Return false.\n  return false;\n}\n\n// ECMA262 7.2.14 Strict Equality Comparison\nexport function StrictEqualityComparison(realm: Realm, x: ConcreteValue, y: ConcreteValue): boolean {\n  // 1. If Type(x) is different from Type(y), return false.\n  if (!HasSameType(x, y)) {\n    return false;\n  }\n\n  // 2. If Type(x) is Number, then\n  if (x instanceof NumberValue && y instanceof NumberValue) {\n    // a. If x is NaN, return false.\n    if (isNaN(x.value)) return false;\n\n    // b. If y is NaN, return false.\n    if (isNaN(y.value)) return false;\n\n    // c. If x is the same Number value as y, return true.\n    // d. If x is +0 and y is -0, return true. (handled by c)\n    // e. If x is -0 and y is +0, return true. (handled by c)\n    if (x.value === y.value) return true;\n\n    // f. Return false.\n    return false;\n  }\n\n  // 3. Return SameValueNonNumber(x, y).\n  return SameValueNonNumber(realm, x, y);\n}\n\nexport function StrictEqualityComparisonPartial(realm: Realm, x: Value, y: Value): boolean {\n  return StrictEqualityComparison(realm, x.throwIfNotConcrete(), y.throwIfNotConcrete());\n}\n\n// ECMA262 7.2.10\nexport function SameValueZero(realm: Realm, x: ConcreteValue, y: ConcreteValue): boolean {\n  // 1. If Type(x) is different from Type(y), return false.\n  if (!HasSameType(x, y)) {\n    return false;\n  }\n\n  // 2. If Type(x) is Number, then\n  if (x instanceof NumberValue) {\n    invariant(y instanceof NumberValue);\n\n    // a. If x is NaN and y is NaN, return true.\n    if (isNaN(x.value) && isNaN(y.value)) return true;\n\n    // b. If x is +0 and y is -0, return true.\n    if (Object.is(x.value, +0) && Object.is(y.value, -0)) return true;\n\n    // c. If x is -0 and y is +0, return true.\n    if (Object.is(x.value, -0) && Object.is(y.value, +0)) return true;\n\n    // d. If x is the same Number value as y, return true.\n    if (x.value === y.value) return true;\n\n    // e. Return false.\n    return false;\n  }\n\n  // 3. Return SameValueNonNumber(x, y).\n  return SameValueNonNumber(realm, x, y);\n}\n\nexport function SameValueZeroPartial(realm: Realm, x: Value, y: Value): boolean {\n  return SameValueZero(realm, x.throwIfNotConcrete(), y.throwIfNotConcrete());\n}\n\n// ECMA262 7.2.9\nexport function SameValue(realm: Realm, x: ConcreteValue, y: ConcreteValue): boolean {\n  // 1. If Type(x) is different from Type(y), return false.\n  if (!HasSameType(x, y)) {\n    return false;\n  }\n\n  // 2. If Type(x) is Number, then\n  if (x instanceof NumberValue && y instanceof NumberValue) {\n    // a. If x is NaN and y is NaN, return true.\n    if (isNaN(x.value) && isNaN(y.value)) return true;\n\n    // b. If x is +0 and y is -0, return false.\n    if (Object.is(x.value, +0) && Object.is(y.value, -0)) return false;\n\n    // c. If x is -0 and y is +0, return false.\n    if (Object.is(x.value, -0) && Object.is(y.value, +0)) return false;\n\n    // d. If x is the same Number value as y, return true.\n    if (x.value === y.value) return true;\n\n    // e. Return false.\n    return false;\n  }\n\n  // 3. Return SameValueNonNumber(x, y).\n  return SameValueNonNumber(realm, x, y);\n}\n\nexport function SameValuePartial(realm: Realm, x: Value, y: Value): boolean {\n  return SameValue(realm, x.throwIfNotConcrete(), y.throwIfNotConcrete());\n}\n\n// ECMA262 7.2.11\nexport function SameValueNonNumber(realm: Realm, x: ConcreteValue, y: ConcreteValue): boolean {\n  // 1. Assert: Type(x) is not Number.\n  invariant(!(x instanceof NumberValue), \"numbers not allowed\");\n\n  // 2. Assert: Type(x) is the same as Type(y).\n  invariant(x.getType() === y.getType(), \"must be same type\");\n\n  // 3. If Type(x) is Undefined, return true.\n  if (x instanceof UndefinedValue) return true;\n\n  // 4. If Type(x) is Null, return true.\n  if (x instanceof NullValue) return true;\n\n  // 5. If Type(x) is String, then\n  if (x instanceof StringValue && y instanceof StringValue) {\n    // a. If x and y are exactly the same sequence of code units (same length and same code units at corresponding indices), return true; otherwise, return false.\n    return x.value === y.value;\n  }\n\n  // 6. If Type(x) is Boolean, then\n  if (x instanceof BooleanValue && y instanceof BooleanValue) {\n    // a. If x and y are both true or both false, return true; otherwise, return false.\n    return x.value === y.value;\n  }\n\n  // 7. If Type(x) is Symbol, then\n  if (x instanceof SymbolValue) {\n    // a. If x and y are both the same Symbol value, return true; otherwise, return false.\n    return x === y;\n  }\n\n  // 8. Return true if x and y are the same Object value. Otherwise, return false.\n  return x === y;\n}\n\n// Checks if two property keys are identical.\nexport function SamePropertyKey(realm: Realm, x: PropertyKeyValue, y: PropertyKeyValue) {\n  if (typeof x === \"string\" && typeof y === \"string\") {\n    return x === y;\n  }\n  if (x instanceof StringValue && y instanceof StringValue) {\n    return x.value === y.value;\n  }\n  if (x instanceof SymbolValue && y instanceof SymbolValue) {\n    return x === y;\n  }\n  return false;\n}\n\n// ECMA262 12.8.5 Applying the Additive Operators to Numbers\nexport function Add(realm: Realm, a: number, b: number, subtract?: boolean = false): NumberValue {\n  // If either operand is NaN, the result is NaN.\n  if (isNaN(a) || isNaN(b)) {\n    return realm.intrinsics.NaN;\n  }\n\n  // The sum of two infinities of opposite sign is NaN.\n  // The sum of two infinities of the same sign is the infinity of that sign.\n  // The sum of an infinity and a finite value is equal to the infinite operand.\n  // The sum of two negative zeroes is -0. The sum of two positive zeroes, or of two zeroes of opposite sign, is +0.\n  // The sum of a zero and a nonzero finite value is equal to the nonzero operand.\n  // The sum of two nonzero finite values of the same magnitude and opposite sign is +0.\n\n  let anum = a;\n  let bnum = b;\n\n  // The - operator performs subtraction when applied to two operands of numeric type,\n  // producing the difference of its operands; the left operand is the minuend and the right\n  // operand is the subtrahend. Given numeric operands a and b, it is always the case that\n  // a-b produces the same result as a+(-b).\n  if (subtract) {\n    bnum = -bnum;\n  }\n\n  return IntegralValue.createFromNumberValue(realm, anum + bnum);\n}\n\n// ECMA262 12.10.4\nexport function InstanceofOperator(realm: Realm, O: Value, C: Value): boolean {\n  // 1. If Type(C) is not Object, throw a TypeError exception.\n  if (!C.mightBeObject()) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Expecting a function in instanceof check\");\n  }\n\n  // 2. Let instOfHandler be ? GetMethod(C, @@hasInstance).\n  let instOfHandler = GetMethod(realm, C, realm.intrinsics.SymbolHasInstance);\n\n  // 3. If instOfHandler is not undefined, then\n  if (!(instOfHandler instanceof UndefinedValue)) {\n    // a. Return ToBoolean(? Call(instOfHandler, C, « O »)).\n    return To.ToBooleanPartial(realm, Call(realm, instOfHandler, C, [O]));\n  }\n\n  // 4. If IsCallable(C) is false, throw a TypeError exception.\n  if (IsCallable(realm, C) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Expecting a function in instanceof check\");\n  }\n\n  // 5. Return ? OrdinaryHasInstance(C, O).\n  return OrdinaryHasInstance(realm, C, O);\n}\n\n// ECMA262 7.3.19\nexport function OrdinaryHasInstance(realm: Realm, C: Value, O: Value): boolean {\n  // 1. If IsCallable(C) is false, return false.\n  if (IsCallable(realm, C) === false) return false;\n  invariant(C instanceof ObjectValue);\n\n  // 2. If C has a [[BoundTargetFunction]] internal slot, then\n  if (C instanceof BoundFunctionValue) {\n    // a. Let BC be the value of C's [[BoundTargetFunction]] internal slot.\n    let BC = C.$BoundTargetFunction;\n\n    // b. Return ? InstanceofOperator(O, BC).\n    return InstanceofOperator(realm, O, BC);\n  }\n\n  // 3. If Type(O) is not Object, return false.\n  O = O.throwIfNotConcrete();\n  if (!(O instanceof ObjectValue)) return false;\n\n  // 4. Let P be ? Get(C, \"prototype\").\n  let P = Get(realm, C, \"prototype\").throwIfNotConcrete();\n\n  // 5. If Type(P) is not Object, throw a TypeError exception.\n  if (!(P instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(P) is not Object\");\n  }\n\n  // 6. Repeat\n  while (true) {\n    // a. Let O be ? O.[[GetPrototypeOf]]().\n    O = O.$GetPrototypeOf();\n\n    // b. If O is null, return false.\n    if (O instanceof NullValue) return false;\n\n    // c. If SameValue(P, O) is true, return true.\n    if (SameValue(realm, P, O) === true) return true;\n  }\n\n  return false;\n}\n\n//\nexport function Type(realm: Realm, val: Value): string {\n  if (val instanceof UndefinedValue) {\n    return \"Undefined\";\n  } else if (val instanceof NullValue) {\n    return \"Null\";\n  } else if (HasCompatibleType(val, BooleanValue)) {\n    return \"Boolean\";\n  } else if (HasCompatibleType(val, StringValue)) {\n    return \"String\";\n  } else if (HasCompatibleType(val, SymbolValue)) {\n    return \"Symbol\";\n  } else if (HasCompatibleType(val, IntegralValue)) {\n    return \"Number\";\n  } else if (HasCompatibleType(val, NumberValue)) {\n    return \"Number\";\n  } else if (!val.mightNotBeObject()) {\n    return \"Object\";\n  } else {\n    invariant(val instanceof AbstractValue);\n    AbstractValue.reportIntrospectionError(val);\n    throw new FatalError();\n  }\n}\n\n// ECMA262 19.4.3.2.1\nexport function SymbolDescriptiveString(realm: Realm, sym: SymbolValue): string {\n  // 1. Assert: Type(sym) is Symbol.\n  invariant(sym instanceof SymbolValue, \"expected symbol\");\n\n  // 2. Let desc be sym's [[Description]] value.\n  let desc = sym.$Description;\n\n  // 3. If desc is undefined, let desc be the empty string.\n  if (!desc) desc = \"\";\n  else desc = desc.throwIfNotConcreteString().value;\n\n  // 4. Assert: Type(desc) is String.\n  invariant(typeof desc === \"string\", \"expected string\");\n\n  // 5. Return the result of concatenating the strings \"Symbol(\", desc, and \")\".\n  return `Symbol(${desc})`;\n}\n\n// ECMA262 6.2.2.5\nexport function UpdateEmpty(realm: Realm, completionRecord: Completion | Value, value: Value): Completion | Value {\n  // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.\n  if (completionRecord instanceof ReturnCompletion || completionRecord instanceof ThrowCompletion) {\n    invariant(completionRecord.value, \"expected completion record to have a value\");\n  }\n\n  // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).\n  if (completionRecord instanceof EmptyValue) return value;\n  if (completionRecord instanceof Value || (completionRecord.value && !(completionRecord.value instanceof EmptyValue)))\n    return completionRecord;\n\n  // 3. Return Completion{[[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.'\n  completionRecord.value = value;\n  return completionRecord;\n}\n"]}