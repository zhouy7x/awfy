{"version":3,"sources":["../../src/methods/widen.js"],"names":["t","WidenImplementation","_widenArrays","realm","v1","v2","e","_widenArraysOfValues","_widenArrayOfsMapEntries","a1","a2","empty","intrinsics","n","Math","max","length","result","i","$Key","key1","$Value","val1","key2","val2","undefined","key3","widenValues","val3","wv","widenEffects","e1","e2","result1","bindings1","properties1","createdObj1","result2","bindings2","properties2","createdObj2","widenResults","bindings","widenBindings","properties","widenPropertyBindings","createdObjects","Set","generator","val","widenMaps","m1","m2","widen","m3","Map","forEach","key","map1","get","set","map2","has","b","b1","b2","l1","hasLeaked","l2","value","kind","phiNode","derive","types","values","skipInvariant","intrinsicName","phiName","_buildNode","args","identifier","Array","isArray","throwIfNotConcrete","createFromWidening","c1","c2","d1","d2","object","descriptor","widenDescriptors","rval","pathNode","mightNotBeString","mightNotBeNumber","createFromWidenedProperty","o","memberExpression","p","initVal","emitVoidExpression","v","assignmentExpression","dc","containsEffects","containsResults","containsBindings","containsPropertyBindings","_containsValues","containsMap","f","entries","keys","containsBinding","containsPropertyBinding","_containsArray","containsArraysOfValue","_containsArrayOfsMapEntries","equals","isTypeCompatibleWith","getType","containsValue"],"mappings":";;;;;;;AAYA;;AAYA;;AACA;;AACA;;AACA;;AACA;;AAEA;;;;AACA;;IAAYA,C;;;;;;AAEL,MAAMC,mBAAN,CAA0B;AAC/BC,eACEC,KADF,EAEEC,EAFF,EAGEC,EAHF,EAIsE;AACpE,QAAIC,IAAKF,MAAMA,GAAG,CAAH,CAAP,IAAkBC,MAAMA,GAAG,CAAH,CAAhC;AACA,QAAIC,0BAAJ,EAAwB,OAAO,KAAKC,oBAAL,CAA0BJ,KAA1B,EAAkCC,EAAlC,EAA6CC,EAA7C,CAAP,CAAxB,KACK,OAAO,KAAKG,wBAAL,CAA8BL,KAA9B,EAAsCC,EAAtC,EAAiDC,EAAjD,CAAP;AACN;;AAEDG,2BACEL,KADF,EAEEM,EAFF,EAGEC,EAHF,EAIuD;AACrD,QAAIC,QAAQR,MAAMS,UAAN,CAAiBD,KAA7B;AACA,QAAIE,IAAIC,KAAKC,GAAL,CAAUN,MAAMA,GAAGO,MAAV,IAAqB,CAA9B,EAAkCN,MAAMA,GAAGM,MAAV,IAAqB,CAAtD,CAAR;AACA,QAAIC,SAA8D,EAAlE;AACA,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIL,CAApB,EAAuBK,GAAvB,EAA4B;AAC1B,UAAI,EAAEC,MAAMC,IAAR,EAAcC,QAAQC,IAAtB,KAAgCb,MAAMA,GAAGS,CAAH,CAAP,IAAiB,EAAEC,MAAMR,KAAR,EAAeU,QAAQV,KAAvB,EAApD;AACA,UAAI,EAAEQ,MAAMI,IAAR,EAAcF,QAAQG,IAAtB,KAAgCd,MAAMA,GAAGQ,CAAH,CAAP,IAAiB,EAAEC,MAAMR,KAAR,EAAeU,QAAQV,KAAvB,EAApD;AACA,UAAIS,SAASK,SAAT,IAAsBF,SAASE,SAAnC,EAA8C;AAC5CR,eAAOC,CAAP,IAAY,EAAEC,MAAMM,SAAR,EAAmBJ,QAAQI,SAA3B,EAAZ;AACD,OAFD,MAEO;AACL,YAAIC,OAAO,KAAKC,WAAL,CAAiBxB,KAAjB,EAAwBiB,IAAxB,EAA8BG,IAA9B,CAAX;AACA,iCAAUG,6BAAV;AACA,YAAIE,OAAO,KAAKD,WAAL,CAAiBxB,KAAjB,EAAwBmB,IAAxB,EAA8BE,IAA9B,CAAX;AACA,iCAAUI,SAASH,SAAT,IAAsBG,6BAAhC;AACAX,eAAOC,CAAP,IAAY,EAAEC,MAAMO,IAAR,EAAcL,QAAQO,IAAtB,EAAZ;AACD;AACF;AACD,WAAOX,MAAP;AACD;;AAEDV,uBAAqBJ,KAArB,EAAmCM,EAAnC,EAA4DC,EAA5D,EAAmG;AACjG,QAAIG,IAAIC,KAAKC,GAAL,CAAUN,MAAMA,GAAGO,MAAV,IAAqB,CAA9B,EAAkCN,MAAMA,GAAGM,MAAV,IAAqB,CAAtD,CAAR;AACA,QAAIC,SAAS,EAAb;AACA,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIL,CAApB,EAAuBK,GAAvB,EAA4B;AAC1B,UAAIW,KAAK,KAAKF,WAAL,CAAiBxB,KAAjB,EAAyBM,MAAMA,GAAGS,CAAH,CAAP,IAAiBO,SAAzC,EAAqDf,MAAMA,GAAGQ,CAAH,CAAP,IAAiBO,SAArE,CAAT;AACA,+BAAUI,OAAOJ,SAAP,IAAoBI,2BAA9B;AACAZ,aAAOC,CAAP,IAAYW,EAAZ;AACD;AACD,WAAOZ,MAAP;AACD;;AAED;AACAa,eAAa3B,KAAb,EAA2B4B,EAA3B,EAAwCC,EAAxC,EAA8D;AAC5D,QAAI,CAACC,OAAD,GAAYC,SAAZ,EAAuBC,WAAvB,EAAoCC,WAApC,IAAmDL,EAAvD;AACA,QAAI,CAACM,OAAD,GAAYC,SAAZ,EAAuBC,WAAvB,EAAoCC,WAApC,IAAmDR,EAAvD;;AAEA,QAAIf,SAAS,KAAKwB,YAAL,CAAkBtC,KAAlB,EAAyB8B,OAAzB,EAAkCI,OAAlC,CAAb;AACA,QAAIK,WAAW,KAAKC,aAAL,CAAmBxC,KAAnB,EAA0B+B,SAA1B,EAAqCI,SAArC,CAAf;AACA,QAAIM,aAAa,KAAKC,qBAAL,CAA2B1C,KAA3B,EAAkCgC,WAAlC,EAA+CI,WAA/C,EAA4DH,WAA5D,EAAyEI,WAAzE,CAAjB;AACA,QAAIM,iBAAiB,IAAIC,GAAJ,EAArB,CAP4D,CAO5B;AAChC,QAAIC,YAAY,yBAAc7C,KAAd,EAAqB,OAArB,CAAhB,CAR4D,CAQb;AAC/C,WAAO,CAACc,MAAD,EAAS+B,SAAT,EAAoBN,QAApB,EAA8BE,UAA9B,EAA0CE,cAA1C,CAAP;AACD;;AAEDL,eAAatC,KAAb,EAA2B8B,OAA3B,EAAsDI,OAAtD,EAAmH;AACjH,6BAAU,EAAEJ,6CAAgCI,yCAAlC,CAAV,EAA2E,uCAA3E;AACA,6BACE,EAAEJ,oDAAuCI,gDAAzC,CADF,EAEE,iFAFF;AAIA,QAAIJ,oCAA4BI,gCAAhC,EAA0D;AACxD,UAAIY,MAAM,KAAKtB,WAAL,CAAiBxB,KAAjB,EAAwB8B,OAAxB,EAAiCI,OAAjC,CAAV;AACA,+BAAUY,4BAAV;AACA,aAAOA,GAAP;AACD;AACD,QAAIhB,4DAA+CI,wDAAnD,EAAgG;AAC9F;AACA;AACA;AACA;AACA,YAAM,wBAAN;AACD;AACD,6BAAU,KAAV;AACD;;AAEDa,YAAgBC,EAAhB,EAA+BC,EAA/B,EAA8CC,KAA9C,EAA8F;AAC5F,QAAIC,KAAgB,IAAIC,GAAJ,EAApB;AACAJ,OAAGK,OAAH,CAAW,CAAClC,IAAD,EAAOmC,GAAP,EAAYC,IAAZ,KAAqB;AAC9B,UAAIlC,OAAO4B,GAAGO,GAAH,CAAOF,GAAP,CAAX;AACA,UAAI7B,OAAOyB,MAAMI,GAAN,EAAWnC,IAAX,EAAiBE,IAAjB,CAAX;AACA8B,SAAGM,GAAH,CAAOH,GAAP,EAAY7B,IAAZ;AACD,KAJD;AAKAwB,OAAGI,OAAH,CAAW,CAAChC,IAAD,EAAOiC,GAAP,EAAYI,IAAZ,KAAqB;AAC9B,UAAI,CAACV,GAAGW,GAAH,CAAOL,GAAP,CAAL,EAAkB;AAChBH,WAAGM,GAAH,CAAOH,GAAP,EAAYJ,MAAMI,GAAN,EAAWhC,SAAX,EAAsBD,IAAtB,CAAZ;AACD;AACF,KAJD;AAKA,WAAO8B,EAAP;AACD;;AAEDX,gBAAcxC,KAAd,EAA4BgD,EAA5B,EAA0CC,EAA1C,EAAkE;AAChE,QAAIC,QAAQ,CAACU,CAAD,EAAaC,EAAb,EAAsCC,EAAtC,KAAkE;AAC5E,UAAIC,KAAKF,OAAOvC,SAAP,GAAmBsC,EAAEI,SAArB,GAAiCH,GAAGG,SAA7C;AACA,UAAIC,KAAKH,OAAOxC,SAAP,GAAmBsC,EAAEI,SAArB,GAAiCF,GAAGE,SAA7C;AACA,UAAIA,YAAYD,MAAME,EAAtB,CAH4E,CAGlD;AAC1B,UAAIhE,KAAK4D,OAAOvC,SAAP,IAAoBuC,GAAGK,KAAH,KAAa5C,SAAjC,GAA6CsC,EAAEM,KAA/C,GAAuDL,GAAGK,KAAnE;AACA,+BAAUJ,OAAOxC,SAAjB,EAL4E,CAK/C;AAC7B,UAAIpB,KAAK4D,GAAGI,KAAZ;AACA,+BAAUhE,OAAOoB,SAAjB;AACA,UAAIR,SAAS,KAAKU,WAAL,CAAiBxB,KAAjB,EAAwBC,EAAxB,EAA4BC,EAA5B,CAAb;AACA,UAAIY,2CAAmCA,OAAOqD,IAAP,KAAgB,SAAvD,EAAkE;AAChE,YAAIC,UAAUR,EAAEQ,OAAhB;AACA,YAAIA,YAAY9C,SAAhB,EAA2B;AACzB;AACA,cAAIuB,YAAY7C,MAAM6C,SAAtB;AACA,mCAAUA,cAAcvB,SAAxB;AACA8C,oBAAUvB,UAAUwB,MAAV,CAAiBvD,OAAOwD,KAAxB,EAA+BxD,OAAOyD,MAAtC,EAA8C,CAACX,EAAEM,KAAF,IAAWlE,MAAMS,UAAN,CAAiBa,SAA7B,CAA9C,EAAuF,CAAC,CAACZ,CAAD,CAAD,KAASA,CAAhG,EAAmG;AAC3G8D,2BAAe;AAD4F,WAAnG,CAAV;AAGAZ,YAAEQ,OAAF,GAAYA,OAAZ;AACD;AACD;AACA,iCAAUA,QAAQK,aAAR,KAA0BnD,SAApC;AACA,YAAIoD,UAAUN,QAAQK,aAAtB;AACA3D,eAAO2D,aAAP,GAAuBC,OAAvB;AACA5D,eAAO6D,UAAP,GAAoBC,QAAQ/E,EAAEgF,UAAF,CAAaH,OAAb,CAA5B;AACD;AACD,+BAAU5D,+BAAV;AACA,aAAO,EAAEkD,SAAF,EAAaE,OAAOpD,MAApB,EAAP;AACD,KA5BD;AA6BA,WAAO,KAAKiC,SAAL,CAAeC,EAAf,EAAmBC,EAAnB,EAAuBC,KAAvB,CAAP;AACD;;AAED;AACA1B,cACExB,KADF,EAEEC,EAFF,EAGEC,EAHF,EAI8E;AAC5E,QAAI4E,MAAMC,OAAN,CAAc9E,EAAd,KAAqB6E,MAAMC,OAAN,CAAc7E,EAAd,CAAzB,EAA4C;AAC1C,+BAAUD,OAAOqB,SAAP,IAAoBwD,MAAMC,OAAN,CAAc9E,EAAd,CAA9B;AACA,+BAAUC,OAAOoB,SAAP,IAAoBwD,MAAMC,OAAN,CAAc7E,EAAd,CAA9B;AACA,aAAO,KAAKH,YAAL,CAAkBC,KAAlB,EAA2BC,EAA3B,EAA6DC,EAA7D,CAAP;AACD;AACD,6BAAUD,OAAOqB,SAAP,IAAoBrB,2BAA9B;AACA,6BAAUC,OAAOoB,SAAP,IAAoBpB,2BAA9B;AACA,QACED,OAAOqB,SAAP,IACApB,OAAOoB,SADP,IAEA,EAAErB,mCAAF,CAFA,IAGA,EAAEC,mCAAF,CAHA,IAIA,qCAAyBF,KAAzB,EAAgCC,GAAG+E,kBAAH,EAAhC,EAAyD9E,GAAG8E,kBAAH,EAAzD,CALF,EAME;AACA,aAAO/E,EAAP,CADA,CACW;AACZ,KARD,MAQO;AACL,aAAO,sBAAcgF,kBAAd,CAAiCjF,KAAjC,EAAwCC,MAAMD,MAAMS,UAAN,CAAiBD,KAA/D,EAAsEN,MAAMF,MAAMS,UAAN,CAAiBa,SAA7F,CAAP;AACD;AACF;;AAEDoB,wBACE1C,KADF,EAEEgD,EAFF,EAGEC,EAHF,EAIEiC,EAJF,EAKEC,EALF,EAMoB;AAClB,QAAIjC,QAAQ,CAACU,CAAD,EAAqBwB,EAArB,EAA4CC,EAA5C,KAAsE;AAChF,UAAID,OAAO9D,SAAP,IAAoB+D,OAAO/D,SAA/B,EAA0C,OAAOA,SAAP;AAC1C;AACA,UAAI8D,OAAO9D,SAAX,EAAsB;AACpB,YAAIsC,EAAE0B,MAAF,mCAAmCH,GAAGxB,GAAH,CAAOC,EAAE0B,MAAT,CAAvC,EAAyD,OAAOD,EAAP,CADrC,CACgD;AACpE,YAAIzB,EAAE2B,UAAF,KAAiBjE,SAAjB,IAA8B0B,GAAGW,GAAH,CAAOC,CAAP,CAAlC,EAA6C;AAC3C;AACAwB,eAAK,4BAAgBxB,EAAE2B,UAAlB,CAAL;AACA,mCAAUH,OAAO9D,SAAjB;AACA8D,aAAGlB,KAAH,GAAWlE,MAAMS,UAAN,CAAiBD,KAA5B;AACD,SALD,MAKO;AACL;AACA4E,eAAKxB,EAAE2B,UAAP;AACA,cAAIH,OAAO9D,SAAX,EAAsB;AACpB8D,iBAAK,4BAAgBC,EAAhB,CAAL;AACA,qCAAUD,OAAO9D,SAAjB;AACA8D,eAAGlB,KAAH,GAAWlE,MAAMS,UAAN,CAAiBD,KAA5B;AACD;AACF;AACF;AACD,UAAI6E,OAAO/D,SAAX,EAAsB;AACpB,YAAIsC,EAAE0B,MAAF,mCAAmCJ,GAAGvB,GAAH,CAAOC,EAAE0B,MAAT,CAAvC,EAAyD,OAAOF,EAAP,CADrC,CACgD;AACpE,YAAInC,GAAGU,GAAH,CAAOC,CAAP,CAAJ,EAAe;AACb;AACAyB,eAAK,4BAAgBD,EAAhB,CAAL;AACA,mCAAUC,OAAO/D,SAAjB;AACA+D,aAAGnB,KAAH,GAAWlE,MAAMS,UAAN,CAAiBD,KAA5B;AACD,SALD,MAKO;AACL;AACA6E,eAAKD,EAAL;AACD;AACD,iCAAUC,OAAO/D,SAAjB;AACD;AACD,UAAIR,SAAS,KAAK0E,gBAAL,CAAsBxF,KAAtB,EAA6BoF,EAA7B,EAAiCC,EAAjC,CAAb;AACA,UAAIvE,UAAUA,OAAOoD,KAAP,iCAAV,IAAmDpD,OAAOoD,KAAP,CAAaC,IAAb,KAAsB,SAA7E,EAAwF;AACtF,YAAIsB,OAAO3E,OAAOoD,KAAlB;AACA,YAAIwB,WAAW9B,EAAE8B,QAAjB;AACA,YAAIA,aAAapE,SAAjB,EAA4B;AAC1B;AACA;AACA;;AAEA;AACA;AACA,cAAIgC,MAAMM,EAAEN,GAAZ;AACA,cAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B,EAAEA,IAAIqC,gBAAJ,MAA0BrC,IAAIsC,gBAAJ,EAA5B,CAA/B,EAAoF;AAClF,gBAAI,OAAOtC,GAAP,KAAe,QAAnB,EAA6B;AAC3BoC,yBAAW,sBAAcG,yBAAd,CAAwC7F,KAAxC,EAA+CyF,IAA/C,EAAqD,CAAC7B,EAAE0B,MAAH,CAArD,EAAiE,CAAC,CAACQ,CAAD,CAAD,KAC1EjG,EAAEkG,gBAAF,CAAmBD,CAAnB,EAAsBjG,EAAEgF,UAAF,CAAavB,GAAb,CAAtB,CADS,CAAX;AAGD,aAJD,MAIO;AACLoC,yBAAW,sBAAcG,yBAAd,CAAwC7F,KAAxC,EAA+CyF,IAA/C,EAAqD,CAAC7B,EAAE0B,MAAH,EAAWhC,GAAX,CAArD,EAAsE,CAAC,CAACwC,CAAD,EAAIE,CAAJ,CAAD,KAAY;AAC3F,uBAAOnG,EAAEkG,gBAAF,CAAmBD,CAAnB,EAAsBE,CAAtB,EAAyB,IAAzB,CAAP;AACD,eAFU,CAAX;AAGD;AACD;AACA;AACA,gBAAInD,YAAY7C,MAAM6C,SAAtB;AACA,qCAAUA,cAAcvB,SAAxB;AACA,gBAAI2E,UAAWrC,EAAE2B,UAAF,IAAgB3B,EAAE2B,UAAF,CAAarB,KAA9B,IAAwClE,MAAMS,UAAN,CAAiBD,KAAvE;AACA,gBAAI,EAAEyF,gCAAF,CAAJ,EAAiC,MAAM,uBAAe,kCAAf,CAAN;AACjC,gBAAI,EAAEA,qCAAF,CAAJ,EAAsC;AACpC,kBAAI3C,QAAQ,QAAR,IAAoBM,EAAE0B,MAAF,8BAAxB,EAAwD;AACtD;AACD,eAFD,MAEO,IAAI,OAAOhC,GAAP,KAAe,QAAnB,EAA6B;AAClCT,0BAAUqD,kBAAV,CAA6BT,KAAKnB,KAAlC,EAAyCmB,KAAKlB,MAA9C,EAAsD,CAACX,EAAE0B,MAAH,EAAWW,OAAX,CAAtD,EAA2E,CAAC,CAACH,CAAD,EAAIK,CAAJ,CAAD,KACzEtG,EAAEuG,oBAAF,CAAuB,GAAvB,EAA4BvG,EAAEkG,gBAAF,CAAmBD,CAAnB,EAAsBjG,EAAEgF,UAAF,CAAavB,GAAb,CAAtB,CAA5B,EAAsE6C,CAAtE,CADF;AAGD,eAJM,MAIA;AACLtD,0BAAUqD,kBAAV,CAA6BT,KAAKnB,KAAlC,EAAyCmB,KAAKlB,MAA9C,EAAsD,CAACX,EAAE0B,MAAH,EAAW1B,EAAEN,GAAb,EAAkB2C,OAAlB,CAAtD,EAAkF,CAAC,CAACH,CAAD,EAAIE,CAAJ,EAAOG,CAAP,CAAD,KAChFtG,EAAEuG,oBAAF,CAAuB,GAAvB,EAA4BvG,EAAEkG,gBAAF,CAAmBD,CAAnB,EAAsBE,CAAtB,EAAyB,IAAzB,CAA5B,EAA4DG,CAA5D,CADF;AAGD;AACF;AACF,WA7BD,MA6BO;AACL,kBAAM,uBAAe,sDAAf,CAAN;AACD;AACDvC,YAAE8B,QAAF,GAAaA,QAAb;AACD;AACD5E,eAAOoD,KAAP,GAAewB,QAAf;AACD;AACD,aAAO5E,MAAP;AACD,KAlFD;AAmFA,WAAO,KAAKiC,SAAL,CAAeC,EAAf,EAAmBC,EAAnB,EAAuBC,KAAvB,CAAP;AACD;;AAEDsC,mBAAiBxF,KAAjB,EAA+BoF,EAA/B,EAAsDC,EAAtD,EAAyF;AACvF,QAAID,OAAO9D,SAAX,EAAsB;AACpB;AACA,UAAI,CAAC,6BAAiBtB,KAAjB,EAAwBqF,EAAxB,CAAL,EAAkC,OAAOA,EAAP,CAFd,CAEyB;AAC7C,UAAIgB,KAAK,4BAAgBhB,EAAhB,CAAT;AACA,+BAAUgB,OAAO/E,SAAjB;AACA+E,SAAGnC,KAAH,GAAW,KAAK1C,WAAL,CAAiBxB,KAAjB,EAAwBqF,GAAGnB,KAA3B,EAAkCmB,GAAGnB,KAArC,CAAX;AACA,aAAOmC,EAAP;AACD,KAPD,MAOO;AACL,UAAI,6BAAiBjB,EAAjB,EAAqBC,EAArB,CAAJ,EAA8B;AAC5B,YAAI,CAAC,6BAAiBrF,KAAjB,EAAwBoF,EAAxB,CAAL,EAAkC,OAAOA,EAAP,CADN,CACiB;AAC7C,YAAIiB,KAAK,4BAAgBjB,EAAhB,CAAT;AACA,iCAAUiB,OAAO/E,SAAjB;AACA+E,WAAGnC,KAAH,GAAW,KAAK1C,WAAL,CAAiBxB,KAAjB,EAAwBoF,GAAGlB,KAA3B,EAAkCmB,GAAGnB,KAArC,CAAX;AACA,eAAOmC,EAAP;AACD;AACD;AACA;AACA;AACA,YAAM,wBAAN;AACD;AACF;;AAED;AACA;AACA;AACAC,kBAAgB1E,EAAhB,EAA6BC,EAA7B,EAAmD;AACjD,QAAI,CAACC,OAAD,GAAYC,SAAZ,EAAuBC,WAAvB,IAAsCJ,EAA1C;AACA,QAAI,CAACM,OAAD,GAAYC,SAAZ,EAAuBC,WAAvB,IAAsCP,EAA1C;;AAEA,QAAI,CAAC,KAAK0E,eAAL,CAAqBzE,OAArB,EAA8BI,OAA9B,CAAL,EAA6C,OAAO,KAAP;AAC7C,QAAI,CAAC,KAAKsE,gBAAL,CAAsBzE,SAAtB,EAAiCI,SAAjC,CAAL,EAAkD,OAAO,KAAP;AAClD,QAAI,CAAC,KAAKsE,wBAAL,CAA8BzE,WAA9B,EAA2CI,WAA3C,CAAL,EAA8D,OAAO,KAAP;AAC9D,WAAO,IAAP;AACD;;AAEDmE,kBAAgBzE,OAAhB,EAA2CI,OAA3C,EAA+E;AAC7E,QAAIJ,oCAA4BI,gCAAhC,EAA0D,OAAO,KAAKwE,eAAL,CAAqB5E,OAArB,EAA8BI,OAA9B,CAAP;AAC1D,WAAO,KAAP;AACD;;AAEDyE,cAAkB3D,EAAlB,EAAiCC,EAAjC,EAAgD2D,CAAhD,EAA6F;AAC3F,SAAK,MAAM,CAAC3F,IAAD,EAAOE,IAAP,CAAX,IAA2B6B,GAAG6D,OAAH,EAA3B,EAAyC;AACvC,UAAI1F,SAASG,SAAb,EAAwB,SADe,CACL;AAClC,UAAID,OAAO4B,GAAGO,GAAH,CAAOvC,IAAP,CAAX;AACA,UAAII,SAASC,SAAb,EAAwB,SAHe,CAGL;AAClC,UAAI,CAACsF,EAAEzF,IAAF,EAAQE,IAAR,CAAL,EAAoB,OAAO,KAAP;AACrB;AACD,SAAK,MAAMD,IAAX,IAAmB6B,GAAG6D,IAAH,EAAnB,EAA8B;AAC5B,UAAI,CAAC9D,GAAGW,GAAH,CAAOvC,IAAP,CAAL,EAAmB,OAAO,KAAP;AACpB;AACD,WAAO,IAAP;AACD;;AAEDoF,mBAAiBxD,EAAjB,EAA+BC,EAA/B,EAAsD;AACpD,QAAI8D,kBAAkB,CAAClD,EAAD,EAA0BC,EAA1B,KAAsD;AAC1E,UACED,OAAOvC,SAAP,IACAwC,OAAOxC,SADP,IAEAuC,GAAGK,KAAH,KAAa5C,SAFb,IAGAwC,GAAGI,KAAH,KAAa5C,SAHb,IAIA,CAAC,KAAKoF,eAAL,CAAqB7C,GAAGK,KAAxB,EAA+BJ,GAAGI,KAAlC,CAJD,IAKAL,GAAGG,SAAH,KAAiBF,GAAGE,SANtB,EAOE;AACA,eAAO,KAAP;AACD;AACD,aAAO,IAAP;AACD,KAZD;AAaA,WAAO,KAAK2C,WAAL,CAAiB3D,EAAjB,EAAqBC,EAArB,EAAyB8D,eAAzB,CAAP;AACD;;AAEDN,2BAAyBzD,EAAzB,EAA+CC,EAA/C,EAA8E;AAC5E,QAAI+D,0BAA0B,CAAC5B,EAAD,EAAwBC,EAAxB,KAAkD;AAC9E,UAAI,CAACpF,EAAD,EAAKC,EAAL,IAAW,CAACkF,MAAMA,GAAGlB,KAAV,EAAiBmB,MAAMA,GAAGnB,KAA1B,CAAf;AACA,UAAIjE,OAAOqB,SAAX,EAAsB,OAAOpB,OAAOoB,SAAd;AACtB,UAAIrB,+BAAuBC,2BAA3B,EAAgD,OAAO,KAAKwG,eAAL,CAAqBzG,EAArB,EAAyBC,EAAzB,CAAP;AAChD,UAAI4E,MAAMC,OAAN,CAAc9E,EAAd,KAAqB6E,MAAMC,OAAN,CAAc7E,EAAd,CAAzB,EAA4C;AAC1C,eAAO,KAAK+G,cAAL,CAAsBhH,EAAtB,EAAiDC,EAAjD,CAAP;AACD;AACD,aAAOA,OAAOoB,SAAd;AACD,KARD;AASA,WAAO,KAAKqF,WAAL,CAAiB3D,EAAjB,EAAqBC,EAArB,EAAyB+D,uBAAzB,CAAP;AACD;;AAEDC,iBACEhH,EADF,EAEEC,EAFF,EAGW;AACT,QAAIC,IAAKF,MAAMA,GAAG,CAAH,CAAP,IAAkBC,MAAMA,GAAG,CAAH,CAAhC;AACA,QAAIC,0BAAJ,EAAwB,OAAO,KAAK+G,qBAAL,CAA4BjH,EAA5B,EAAuCC,EAAvC,CAAP,CAAxB,KACK,OAAO,KAAKiH,2BAAL,CAAkClH,EAAlC,EAA6CC,EAA7C,CAAP;AACN;;AAEDiH,8BACEnH,KADF,EAEEM,EAFF,EAGEC,EAHF,EAIW;AACT,QAAIC,QAAQR,MAAMS,UAAN,CAAiBD,KAA7B;AACA,QAAIE,IAAIC,KAAKC,GAAL,CAAUN,MAAMA,GAAGO,MAAV,IAAqB,CAA9B,EAAkCN,MAAMA,GAAGM,MAAV,IAAqB,CAAtD,CAAR;AACA,SAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAIL,CAApB,EAAuBK,GAAvB,EAA4B;AAC1B,UAAI,EAAEC,MAAMC,IAAR,EAAcC,QAAQC,IAAtB,KAAgCb,MAAMA,GAAGS,CAAH,CAAP,IAAiB,EAAEC,MAAMR,KAAR,EAAeU,QAAQV,KAAvB,EAApD;AACA,UAAI,EAAEQ,MAAMI,IAAR,EAAcF,QAAQG,IAAtB,KAAgCd,MAAMA,GAAGQ,CAAH,CAAP,IAAiB,EAAEC,MAAMR,KAAR,EAAeU,QAAQV,KAAvB,EAApD;AACA,UAAIS,SAASK,SAAb,EAAwB;AACtB,YAAIF,SAASE,SAAb,EAAwB,OAAO,KAAP;AACzB,OAFD,MAEO;AACL,YAAIL,iCAAyBG,6BAAzB,IAAkDH,KAAKmG,MAAL,CAAYhG,IAAZ,CAAtD,EAAyE;AACvE,cAAID,iCAAyBE,6BAAzB,IAAkD,KAAKqF,eAAL,CAAqBvF,IAArB,EAA2BE,IAA3B,CAAtD,EAAwF;AACzF;AACD,eAAO,KAAP;AACD;AACF;AACD,WAAO,IAAP;AACD;;AAED6F,wBAAsBlH,KAAtB,EAAoCM,EAApC,EAA6DC,EAA7D,EAA+F;AAC7F,QAAIG,IAAIC,KAAKC,GAAL,CAAUN,MAAMA,GAAGO,MAAV,IAAqB,CAA9B,EAAkCN,MAAMA,GAAGM,MAAV,IAAqB,CAAtD,CAAR;AACA,SAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAIL,CAApB,EAAuBK,GAAvB,EAA4B;AAC1B,UAAI,CAACI,IAAD,EAAOE,IAAP,IAAe,CAACf,MAAMA,GAAGS,CAAH,CAAP,EAAcR,MAAMA,GAAGQ,CAAH,CAApB,CAAnB;AACA,UAAII,iCAAyBE,6BAAzB,IAAkD,CAAC,KAAKqF,eAAL,CAAqBvF,IAArB,EAA2BE,IAA3B,CAAvD,EAAyF,OAAO,KAAP;AAC1F;AACD,WAAO,IAAP;AACD;;AAEDqF,kBAAgBvF,IAAhB,EAA6BE,IAA7B,EAA0C;AACxC,QAAIF,qCAAJ,EAAmC;AACjC,UACE,CAAC,cAAMkG,oBAAN,CAA2BhG,KAAKiG,OAAL,EAA3B,EAA2CnG,KAAKmG,OAAL,EAA3C,CAAD,IACA,CAAC,cAAMD,oBAAN,CAA2BlG,KAAKmG,OAAL,EAA3B,EAA2CjG,KAAKiG,OAAL,EAA3C,CAFH,EAIE,OAAO,KAAP;AACF,aAAOnG,KAAKoD,MAAL,CAAYgD,aAAZ,CAA0BlG,IAA1B,CAAP;AACD;AACD,WAAOF,KAAKiG,MAAL,CAAY/F,IAAZ,CAAP;AACD;AA7X8B;QAApBvB,mB,GAAAA,mB,EAjCb","file":"widen.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Binding } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport type {\n  Bindings,\n  BindingEntry,\n  Effects,\n  EvaluationResult,\n  PropertyBindings,\n  CreatedObjects,\n  Realm,\n} from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\n\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { cloneDescriptor, equalDescriptors, IsDataDescriptor, StrictEqualityComparison } from \"../methods/index.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport { AbstractValue, ArrayValue, EmptyValue, ObjectValue, Value } from \"../values/index.js\";\n\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\nexport class WidenImplementation {\n  _widenArrays(\n    realm: Realm,\n    v1: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    let e = (v1 && v1[0]) || (v2 && v2[0]);\n    if (e instanceof Value) return this._widenArraysOfValues(realm, (v1: any), (v2: any));\n    else return this._widenArrayOfsMapEntries(realm, (v1: any), (v2: any));\n  }\n\n  _widenArrayOfsMapEntries(\n    realm: Realm,\n    a1: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n    a2: void | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Array<{ $Key: void | Value, $Value: void | Value }> {\n    let empty = realm.intrinsics.empty;\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    let result: Array<{ $Key: void | Value, $Value: void | Value }> = [];\n    for (let i = 0; i < n; i++) {\n      let { $Key: key1, $Value: val1 } = (a1 && a1[i]) || { $Key: empty, $Value: empty };\n      let { $Key: key2, $Value: val2 } = (a2 && a2[i]) || { $Key: empty, $Value: empty };\n      if (key1 === undefined && key2 === undefined) {\n        result[i] = { $Key: undefined, $Value: undefined };\n      } else {\n        let key3 = this.widenValues(realm, key1, key2);\n        invariant(key3 instanceof Value);\n        let val3 = this.widenValues(realm, val1, val2);\n        invariant(val3 === undefined || val3 instanceof Value);\n        result[i] = { $Key: key3, $Value: val3 };\n      }\n    }\n    return result;\n  }\n\n  _widenArraysOfValues(realm: Realm, a1: void | Array<Value>, a2: void | Array<Value>): Array<Value> {\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    let result = [];\n    for (let i = 0; i < n; i++) {\n      let wv = this.widenValues(realm, (a1 && a1[i]) || undefined, (a2 && a2[i]) || undefined);\n      invariant(wv === undefined || wv instanceof Value);\n      result[i] = wv;\n    }\n    return result;\n  }\n\n  // Returns a new effects summary that includes both e1 and e2.\n  widenEffects(realm: Realm, e1: Effects, e2: Effects): Effects {\n    let [result1, , bindings1, properties1, createdObj1] = e1;\n    let [result2, , bindings2, properties2, createdObj2] = e2;\n\n    let result = this.widenResults(realm, result1, result2);\n    let bindings = this.widenBindings(realm, bindings1, bindings2);\n    let properties = this.widenPropertyBindings(realm, properties1, properties2, createdObj1, createdObj2);\n    let createdObjects = new Set(); // Top, since the empty set knows nothing. There is no other choice for widen.\n    let generator = new Generator(realm, \"widen\"); // code subject to widening will be generated somewhere else\n    return [result, generator, bindings, properties, createdObjects];\n  }\n\n  widenResults(realm: Realm, result1: EvaluationResult, result2: EvaluationResult): PossiblyNormalCompletion | Value {\n    invariant(!(result1 instanceof Reference || result2 instanceof Reference), \"loop bodies should not result in refs\");\n    invariant(\n      !(result1 instanceof AbruptCompletion || result2 instanceof AbruptCompletion),\n      \"if a loop iteration ends abruptly, there is no need for fixed point computation\"\n    );\n    if (result1 instanceof Value && result2 instanceof Value) {\n      let val = this.widenValues(realm, result1, result2);\n      invariant(val instanceof Value);\n      return val;\n    }\n    if (result1 instanceof PossiblyNormalCompletion || result2 instanceof PossiblyNormalCompletion) {\n      //todo: #1174 figure out how to deal with loops that have embedded conditional exits\n      // widen join pathConditions\n      // widen normal result and Effects\n      // use abrupt part of result2, depend stability to make this safe. See below.\n      throw new FatalError();\n    }\n    invariant(false);\n  }\n\n  widenMaps<K, V>(m1: Map<K, V>, m2: Map<K, V>, widen: (K, void | V, void | V) => V): Map<K, V> {\n    let m3: Map<K, V> = new Map();\n    m1.forEach((val1, key, map1) => {\n      let val2 = m2.get(key);\n      let val3 = widen(key, val1, val2);\n      m3.set(key, val3);\n    });\n    m2.forEach((val2, key, map2) => {\n      if (!m1.has(key)) {\n        m3.set(key, widen(key, undefined, val2));\n      }\n    });\n    return m3;\n  }\n\n  widenBindings(realm: Realm, m1: Bindings, m2: Bindings): Bindings {\n    let widen = (b: Binding, b1: void | BindingEntry, b2: void | BindingEntry) => {\n      let l1 = b1 === undefined ? b.hasLeaked : b1.hasLeaked;\n      let l2 = b2 === undefined ? b.hasLeaked : b2.hasLeaked;\n      let hasLeaked = l1 || l2; // If either has leaked, then this binding has leaked.\n      let v1 = b1 === undefined || b1.value === undefined ? b.value : b1.value;\n      invariant(b2 !== undefined); // Local variables are not going to get deleted as a result of widening\n      let v2 = b2.value;\n      invariant(v2 !== undefined);\n      let result = this.widenValues(realm, v1, v2);\n      if (result instanceof AbstractValue && result.kind === \"widened\") {\n        let phiNode = b.phiNode;\n        if (phiNode === undefined) {\n          // Create a temporal location for binding\n          let generator = realm.generator;\n          invariant(generator !== undefined);\n          phiNode = generator.derive(result.types, result.values, [b.value || realm.intrinsics.undefined], ([n]) => n, {\n            skipInvariant: true,\n          });\n          b.phiNode = phiNode;\n        }\n        // Let the widened value be a reference to the phiNode of the binding\n        invariant(phiNode.intrinsicName !== undefined);\n        let phiName = phiNode.intrinsicName;\n        result.intrinsicName = phiName;\n        result._buildNode = args => t.identifier(phiName);\n      }\n      invariant(result instanceof Value);\n      return { hasLeaked, value: result };\n    };\n    return this.widenMaps(m1, m2, widen);\n  }\n\n  // Returns an abstract value that includes both v1 and v2 as potential values.\n  widenValues(\n    realm: Realm,\n    v1: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    if (Array.isArray(v1) || Array.isArray(v2)) {\n      invariant(v1 === undefined || Array.isArray(v1));\n      invariant(v2 === undefined || Array.isArray(v2));\n      return this._widenArrays(realm, ((v1: any): void | Array<Value>), ((v2: any): void | Array<Value>));\n    }\n    invariant(v1 === undefined || v1 instanceof Value);\n    invariant(v2 === undefined || v2 instanceof Value);\n    if (\n      v1 !== undefined &&\n      v2 !== undefined &&\n      !(v1 instanceof AbstractValue) &&\n      !(v2 instanceof AbstractValue) &&\n      StrictEqualityComparison(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())\n    ) {\n      return v1; // no need to widen a loop invariant value\n    } else {\n      return AbstractValue.createFromWidening(realm, v1 || realm.intrinsics.empty, v2 || realm.intrinsics.undefined);\n    }\n  }\n\n  widenPropertyBindings(\n    realm: Realm,\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): PropertyBindings {\n    let widen = (b: PropertyBinding, d1: void | Descriptor, d2: void | Descriptor) => {\n      if (d1 === undefined && d2 === undefined) return undefined;\n      // If the PropertyBinding object has been freshly allocated do not widen (that happens in AbstractObjectValue)\n      if (d1 === undefined) {\n        if (b.object instanceof ObjectValue && c2.has(b.object)) return d2; // no widen\n        if (b.descriptor !== undefined && m1.has(b)) {\n          // property was present in (n-1)th iteration and deleted in nth iteration\n          d1 = cloneDescriptor(b.descriptor);\n          invariant(d1 !== undefined);\n          d1.value = realm.intrinsics.empty;\n        } else {\n          // no write to property in nth iteration, use the value from the (n-1)th iteration\n          d1 = b.descriptor;\n          if (d1 === undefined) {\n            d1 = cloneDescriptor(d2);\n            invariant(d1 !== undefined);\n            d1.value = realm.intrinsics.empty;\n          }\n        }\n      }\n      if (d2 === undefined) {\n        if (b.object instanceof ObjectValue && c1.has(b.object)) return d1; // no widen\n        if (m2.has(b)) {\n          // property was present in nth iteration and deleted in (n+1)th iteration\n          d2 = cloneDescriptor(d1);\n          invariant(d2 !== undefined);\n          d2.value = realm.intrinsics.empty;\n        } else {\n          // no write to property in (n+1)th iteration, use the value from the nth iteration\n          d2 = d1;\n        }\n        invariant(d2 !== undefined);\n      }\n      let result = this.widenDescriptors(realm, d1, d2);\n      if (result && result.value instanceof AbstractValue && result.value.kind === \"widened\") {\n        let rval = result.value;\n        let pathNode = b.pathNode;\n        if (pathNode === undefined) {\n          //Since properties already have mutable storage locations associated with them, we do not\n          //need phi nodes. What we need is an abstract value with a build node that results in a memberExpression\n          //that resolves to the storage location of the property.\n\n          // For now, we only handle loop invariant properties\n          //i.e. properties where the member expresssion does not involve any values written to inside the loop.\n          let key = b.key;\n          if (typeof key === \"string\" || !(key.mightNotBeString() && key.mightNotBeNumber())) {\n            if (typeof key === \"string\") {\n              pathNode = AbstractValue.createFromWidenedProperty(realm, rval, [b.object], ([o]) =>\n                t.memberExpression(o, t.identifier(key))\n              );\n            } else {\n              pathNode = AbstractValue.createFromWidenedProperty(realm, rval, [b.object, key], ([o, p]) => {\n                return t.memberExpression(o, p, true);\n              });\n            }\n            // The value of the property at the start of the loop needs to be written to the property\n            // before the loop commences, otherwise the memberExpression will result in an undefined value.\n            let generator = realm.generator;\n            invariant(generator !== undefined);\n            let initVal = (b.descriptor && b.descriptor.value) || realm.intrinsics.empty;\n            if (!(initVal instanceof Value)) throw new FatalError(\"todo: handle internal properties\");\n            if (!(initVal instanceof EmptyValue)) {\n              if (key === \"length\" && b.object instanceof ArrayValue) {\n                // do nothing, the array length will already be initialized\n              } else if (typeof key === \"string\") {\n                generator.emitVoidExpression(rval.types, rval.values, [b.object, initVal], ([o, v]) =>\n                  t.assignmentExpression(\"=\", t.memberExpression(o, t.identifier(key)), v)\n                );\n              } else {\n                generator.emitVoidExpression(rval.types, rval.values, [b.object, b.key, initVal], ([o, p, v]) =>\n                  t.assignmentExpression(\"=\", t.memberExpression(o, p, true), v)\n                );\n              }\n            }\n          } else {\n            throw new FatalError(\"todo: handle the case where key is an abstract value\");\n          }\n          b.pathNode = pathNode;\n        }\n        result.value = pathNode;\n      }\n      return result;\n    };\n    return this.widenMaps(m1, m2, widen);\n  }\n\n  widenDescriptors(realm: Realm, d1: void | Descriptor, d2: Descriptor): void | Descriptor {\n    if (d1 === undefined) {\n      // d2 is a property written to only in the (n+1)th iteration\n      if (!IsDataDescriptor(realm, d2)) return d2; // accessor properties need not be widened.\n      let dc = cloneDescriptor(d2);\n      invariant(dc !== undefined);\n      dc.value = this.widenValues(realm, d2.value, d2.value);\n      return dc;\n    } else {\n      if (equalDescriptors(d1, d2)) {\n        if (!IsDataDescriptor(realm, d1)) return d1; // identical accessor properties need not be widened.\n        let dc = cloneDescriptor(d1);\n        invariant(dc !== undefined);\n        dc.value = this.widenValues(realm, d1.value, d2.value);\n        return dc;\n      }\n      //todo: #1174 if we get here, the loop body contains a call to create a property and different iterations\n      // create them differently. That seems beyond what a fixpoint computation can reasonably handle without\n      // losing precision. Report an error here.\n      throw new FatalError();\n    }\n  }\n\n  // If e2 is the result of a loop iteration starting with effects e1 and it has a subset of elements of e1,\n  // then we have reached a fixed point and no further calls to widen are needed. e1/e2 represent a general\n  // summary of the loop, regardless of how many iterations will be performed at runtime.\n  containsEffects(e1: Effects, e2: Effects): boolean {\n    let [result1, , bindings1, properties1] = e1;\n    let [result2, , bindings2, properties2] = e2;\n\n    if (!this.containsResults(result1, result2)) return false;\n    if (!this.containsBindings(bindings1, bindings2)) return false;\n    if (!this.containsPropertyBindings(properties1, properties2)) return false;\n    return true;\n  }\n\n  containsResults(result1: EvaluationResult, result2: EvaluationResult): boolean {\n    if (result1 instanceof Value && result2 instanceof Value) return this._containsValues(result1, result2);\n    return false;\n  }\n\n  containsMap<K, V>(m1: Map<K, V>, m2: Map<K, V>, f: (void | V, void | V) => boolean): boolean {\n    for (const [key1, val1] of m1.entries()) {\n      if (val1 === undefined) continue; // deleted\n      let val2 = m2.get(key1);\n      if (val2 === undefined) continue; // A key that disappears has been widened away into the unknown key\n      if (!f(val1, val2)) return false;\n    }\n    for (const key2 of m2.keys()) {\n      if (!m1.has(key2)) return false;\n    }\n    return true;\n  }\n\n  containsBindings(m1: Bindings, m2: Bindings): boolean {\n    let containsBinding = (b1: void | BindingEntry, b2: void | BindingEntry) => {\n      if (\n        b1 === undefined ||\n        b2 === undefined ||\n        b1.value === undefined ||\n        b2.value === undefined ||\n        !this._containsValues(b1.value, b2.value) ||\n        b1.hasLeaked !== b2.hasLeaked\n      ) {\n        return false;\n      }\n      return true;\n    };\n    return this.containsMap(m1, m2, containsBinding);\n  }\n\n  containsPropertyBindings(m1: PropertyBindings, m2: PropertyBindings): boolean {\n    let containsPropertyBinding = (d1: void | Descriptor, d2: void | Descriptor) => {\n      let [v1, v2] = [d1 && d1.value, d2 && d2.value];\n      if (v1 === undefined) return v2 === undefined;\n      if (v1 instanceof Value && v2 instanceof Value) return this._containsValues(v1, v2);\n      if (Array.isArray(v1) && Array.isArray(v2)) {\n        return this._containsArray(((v1: any): Array<Value>), ((v2: any): Array<Value>));\n      }\n      return v2 === undefined;\n    };\n    return this.containsMap(m1, m2, containsPropertyBinding);\n  }\n\n  _containsArray(\n    v1: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): boolean {\n    let e = (v1 && v1[0]) || (v2 && v2[0]);\n    if (e instanceof Value) return this.containsArraysOfValue((v1: any), (v2: any));\n    else return this._containsArrayOfsMapEntries((v1: any), (v2: any));\n  }\n\n  _containsArrayOfsMapEntries(\n    realm: Realm,\n    a1: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n    a2: void | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): boolean {\n    let empty = realm.intrinsics.empty;\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    for (let i = 0; i < n; i++) {\n      let { $Key: key1, $Value: val1 } = (a1 && a1[i]) || { $Key: empty, $Value: empty };\n      let { $Key: key2, $Value: val2 } = (a2 && a2[i]) || { $Key: empty, $Value: empty };\n      if (key1 === undefined) {\n        if (key2 !== undefined) return false;\n      } else {\n        if (key1 instanceof Value && key2 instanceof Value && key1.equals(key2)) {\n          if (val1 instanceof Value && val2 instanceof Value && this._containsValues(val1, val2)) continue;\n        }\n        return false;\n      }\n    }\n    return true;\n  }\n\n  containsArraysOfValue(realm: Realm, a1: void | Array<Value>, a2: void | Array<Value>): boolean {\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    for (let i = 0; i < n; i++) {\n      let [val1, val2] = [a1 && a1[i], a2 && a2[i]];\n      if (val1 instanceof Value && val2 instanceof Value && !this._containsValues(val1, val2)) return false;\n    }\n    return true;\n  }\n\n  _containsValues(val1: Value, val2: Value) {\n    if (val1 instanceof AbstractValue) {\n      if (\n        !Value.isTypeCompatibleWith(val2.getType(), val1.getType()) &&\n        !Value.isTypeCompatibleWith(val1.getType(), val2.getType())\n      )\n        return false;\n      return val1.values.containsValue(val2);\n    }\n    return val1.equals(val2);\n  }\n}\n"]}