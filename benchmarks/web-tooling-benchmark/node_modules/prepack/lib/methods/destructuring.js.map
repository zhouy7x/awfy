{"version":3,"sources":["../../src/methods/destructuring.js"],"names":["DestructuringAssignmentEvaluation","IteratorDestructuringAssignmentEvaluation","KeyedDestructuringAssignmentEvaluation","realm","pattern","value","strictCode","env","type","property","properties","name","iterator","iteratorRecord","$Iterator","$Done","result","elements","error","completion","intrinsics","undefined","restEl","length","lastEl","slice","element","next","e","DestructuringAssignmentTarget","Initializer","right","left","lref","evaluate","v","defaultValue","GetValue","nestedAssignmentPattern","hasNameProperty","SetFunctionName","GetReferencedName","PutValue","argument","A","ArrayCreate","n","nextValue","status","CreateDataProperty","toString","node","propertyName","rhsValue","assignmentPattern"],"mappings":"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","file":"destructuring.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport invariant from \"../invariant.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Reference } from \"../environment.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { Value, ObjectValue, UndefinedValue } from \"../values/index.js\";\nimport { NormalCompletion, AbruptCompletion } from \"../completions.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport {\n  RequireObjectCoercible,\n  GetIterator,\n  IteratorClose,\n  IteratorStep,\n  IteratorValue,\n  IsAnonymousFunctionDefinition,\n  IsIdentifierRef,\n  HasOwnProperty,\n  GetV,\n} from \"./index.js\";\nimport { Create, Environment, Functions, Properties } from \"../singletons.js\";\nimport type { BabelNodeLVal, BabelNodeArrayPattern, BabelNodeObjectPattern } from \"babel-types\";\n\n// ECMA262 12.15.5.2\nexport function DestructuringAssignmentEvaluation(\n  realm: Realm,\n  pattern: BabelNodeArrayPattern | BabelNodeObjectPattern,\n  value: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment\n) {\n  if (pattern.type === \"ObjectPattern\") {\n    // 1. Perform ? RequireObjectCoercible(value).\n    RequireObjectCoercible(realm, value);\n\n    // 2. Return the result of performing DestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.\n\n    for (let property of pattern.properties) {\n      // 1. Let name be the result of evaluating PropertyName.\n      let name = EvalPropertyName(property, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(name).\n\n      // 3. Return the result of performing KeyedDestructuringAssignmentEvaluation of AssignmentElement with value and name as the arguments.\n      KeyedDestructuringAssignmentEvaluation(realm, property.value, value, name, strictCode, env);\n    }\n  } else if (pattern.type === \"ArrayPattern\") {\n    // 1. Let iterator be ? GetIterator(value).\n    let iterator = GetIterator(realm, value);\n\n    // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.\n    let iteratorRecord = {\n      $Iterator: iterator,\n      $Done: false,\n    };\n\n    // 3. Let result be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElementList using iteratorRecord as the argument.\n    let result;\n    try {\n      result = IteratorDestructuringAssignmentEvaluation(realm, pattern.elements, iteratorRecord, strictCode, env);\n    } catch (error) {\n      // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n      if (iteratorRecord.$Done === false && error instanceof AbruptCompletion) {\n        throw IteratorClose(realm, iterator, error);\n      }\n      throw error;\n    }\n\n    // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n    if (iteratorRecord.$Done === false) {\n      let completion = IteratorClose(realm, iterator, new NormalCompletion(realm.intrinsics.undefined));\n      if (completion instanceof AbruptCompletion) {\n        throw completion;\n      }\n    }\n\n    // 5. Return result.\n    return result;\n  }\n}\n\n// ECMA262 12.15.5.3\nexport function IteratorDestructuringAssignmentEvaluation(\n  realm: Realm,\n  elements: $ReadOnlyArray<BabelNodeLVal | null>,\n  iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n  strictCode: boolean,\n  env: LexicalEnvironment\n) {\n  // Check if the last element is a rest element. If so then we want to save the\n  // element and handle it separately after we iterate through the other\n  // formals. This also enforces that a rest element may only ever be in the\n  // last position.\n  let restEl;\n  if (elements.length > 0) {\n    let lastEl = elements[elements.length - 1];\n    if (lastEl !== null && lastEl.type === \"RestElement\") {\n      restEl = lastEl;\n      elements = elements.slice(0, -1);\n    }\n  }\n\n  for (let element of elements) {\n    if (element === null) {\n      // Elision handling\n\n      // 1. If iteratorRecord.[[Done]] is false, then\n      if (iteratorRecord.$Done === false) {\n        // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n        let next;\n        try {\n          next = IteratorStep(realm, iteratorRecord.$Iterator);\n        } catch (e) {\n          // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // c. ReturnIfAbrupt(next).\n          throw e;\n        }\n        // d. If next is false, set iteratorRecord.[[Done]] to true.\n        if (next === false) {\n          iteratorRecord.$Done = true;\n        }\n      }\n      // 2. Return NormalCompletion(empty).\n      continue;\n    }\n\n    // AssignmentElement : DestructuringAssignmentTarget Initializer\n\n    let DestructuringAssignmentTarget;\n    let Initializer;\n\n    if (element.type === \"AssignmentPattern\") {\n      Initializer = element.right;\n      DestructuringAssignmentTarget = element.left;\n    } else {\n      DestructuringAssignmentTarget = element;\n    }\n\n    let lref;\n\n    // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n    //\n    // The spec assumes we haven't yet distinguished between literals and\n    // patterns, but our parser does that work for us. That means we check for\n    // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n    if (\n      DestructuringAssignmentTarget.type !== \"ObjectPattern\" &&\n      DestructuringAssignmentTarget.type !== \"ArrayPattern\"\n    ) {\n      // a. Let lref be the result of evaluating DestructuringAssignmentTarget.\n      lref = env.evaluate(DestructuringAssignmentTarget, strictCode);\n\n      // b. ReturnIfAbrupt(lref).\n    }\n\n    let value;\n\n    // 2. If iteratorRecord.[[Done]] is false, then\n    if (iteratorRecord.$Done === false) {\n      // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n      let next;\n      try {\n        next = IteratorStep(realm, iteratorRecord.$Iterator);\n      } catch (e) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        if (e instanceof AbruptCompletion) {\n          iteratorRecord.$Done = true;\n        }\n        // c. ReturnIfAbrupt(next).\n        throw e;\n      }\n\n      // d. If next is false, set iteratorRecord.[[Done]] to true.\n      if (next === false) {\n        iteratorRecord.$Done = true;\n        // Normally this assignment would be done in step 3, but we do it\n        // here so that Flow knows `value` will always be initialized by step 4.\n        value = realm.intrinsics.undefined;\n      } else {\n        // e. Else,\n        // i. Let value be IteratorValue(next).\n        try {\n          value = IteratorValue(realm, next);\n        } catch (e) {\n          // ii. If value is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // iii. ReturnIfAbrupt(v).\n          throw e;\n        }\n      }\n    } else {\n      // 3. If iteratorRecord.[[Done]] is true, let value be undefined.\n      value = realm.intrinsics.undefined;\n    }\n\n    let v;\n\n    // 4. If Initializer is present and value is undefined, then\n    if (Initializer && value instanceof UndefinedValue) {\n      // a. Let defaultValue be the result of evaluating Initializer.\n      let defaultValue = env.evaluate(Initializer, strictCode);\n\n      // b. Let v be ? GetValue(defaultValue).\n      v = Environment.GetValue(realm, defaultValue);\n    } else {\n      // 5. Else, let v be value.\n      v = value;\n    }\n\n    // 6. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then\n    //\n    // The spec assumes we haven't yet distinguished between literals and\n    // patterns, but our parser does that work for us. That means we check for\n    // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n    if (\n      DestructuringAssignmentTarget.type === \"ObjectPattern\" ||\n      DestructuringAssignmentTarget.type === \"ArrayPattern\"\n    ) {\n      // a. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.\n      let nestedAssignmentPattern = DestructuringAssignmentTarget;\n\n      // b. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with v as the argument.\n      DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, v, strictCode, env);\n      continue;\n    }\n\n    // We know `lref` exists because of how the algorithm is setup, but tell\n    // Flow that `lref` exists with an `invariant()`.\n    invariant(lref);\n\n    // 7. If Initializer is present and value is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then\n    if (\n      Initializer &&\n      value instanceof UndefinedValue &&\n      IsAnonymousFunctionDefinition(realm, Initializer) &&\n      IsIdentifierRef(realm, DestructuringAssignmentTarget) &&\n      v instanceof ObjectValue\n    ) {\n      // a. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n      let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n\n      // b. If hasNameProperty is false, perform SetFunctionName(v, GetReferencedName(lref)).\n      if (hasNameProperty === false) {\n        // All of the nodes that may be evaluated to produce lref create\n        // references. Assert this with an invariant as GetReferencedName may\n        // not be called with a value.\n        invariant(lref instanceof Reference);\n\n        Functions.SetFunctionName(realm, v, Environment.GetReferencedName(realm, lref));\n      }\n    }\n\n    // 8. Return ? PutValue(lref, v).\n    Properties.PutValue(realm, lref, v);\n    continue;\n  }\n\n  // Handle the rest element if we have one.\n  if (restEl) {\n    // AssignmentRestElement : ...DestructuringAssignmentTarget\n    let DestructuringAssignmentTarget = restEl.argument;\n\n    let lref;\n\n    // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n    //\n    // The spec assumes we haven't yet distinguished between literals and\n    // patterns, but our parser does that work for us. That means we check for\n    // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n    if (\n      DestructuringAssignmentTarget.type !== \"ObjectPattern\" &&\n      DestructuringAssignmentTarget.type !== \"ArrayPattern\"\n    ) {\n      // a. Let lref be the result of evaluating DestructuringAssignmentTarget.\n      lref = env.evaluate(DestructuringAssignmentTarget, strictCode);\n\n      // b. ReturnIfAbrupt(lref).\n    }\n\n    // 2. Let A be ArrayCreate(0).\n    let A = Create.ArrayCreate(realm, 0);\n\n    // 3. Let n be 0.\n    let n = 0;\n\n    // 4. Repeat while iteratorRecord.[[Done]] is false,\n    while (iteratorRecord.$Done === false) {\n      // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n      let next;\n      try {\n        next = IteratorStep(realm, iteratorRecord.$Iterator);\n      } catch (e) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        if (e instanceof AbruptCompletion) {\n          iteratorRecord.$Done = true;\n        }\n        // c. ReturnIfAbrupt(next).\n        throw e;\n      }\n\n      // d. If next is false, set iteratorRecord.[[Done]] to true.\n      if (next === false) {\n        iteratorRecord.$Done = true;\n      } else {\n        // e. Else,\n        // i. Let nextValue be IteratorValue(next).\n        let nextValue;\n        try {\n          nextValue = IteratorValue(realm, next);\n        } catch (e) {\n          // ii. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // iii. ReturnIfAbrupt(nextValue).\n          throw e;\n        }\n\n        // iv. Let status be CreateDataProperty(A, ! ToString(n), nextValue).\n        let status = Create.CreateDataProperty(realm, A, n.toString(), nextValue);\n\n        // v. Assert: status is true.\n        invariant(status, \"expected to create data property\");\n\n        // vi. Increment n by 1.\n        n += 1;\n      }\n    }\n\n    // 5. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n    if (\n      DestructuringAssignmentTarget.type !== \"ObjectPattern\" &&\n      DestructuringAssignmentTarget.type !== \"ArrayPattern\"\n    ) {\n      // `lref` will always be defined at this point. Let Flow know with an\n      // invariant.\n      invariant(lref);\n\n      // a. Return ? PutValue(lref, A).\n      Properties.PutValue(realm, lref, A);\n    } else {\n      // 6. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.\n      let nestedAssignmentPattern = DestructuringAssignmentTarget;\n\n      // 7. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with A as the argument.\n      DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, A, strictCode, env);\n    }\n  }\n}\n\n// ECMA262 12.15.5.4\nexport function KeyedDestructuringAssignmentEvaluation(\n  realm: Realm,\n  node: BabelNodeLVal,\n  value: Value,\n  propertyName: PropertyKeyValue,\n  strictCode: boolean,\n  env: LexicalEnvironment\n) {\n  let DestructuringAssignmentTarget;\n  let Initializer;\n\n  if (node.type === \"AssignmentPattern\") {\n    Initializer = node.right;\n    DestructuringAssignmentTarget = node.left;\n  } else {\n    DestructuringAssignmentTarget = node;\n  }\n\n  let lref;\n\n  // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n  //\n  // The spec assumes we haven't yet distinguished between literals and\n  // patterns, but our parser does that work for us. That means we check for\n  // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n  if (DestructuringAssignmentTarget.type !== \"ObjectPattern\" && DestructuringAssignmentTarget.type !== \"ArrayPattern\") {\n    // a. Let lref be the result of evaluating DestructuringAssignmentTarget.\n    lref = env.evaluate(DestructuringAssignmentTarget, strictCode);\n\n    // b. ReturnIfAbrupt(lref).\n  }\n\n  let rhsValue;\n\n  // 2. Let v be ? GetV(value, propertyName).\n  let v = GetV(realm, value, propertyName);\n\n  // 3. If Initializer is present and v is undefined, then\n  if (Initializer && v instanceof UndefinedValue) {\n    // a. Let defaultValue be the result of evaluating Initializer.\n    let defaultValue = env.evaluate(Initializer, strictCode);\n\n    // b. Let rhsValue be ? GetValue(defaultValue).\n    rhsValue = Environment.GetValue(realm, defaultValue);\n  } else {\n    // 4. Else, let rhsValue be v.\n    rhsValue = v;\n  }\n\n  // 5. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then\n  //\n  // The spec assumes we haven't yet distinguished between literals and\n  // patterns, but our parser does that work for us. That means we check for\n  // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n  if (DestructuringAssignmentTarget.type === \"ObjectPattern\" || DestructuringAssignmentTarget.type === \"ArrayPattern\") {\n    // a. Let assignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.\n    let assignmentPattern = DestructuringAssignmentTarget;\n\n    // b. Return the result of performing DestructuringAssignmentEvaluation of assignmentPattern with rhsValue as the argument.\n    return DestructuringAssignmentEvaluation(realm, assignmentPattern, rhsValue, strictCode, env);\n  }\n\n  // `lref` will always be defined at this point. Let Flow know with an\n  // invariant.\n  invariant(lref);\n\n  // 6. If Initializer is present and v is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then\n  if (\n    Initializer &&\n    v instanceof UndefinedValue &&\n    IsAnonymousFunctionDefinition(realm, Initializer) &&\n    IsIdentifierRef(realm, DestructuringAssignmentTarget) &&\n    rhsValue instanceof ObjectValue\n  ) {\n    // a. Let hasNameProperty be ? HasOwnProperty(rhsValue, \"name\").\n    let hasNameProperty = HasOwnProperty(realm, rhsValue, \"name\");\n\n    // b. If hasNameProperty is false, perform SetFunctionName(rhsValue, GetReferencedName(lref)).\n    if (hasNameProperty === false) {\n      // All of the nodes that may be evaluated to produce lref create\n      // references. Assert this with an invariant as GetReferencedName may\n      // not be called with a value.\n      invariant(lref instanceof Reference);\n\n      Functions.SetFunctionName(realm, rhsValue, Environment.GetReferencedName(realm, lref));\n    }\n  }\n\n  // 7. Return ? PutValue(lref, rhsValue).\n  return Properties.PutValue(realm, lref, rhsValue);\n}\n"]}