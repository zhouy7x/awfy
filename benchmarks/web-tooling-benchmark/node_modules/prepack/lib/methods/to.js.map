{"version":3,"sources":["../../src/methods/to.js"],"names":["modulo","x","y","ToImplementation","constructor","ElementConv","Int8","ToInt8","bind","Int16","ToInt16","Int32","ToInt32","Uint8","ToUint8","Uint16","ToUint16","Uint32","ToUint32","Uint8Clamped","ToUint8Clamp","realm","argument","number","ToNumber","isNaN","isFinite","int","Math","floor","abs","int32bit","pow","int16bit","int8bit","f","thisBooleanValue","value","$BooleanData","booleanData","throwIfNotConcreteBoolean","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","thisNumberValue","$NumberData","numberData","throwIfNotConcreteNumber","thisStringValue","$StringData","stringData","throwIfNotConcreteString","ToPropertyDescriptor","Obj","desc","hasEnumerable","enu","ToBooleanPartial","enumerable","hasConfigurable","conf","configurable","hasValue","hasWritable","writable","hasGet","getter","mightBeUndefined","get","hasSet","setter","set","ToObject","arg","obj","BooleanPrototype","NumberPrototype","StringCreate","StringPrototype","SymbolPrototype","$SymbolData","_WrapAbstractInObject","types","getType","isInPureScope","createFromType","args","throwIfNotConcreteObject","ToObjectPartial","ToLength","len","ToInteger","Infinity","min","ToIndex","index","integerIndex","RangeError","ToIndexPartial","val","num","ToNumberOrAbstract","reportIntrospectionError","NaN","prim","ToPrimitiveOrAbstract","Number","IsToNumberPure","IsToPrimitivePure","type","ToPrimitive","input","hint","throwIfNotConcretePrimitive","exoticToPrim","SymbolToPrimitive","result","OrdinaryToPrimitiveOrAbstract","GetToPrimitivePureResultType","mightBeObject","undefined","OrdinaryToPrimitive","methodNames","name","method","resultType","error","currentLocation","handleError","isTypeCompatibleWith","ToString","primValue","ToStringPartial","ToStringValue","str","ToBoolean","length","mightNotBeObject","ToPropertyKey","key","ToPropertyKeyPartial","mightNotBeString","mightNotBeNumber","isSimpleObject","CanonicalNumericIndexString","n"],"mappings":"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","file":"to.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Descriptor, CallableObjectValue } from \"../types.js\";\nimport type { Realm } from \"../realm.js\";\nimport { GetMethod, Get } from \"./get.js\";\nimport { Create } from \"../singletons.js\";\nimport { HasProperty } from \"./has.js\";\nimport { Call } from \"./call.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { IsCallable } from \"./is.js\";\nimport { SameValue, SameValueZero } from \"./abstract.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  NullValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\n\ntype ElementConvType = {\n  Int8: (Realm, numberOrValue) => number,\n  Int16: (Realm, numberOrValue) => number,\n  Int32: (Realm, numberOrValue) => number,\n  Uint8: (Realm, numberOrValue) => number,\n  Uint16: (Realm, numberOrValue) => number,\n  Uint32: (Realm, numberOrValue) => number,\n  Uint8Clamped: (Realm, numberOrValue) => number,\n};\ntype numberOrValue = number | Value;\n\nfunction modulo(x: number, y: number): number {\n  return x < 0 ? x % y + y : x % y;\n}\n\nexport class ToImplementation {\n  constructor() {\n    this.ElementConv = {\n      Int8: this.ToInt8.bind(this),\n      Int16: this.ToInt16.bind(this),\n      Int32: this.ToInt32.bind(this),\n      Uint8: this.ToUint8.bind(this),\n      Uint16: this.ToUint16.bind(this),\n      Uint32: this.ToUint32.bind(this),\n      Uint8Clamped: this.ToUint8Clamp.bind(this),\n    };\n  }\n\n  ElementConv: ElementConvType;\n\n  // ECMA262 7.1.5\n  ToInt32(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^32.\n    let int32bit = modulo(int, Math.pow(2, 32));\n\n    // 5. If int32bit ≥ 2^31, return int32bit - 2^32; otherwise return int32bit.\n    return int32bit >= Math.pow(2, 31) ? int32bit - Math.pow(2, 32) : int32bit;\n  }\n\n  // ECMA262 7.1.6\n  ToUint32(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^32.\n    let int32bit = modulo(int, Math.pow(2, 32));\n\n    // 5. Return int32bit.\n    return int32bit;\n  }\n\n  // ECMA262 7.1.7\n  ToInt16(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^16.\n    let int16bit = modulo(int, Math.pow(2, 16));\n\n    // 5. If int16bit ≥ 2^15, return int16bit - 2^16; otherwise return int16bit.\n    return int16bit >= Math.pow(2, 15) ? int16bit - Math.pow(2, 16) : int16bit;\n  }\n\n  // ECMA262 7.1.8\n  ToUint16(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^16.\n    let int16bit = modulo(int, Math.pow(2, 16));\n\n    // 5. Return int16bit.\n    return int16bit;\n  }\n\n  // ECMA262 7.1.9\n  ToInt8(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int8bit be int modulo 2^8.\n    let int8bit = modulo(int, Math.pow(2, 8));\n\n    // 5. If int8bit ≥ 2^7, return int8bit - 2^8; otherwise return int8bit.\n    return int8bit >= Math.pow(2, 7) ? int8bit - Math.pow(2, 8) : int8bit;\n  }\n\n  // ECMA262 7.1.10\n  ToUint8(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int8bit be int modulo 2^8.\n    let int8bit = modulo(int, Math.pow(2, 8));\n\n    // 5. Return int8bit.\n    return int8bit;\n  }\n\n  // ECMA262 7.1.11\n  ToUint8Clamp(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, return +0.\n    if (isNaN(number)) return +0;\n\n    // 3. If number ≤ 0, return +0.\n    if (number <= 0) return +0;\n\n    // 4. If number ≥ 255, return 255.\n    if (number >= 255) return 255;\n\n    // 5. Let f be floor(number).\n    let f = Math.floor(number);\n\n    // 6. If f + 0.5 < number, return f + 1.\n    if (f + 0.5 < number) return f + 1;\n\n    // 7. If number < f + 0.5, return f.\n    if (number < f + 0.5) return f;\n\n    // 8. If f is odd, return f + 1.\n    if (f % 2 === 1) return f + 1;\n\n    // 9. Return f.\n    return f;\n  }\n\n  // ECMA262 19.3.3.1\n  thisBooleanValue(realm: Realm, value: Value): BooleanValue {\n    // 1. If Type(value) is Boolean, return value.\n    if (value instanceof BooleanValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[BooleanData]] internal slot, then\n    if (value instanceof ObjectValue && value.$BooleanData) {\n      const booleanData = value.$BooleanData.throwIfNotConcreteBoolean();\n      // a. Assert: value's [[BooleanData]] internal slot is a Boolean value.\n      invariant(booleanData instanceof BooleanValue, \"expected boolean data internal slot to be a boolean value\");\n\n      // b. Return the value of value's [[BooleanData]] internal slot.\n      return booleanData;\n    }\n\n    value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 20.1.3\n  thisNumberValue(realm: Realm, value: Value): NumberValue {\n    // 1. If Type(value) is Number, return value.\n    if (value instanceof NumberValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[NumberData]] internal slot, then\n    if (value instanceof ObjectValue && value.$NumberData) {\n      const numberData = value.$NumberData.throwIfNotConcreteNumber();\n      // a. Assert: value's [[NumberData]] internal slot is a Number value.\n      invariant(numberData instanceof NumberValue, \"expected number data internal slot to be a number value\");\n\n      // b. Return the value of value's [[NumberData]] internal slot.\n      return numberData;\n    }\n\n    value = value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 21.1.3\n  thisStringValue(realm: Realm, value: Value): StringValue {\n    // 1. If Type(value) is String, return value.\n    if (value instanceof StringValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[StringData]] internal slot, then\n    if (value instanceof ObjectValue && value.$StringData) {\n      const stringData = value.$StringData.throwIfNotConcreteString();\n      // a. Assert: value's [[StringData]] internal slot is a String value.\n      invariant(stringData instanceof StringValue, \"expected string data internal slot to be a string value\");\n\n      // b. Return the value of value's [[StringData]] internal slot.\n      return stringData;\n    }\n\n    value = value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 6.2.4.5\n  ToPropertyDescriptor(realm: Realm, Obj: Value): Descriptor {\n    Obj = Obj.throwIfNotConcrete();\n\n    // 1. If Type(Obj) is not Object, throw a TypeError exception.\n    if (!(Obj instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 2. Let desc be a new Property Descriptor that initially has no fields.\n    let desc: Descriptor = {};\n\n    // 3. Let hasEnumerable be ? HasProperty(Obj, \"enumerable\").\n    let hasEnumerable = HasProperty(realm, Obj, \"enumerable\");\n\n    // 4. If hasEnumerable is true, then\n    if (hasEnumerable === true) {\n      // a. Let enum be ToBoolean(? Get(Obj, \"enumerable\")).\n      let enu = this.ToBooleanPartial(realm, Get(realm, Obj, \"enumerable\"));\n\n      // b. Set the [[Enumerable]] field of desc to enum.\n      desc.enumerable = enu === true;\n    }\n\n    // 5. Let hasConfigurable be ? HasProperty(Obj, \"configurable\").\n    let hasConfigurable = HasProperty(realm, Obj, \"configurable\");\n\n    // 6. If hasConfigurable is true, then\n    if (hasConfigurable === true) {\n      // a. Let conf be ToBoolean(? Get(Obj, \"configurable\")).\n      let conf = this.ToBooleanPartial(realm, Get(realm, Obj, \"configurable\"));\n\n      // b. Set the [[Configurable]] field of desc to conf.\n      desc.configurable = conf === true;\n    }\n\n    // 7. Let hasValue be ? HasProperty(Obj, \"value\").\n    let hasValue = HasProperty(realm, Obj, \"value\");\n\n    // 8. If hasValue is true, then\n    if (hasValue === true) {\n      // a. Let value be ? Get(Obj, \"value\").\n      let value = Get(realm, Obj, \"value\");\n\n      // b. Set the [[Value]] field of desc to value.\n      desc.value = value;\n    }\n\n    // 9. Let hasWritable be ? HasProperty(Obj, \"writable\").\n    let hasWritable = HasProperty(realm, Obj, \"writable\");\n\n    // 10. If hasWritable is true, then\n    if (hasWritable === true) {\n      // a. Let writable be ToBoolean(? Get(Obj, \"writable\")).\n      let writable = this.ToBooleanPartial(realm, Get(realm, Obj, \"writable\"));\n\n      // b. Set the [[Writable]] field of desc to writable.\n      desc.writable = writable === true;\n    }\n\n    // 11. Let hasGet be ? HasProperty(Obj, \"get\").\n    let hasGet = HasProperty(realm, Obj, \"get\");\n\n    // 12. If hasGet is true, then\n    if (hasGet === true) {\n      // a. Let getter be ? Get(Obj, \"get\").\n      let getter = Get(realm, Obj, \"get\");\n\n      // b. If IsCallable(getter) is false and getter is not undefined, throw a TypeError exception.\n      if (IsCallable(realm, getter) === false && !getter.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n      getter.throwIfNotConcrete();\n\n      // c. Set the [[Get]] field of desc to getter.\n      desc.get = ((getter: any): CallableObjectValue | UndefinedValue);\n    }\n\n    // 13. Let hasSet be ? HasProperty(Obj, \"set\").\n    let hasSet = HasProperty(realm, Obj, \"set\");\n\n    // 14. If hasSet is true, then\n    if (hasSet === true) {\n      // a. Let setter be ? Get(Obj, \"set\").\n      let setter = Get(realm, Obj, \"set\");\n\n      // b. If IsCallable(setter) is false and setter is not undefined, throw a TypeError exception.\n      if (IsCallable(realm, setter) === false && !setter.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n      setter.throwIfNotConcrete();\n\n      // c. Set the [[Set]] field of desc to setter.\n      desc.set = ((setter: any): CallableObjectValue | UndefinedValue);\n    }\n\n    // 15. If either desc.[[Get]] or desc.[[Set]] is present, then\n    if (desc.get || desc.set) {\n      // a. If either desc.[[Value]] or desc.[[Writable]] is present, throw a TypeError exception.\n      if (\"value\" in desc || \"writable\" in desc) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 16. Return desc.\n    return desc;\n  }\n\n  // ECMA262 7.1.13\n  ToObject(realm: Realm, arg: ConcreteValue): ObjectValue {\n    if (arg instanceof UndefinedValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (arg instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (arg instanceof BooleanValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.BooleanPrototype);\n      obj.$BooleanData = arg;\n      return obj;\n    } else if (arg instanceof NumberValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.NumberPrototype);\n      obj.$NumberData = arg;\n      return obj;\n    } else if (arg instanceof StringValue) {\n      let obj = Create.StringCreate(realm, arg, realm.intrinsics.StringPrototype);\n      return obj;\n    } else if (arg instanceof SymbolValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.SymbolPrototype);\n      obj.$SymbolData = arg;\n      return obj;\n    } else if (arg instanceof ObjectValue) {\n      return arg;\n    }\n    invariant(false);\n  }\n\n  _WrapAbstractInObject(realm: Realm, arg: AbstractValue): ObjectValue | AbstractObjectValue {\n    let obj;\n    switch (arg.types.getType()) {\n      case IntegralValue:\n      case NumberValue:\n        obj = new ObjectValue(realm, realm.intrinsics.NumberPrototype);\n        obj.$NumberData = arg;\n        break;\n\n      case StringValue:\n        obj = new ObjectValue(realm, realm.intrinsics.StringPrototype);\n        obj.$StringData = arg;\n        break;\n\n      case BooleanValue:\n        obj = new ObjectValue(realm, realm.intrinsics.BooleanPrototype);\n        obj.$BooleanData = arg;\n        break;\n\n      case SymbolValue:\n        obj = new ObjectValue(realm, realm.intrinsics.SymbolPrototype);\n        obj.$SymbolData = arg;\n        break;\n\n      case UndefinedValue:\n      case NullValue:\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n\n      default:\n        if (realm.isInPureScope()) {\n          // Create a placeholder value to represent the ObjectValue that we would've\n          // received, but this object should never leak so as an optimization we will\n          // let operations on top of this object force the ToObject operations instead.\n          obj = AbstractValue.createFromType(realm, ObjectValue, \"sentinel ToObject\");\n          invariant(obj instanceof AbstractObjectValue);\n          obj.args = [arg];\n        } else {\n          obj = arg.throwIfNotConcreteObject();\n        }\n        break;\n    }\n    return obj;\n  }\n\n  ToObjectPartial(realm: Realm, arg: Value): ObjectValue | AbstractObjectValue {\n    if (arg instanceof AbstractObjectValue) return arg;\n    if (arg instanceof AbstractValue) {\n      return this._WrapAbstractInObject(realm, arg);\n    }\n    arg = arg.throwIfNotConcrete();\n    return this.ToObject(realm, arg);\n  }\n\n  // ECMA262 7.1.15\n  ToLength(realm: Realm, argument: numberOrValue): number {\n    // Let len be ? ToInteger(argument).\n    let len = this.ToInteger(realm, argument);\n\n    // If len ≤ +0, return +0.\n    if (len <= 0) return +0;\n\n    // If len is +∞, return 2^53-1.\n    if (len === +Infinity) return Math.pow(2, 53) - 1;\n\n    // Return min(len, 2^53-1).\n    return Math.min(len, Math.pow(2, 53) - 1);\n  }\n\n  // ECMA262 7.1.4\n  ToInteger(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, return +0.\n    if (isNaN(number)) return +0;\n\n    // 3. If number is +0, -0, +∞, or -∞, return number.\n    if (!isFinite(number) || number === 0) return number;\n\n    // 4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).\n    return number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n  }\n\n  // ECMA262 7.1.17\n  ToIndex(realm: Realm, value: number | ConcreteValue): number {\n    let index;\n    // 1. If value is undefined, then\n    if (value instanceof UndefinedValue) {\n      // a. Let index be 0.\n      index = 0;\n    } else {\n      // 2. Else,\n      // a. Let integerIndex be ? ToInteger(value).\n      let integerIndex = this.ToInteger(realm, value);\n\n      // b. If integerIndex < 0, throw a RangeError exception.\n      if (integerIndex < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"integerIndex < 0\");\n      }\n\n      // c. Let index be ! ToLength(integerIndex).\n      index = this.ToLength(realm, integerIndex);\n\n      // d. If SameValueZero(integerIndex, index) is false, throw a RangeError exception.\n      if (SameValueZero(realm, new NumberValue(realm, integerIndex), new NumberValue(realm, index)) === false) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"integerIndex < 0\");\n      }\n    }\n    // 3. Return index.\n    return index;\n  }\n\n  ToIndexPartial(realm: Realm, value: numberOrValue): number {\n    return this.ToIndex(realm, typeof value === \"number\" ? value : value.throwIfNotConcrete());\n  }\n\n  ToNumber(realm: Realm, val: numberOrValue): number {\n    const num = this.ToNumberOrAbstract(realm, val);\n    if (typeof num !== \"number\") {\n      AbstractValue.reportIntrospectionError(num);\n      throw new FatalError();\n    }\n    return num;\n  }\n\n  // ECMA262 7.1.3\n  ToNumberOrAbstract(realm: Realm, val: numberOrValue | AbstractValue): AbstractValue | number {\n    if (typeof val === \"number\") {\n      return val;\n    } else if (val instanceof AbstractValue) {\n      return val;\n    } else if (val instanceof UndefinedValue) {\n      return NaN;\n    } else if (val instanceof NullValue) {\n      return +0;\n    } else if (val instanceof ObjectValue) {\n      let prim = this.ToPrimitiveOrAbstract(realm, val, \"number\");\n      return this.ToNumberOrAbstract(realm, prim);\n    } else if (val instanceof BooleanValue) {\n      if (val.value === true) {\n        return 1;\n      } else {\n        // `val.value === false`\n        return 0;\n      }\n    } else if (val instanceof NumberValue) {\n      return val.value;\n    } else if (val instanceof StringValue) {\n      return Number(val.value);\n    } else if (val instanceof SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else {\n      invariant(false, \"unexpected type of value\");\n    }\n  }\n\n  IsToNumberPure(realm: Realm, val: numberOrValue): boolean {\n    if (val instanceof Value) {\n      if (this.IsToPrimitivePure(realm, val)) {\n        let type = val.getType();\n        return type !== SymbolValue && type !== PrimitiveValue && type !== Value;\n      }\n      return false;\n    }\n    return true;\n  }\n\n  // ECMA262 7.1.1\n  ToPrimitive(realm: Realm, input: ConcreteValue, hint?: \"default\" | \"string\" | \"number\"): PrimitiveValue {\n    return this.ToPrimitiveOrAbstract(realm, input, hint).throwIfNotConcretePrimitive();\n  }\n\n  ToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ConcreteValue,\n    hint?: \"default\" | \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue {\n    if (input instanceof PrimitiveValue) {\n      return input;\n    }\n\n    // When Type(input) is Object, the following steps are taken\n    invariant(input instanceof ObjectValue, \"expected an object\");\n\n    // 1. If PreferredType was not passed, let hint be \"default\".\n    hint = hint || \"default\";\n\n    // Following two steps are redundant since we just pass string hints.\n    // 2. Else if PreferredType is hint String, let hint be \"string\".\n    // 3. Else PreferredType is hint Number, let hint be \"number\".\n\n    // 4. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).\n    let exoticToPrim = GetMethod(realm, input, realm.intrinsics.SymbolToPrimitive);\n\n    // 5. If exoticToPrim is not undefined, then\n    if (!(exoticToPrim instanceof UndefinedValue)) {\n      // a. Let result be ? Call(exoticToPrim, input, « hint »).\n      let result = Call(realm, exoticToPrim, input, [new StringValue(realm, hint)]);\n\n      // b. If Type(result) is not Object, return result.\n      if (!(result instanceof ObjectValue)) {\n        invariant(result instanceof PrimitiveValue);\n        return result;\n      }\n\n      // c. Throw a TypeError exception.\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. If hint is \"default\", let hint be \"number\".\n    if (hint === \"default\") hint = \"number\";\n\n    // 7. Return ? OrdinaryToPrimitive(input, hint).\n    return this.OrdinaryToPrimitiveOrAbstract(realm, input, hint);\n  }\n\n  // Returns result type of ToPrimitive if it is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\n  GetToPrimitivePureResultType(realm: Realm, input: Value): void | typeof Value {\n    let type = input.getType();\n    if (input instanceof PrimitiveValue) return type;\n    if (input instanceof AbstractValue && !input.mightBeObject()) return PrimitiveValue;\n    return undefined;\n  }\n\n  IsToPrimitivePure(realm: Realm, input: Value) {\n    return this.GetToPrimitivePureResultType(realm, input) !== undefined;\n  }\n\n  // ECMA262 7.1.1\n  OrdinaryToPrimitive(realm: Realm, input: ObjectValue, hint: \"string\" | \"number\"): PrimitiveValue {\n    return this.OrdinaryToPrimitiveOrAbstract(realm, input, hint).throwIfNotConcretePrimitive();\n  }\n\n  OrdinaryToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ObjectValue,\n    hint: \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue {\n    let methodNames;\n\n    // 1. Assert: Type(O) is Object.\n    invariant(input instanceof ObjectValue, \"Expected object\");\n\n    // 2. Assert: Type(hint) is String and its value is either \"string\" or \"number\".\n    invariant(hint === \"string\" || hint === \"number\", \"Expected string or number hint\");\n\n    // 3. If hint is \"string\", then\n    if (hint === \"string\") {\n      // a. Let methodNames be « \"toString\", \"valueOf\" ».\n      methodNames = [\"toString\", \"valueOf\"];\n    } else {\n      // 4. Else,\n      // a. Let methodNames be « \"valueOf\", \"toString\" ».\n      methodNames = [\"valueOf\", \"toString\"];\n    }\n\n    // 5. For each name in methodNames in List order, do\n    for (let name of methodNames) {\n      // a. Let method be ? Get(O, name).\n      let method = Get(realm, input, new StringValue(realm, name));\n\n      // b. If IsCallable(method) is true, then\n      if (IsCallable(realm, method)) {\n        // i. Let result be ? Call(method, O).\n        let result = Call(realm, method, input);\n        let resultType = result.getType();\n\n        // ii. If Type(result) is not Object, return result.\n        if (resultType === Value) {\n          invariant(result instanceof AbstractValue);\n          let error = new CompilerDiagnostic(\n            `${name} might return either an object or primitive`,\n            realm.currentLocation,\n            \"PP0028\",\n            \"RecoverableError\"\n          );\n          realm.handleError(error);\n          throw new FatalError();\n        }\n        if (Value.isTypeCompatibleWith(resultType, PrimitiveValue)) {\n          invariant(result instanceof AbstractValue || result instanceof PrimitiveValue);\n          return result;\n        }\n      }\n    }\n\n    // 6. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"can't turn to primitive\");\n  }\n\n  // ECMA262 7.1.12\n  ToString(realm: Realm, val: string | ConcreteValue): string {\n    if (typeof val === \"string\") {\n      return val;\n    } else if (val instanceof StringValue) {\n      return val.value;\n    } else if (val instanceof NumberValue) {\n      return val.value + \"\";\n    } else if (val instanceof UndefinedValue) {\n      return \"undefined\";\n    } else if (val instanceof NullValue) {\n      return \"null\";\n    } else if (val instanceof SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (val instanceof BooleanValue) {\n      return val.value ? \"true\" : \"false\";\n    } else if (val instanceof ObjectValue) {\n      let primValue = this.ToPrimitive(realm, val, \"string\");\n      return this.ToString(realm, primValue);\n    } else {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown value type, can't coerce to string\");\n    }\n  }\n\n  ToStringPartial(realm: Realm, val: string | Value): string {\n    return this.ToString(realm, typeof val === \"string\" ? val : val.throwIfNotConcrete());\n  }\n\n  ToStringValue(realm: Realm, val: Value): Value {\n    if (val.getType() === StringValue) return val;\n    let str;\n    if (typeof val === \"string\") {\n      str = val;\n    } else if (val instanceof NumberValue) {\n      str = val.value + \"\";\n    } else if (val instanceof UndefinedValue) {\n      str = \"undefined\";\n    } else if (val instanceof NullValue) {\n      str = \"null\";\n    } else if (val instanceof SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (val instanceof BooleanValue) {\n      str = val.value ? \"true\" : \"false\";\n    } else if (val instanceof ObjectValue) {\n      let primValue = this.ToPrimitiveOrAbstract(realm, val, \"string\");\n      if (primValue.getType() === StringValue) return primValue;\n      str = this.ToStringPartial(realm, primValue);\n    } else {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown value type, can't coerce to string\");\n    }\n    return new StringValue(realm, str);\n  }\n\n  // ECMA262 7.1.2\n  ToBoolean(realm: Realm, val: ConcreteValue): boolean {\n    if (val instanceof BooleanValue) {\n      return val.value;\n    } else if (val instanceof UndefinedValue) {\n      return false;\n    } else if (val instanceof NullValue) {\n      return false;\n    } else if (val instanceof NumberValue) {\n      return val.value !== 0 && !isNaN(val.value);\n    } else if (val instanceof StringValue) {\n      return val.value.length > 0;\n    } else if (val instanceof ObjectValue) {\n      return true;\n    } else if (val instanceof SymbolValue) {\n      return true;\n    } else {\n      invariant(!(val instanceof AbstractValue));\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"unknown value type, can't coerce to a boolean\"\n      );\n    }\n  }\n\n  ToBooleanPartial(realm: Realm, val: Value): boolean {\n    if (!val.mightNotBeObject()) return true;\n    return this.ToBoolean(realm, val.throwIfNotConcrete());\n  }\n\n  // ECMA262 7.1.14\n  ToPropertyKey(realm: Realm, arg: ConcreteValue): SymbolValue | string /* but not StringValue */ {\n    // 1. Let key be ? ToPrimitive(argument, hint String).\n    let key = this.ToPrimitive(realm, arg, \"string\");\n\n    // 2. If Type(key) is Symbol, then\n    if (key instanceof SymbolValue) {\n      // a. Return key.\n      return key;\n    }\n\n    // 3. Return ! ToString(key).\n    return this.ToString(realm, key);\n  }\n\n  ToPropertyKeyPartial(realm: Realm, arg: Value): AbstractValue | SymbolValue | string /* but not StringValue */ {\n    if (arg instanceof ConcreteValue) return this.ToPropertyKey(realm, arg);\n    // if we are in pure scope, we can assume that ToPropertyKey\n    // won't cause side-effects even if it's not simple\n    if (arg.mightNotBeString() && arg.mightNotBeNumber() && !arg.isSimpleObject() && !realm.isInPureScope()) {\n      arg.throwIfNotConcrete();\n    }\n    invariant(arg instanceof AbstractValue);\n    return arg;\n  }\n\n  // ECMA262 7.1.16\n  CanonicalNumericIndexString(realm: Realm, argument: StringValue): number | void {\n    // 1. Assert: Type(argument) is String.\n    invariant(argument instanceof StringValue);\n\n    // 2. If argument is \"-0\", return −0.\n    if (argument.value === \"-0\") return -0;\n\n    // 3. Let n be ToNumber(argument).\n    let n = this.ToNumber(realm, argument);\n\n    // 4. If SameValue(ToString(n), argument) is false, return undefined.\n    if (SameValue(realm, new StringValue(realm, this.ToString(realm, new NumberValue(realm, n))), argument) === false)\n      return undefined;\n\n    // 5. Return n.\n    return n;\n  }\n}\n"]}