{"version":3,"sources":["../../src/evaluators/UpdateExpression.js"],"names":["ast","strictCode","env","realm","expr","evaluate","argument","oldExpr","GetValue","IsToNumberPure","error","loc","handleError","operator","op","newAbstractValue","createFromBinaryOp","PutValue","prefix","oldValue","ToNumber","newValue","createFromNumberValue"],"mappings":";;;;;;kBAqBe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKN;AACP;;AAEA;AACA,MAAIC,OAAOF,IAAIG,QAAJ,CAAaL,IAAIM,QAAjB,EAA2BL,UAA3B,CAAX;;AAEA;AACA,MAAIM,UAAU,wBAAYC,QAAZ,CAAqBL,KAArB,EAA4BC,IAA5B,CAAd;AACA,MAAIG,wCAAJ,EAAsC;AACpC,QAAI,CAAC,eAAGE,cAAH,CAAkBN,KAAlB,EAAyBI,OAAzB,CAAL,EAAwC;AACtC,UAAIG,QAAQ,+BACV,iGADU,EAEVV,IAAIM,QAAJ,CAAaK,GAFH,EAGV,QAHU,EAIV,kBAJU,CAAZ;AAMA,UAAIR,MAAMS,WAAN,CAAkBF,KAAlB,MAA6B,MAAjC,EAAyC,MAAM,wBAAN;AAC1C;AACD,6BAAUV,IAAIa,QAAJ,KAAiB,IAAjB,IAAyBb,IAAIa,QAAJ,KAAiB,IAApD,EAVoC,CAUuB;AAC3D,QAAIC,KAAKd,IAAIa,QAAJ,KAAiB,IAAjB,GAAwB,GAAxB,GAA8B,GAAvC;AACA,QAAIE,mBAAmB,sBAAcC,kBAAd,CAAiCb,KAAjC,EAAwCW,EAAxC,EAA4CP,OAA5C,EAAqD,wBAAgBJ,KAAhB,EAAuB,CAAvB,CAArD,EAAgFH,IAAIW,GAApF,CAAvB;AACA,2BAAWM,QAAX,CAAoBd,KAApB,EAA2BC,IAA3B,EAAiCW,gBAAjC;AACA,QAAIf,IAAIkB,MAAR,EAAgB;AACd,aAAOH,gBAAP;AACD,KAFD,MAEO;AACL,aAAOR,OAAP;AACD;AACF;AACD,MAAIY,WAAW,eAAGC,QAAH,CAAYjB,KAAZ,EAAmBI,OAAnB,CAAf;;AAEA,MAAIP,IAAIkB,MAAR,EAAgB;AACd,QAAIlB,IAAIa,QAAJ,KAAiB,IAArB,EAA2B;AACzB;;AAEA;AACA,UAAIQ,WAAW,gBAAIlB,KAAJ,EAAWgB,QAAX,EAAqB,CAArB,CAAf;;AAEA;AACA,6BAAWF,QAAX,CAAoBd,KAApB,EAA2BC,IAA3B,EAAiCiB,QAAjC;;AAEA;AACA,aAAOA,QAAP;AACD,KAXD,MAWO,IAAIrB,IAAIa,QAAJ,KAAiB,IAArB,EAA2B;AAChC;;AAEA;AACA,UAAIQ,WAAW,gBAAIlB,KAAJ,EAAWgB,QAAX,EAAqB,CAAC,CAAtB,CAAf;;AAEA;AACA,6BAAWF,QAAX,CAAoBd,KAApB,EAA2BC,IAA3B,EAAiCiB,QAAjC;;AAEA;AACA,aAAOA,QAAP;AACD;AACD,6BAAU,KAAV;AACD,GAzBD,MAyBO;AACL,QAAIrB,IAAIa,QAAJ,KAAiB,IAArB,EAA2B;AACzB;;AAEA;AACA,UAAIQ,WAAW,gBAAIlB,KAAJ,EAAWgB,QAAX,EAAqB,CAArB,CAAf;;AAEA;AACA,6BAAWF,QAAX,CAAoBd,KAApB,EAA2BC,IAA3B,EAAiCiB,QAAjC;;AAEA;AACA,aAAO,sBAAcC,qBAAd,CAAoCnB,KAApC,EAA2CgB,QAA3C,CAAP;AACD,KAXD,MAWO,IAAInB,IAAIa,QAAJ,KAAiB,IAArB,EAA2B;AAChC;;AAEA;AACA,UAAIQ,WAAW,gBAAIlB,KAAJ,EAAWgB,QAAX,EAAqB,CAAC,CAAtB,CAAf;;AAEA;AACA,6BAAWF,QAAX,CAAoBd,KAApB,EAA2BC,IAA3B,EAAiCiB,QAAjC;;AAEA;AACA,aAAO,sBAAcC,qBAAd,CAAoCnB,KAApC,EAA2CgB,QAA3C,CAAP;AACD;AACD,6BAAU,KAAV;AACD;AACF,C;;AA7FD;;AACA;;AACA;;AAEA;;AACA","file":"UpdateExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { Add } from \"../methods/index.js\";\nimport { AbstractValue, NumberValue, IntegralValue } from \"../values/index.js\";\nimport type { BabelNodeUpdateExpression } from \"babel-types\";\nimport { Environment, Properties, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeUpdateExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // ECMA262 12.4 Update Expressions\n\n  // Let expr be the result of evaluating UnaryExpression.\n  let expr = env.evaluate(ast.argument, strictCode);\n\n  // Let oldValue be ? ToNumber(? GetValue(expr)).\n  let oldExpr = Environment.GetValue(realm, expr);\n  if (oldExpr instanceof AbstractValue) {\n    if (!To.IsToNumberPure(realm, oldExpr)) {\n      let error = new CompilerDiagnostic(\n        \"might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method\",\n        ast.argument.loc,\n        \"PP0008\",\n        \"RecoverableError\"\n      );\n      if (realm.handleError(error) === \"Fail\") throw new FatalError();\n    }\n    invariant(ast.operator === \"++\" || ast.operator === \"--\"); // As per BabelNodeUpdateExpression\n    let op = ast.operator === \"++\" ? \"+\" : \"-\";\n    let newAbstractValue = AbstractValue.createFromBinaryOp(realm, op, oldExpr, new NumberValue(realm, 1), ast.loc);\n    Properties.PutValue(realm, expr, newAbstractValue);\n    if (ast.prefix) {\n      return newAbstractValue;\n    } else {\n      return oldExpr;\n    }\n  }\n  let oldValue = To.ToNumber(realm, oldExpr);\n\n  if (ast.prefix) {\n    if (ast.operator === \"++\") {\n      // ECMA262 12.4.6.1\n\n      // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5)\n      let newValue = Add(realm, oldValue, 1);\n\n      // 4. Perform ? PutValue(expr, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return newValue.\n      return newValue;\n    } else if (ast.operator === \"--\") {\n      // ECMA262 12.4.7.1\n\n      // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, -1);\n\n      // 4. Perform ? PutValue(expr, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return newValue.\n      return newValue;\n    }\n    invariant(false);\n  } else {\n    if (ast.operator === \"++\") {\n      // ECMA262 12.4.4.1\n\n      // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, 1);\n\n      // 4. Perform ? PutValue(lhs, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return oldValue.\n      return IntegralValue.createFromNumberValue(realm, oldValue);\n    } else if (ast.operator === \"--\") {\n      // ECMA262 12.4.5.1\n\n      // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, -1);\n\n      // 4. Perform ? PutValue(lhs, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return oldValue.\n      return IntegralValue.createFromNumberValue(realm, oldValue);\n    }\n    invariant(false);\n  }\n}\n"]}