{"version":3,"sources":["../../src/evaluators/ForStatement.js"],"names":["CreatePerIterationEnvironment","ast","strictCode","env","realm","labelSet","init","test","update","body","type","kind","varDcl","evaluate","ForBodyEvaluation","oldEnv","loopEnv","NewDeclarativeEnvironment","loopEnvRec","environmentRecord","isConst","boundNames","BoundNames","dn","CreateImmutableBinding","CreateMutableBinding","getRunningContext","lexicalEnvironment","forDcl","evaluateCompletion","currentEnv","onDestroyScope","destroyed","perIterationLets","bodyResult","exprRef","GetValue","perIterationBindings","length","lastIterationEnv","lastIterationEnvRec","outer","parent","thisIterationEnv","thisIterationEnvRec","bn","lastValue","GetBindingValue","InitializeBinding","intrinsics","undefined","increment","stmt","V","testRef","testValue","ToBooleanPartial","result","target","value","resultValue","incRef"],"mappings":"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","file":"ForStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\nimport { Value, EmptyValue } from \"../values/index.js\";\nimport { AbruptCompletion, BreakCompletion } from \"../completions.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { LoopContinues, InternalGetResultValue } from \"./ForOfStatement.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeForStatement } from \"babel-types\";\n\n// ECMA262 13.7.4.9\nexport function CreatePerIterationEnvironment(realm: Realm, perIterationBindings: Array<string>) {\n  // 1. If perIterationBindings has any elements, then\n  if (perIterationBindings.length > 0) {\n    // a. Let lastIterationEnv be the running execution context's LexicalEnvironment.\n    let lastIterationEnv = realm.getRunningContext().lexicalEnvironment;\n    // b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord.\n    let lastIterationEnvRec = lastIterationEnv.environmentRecord;\n    // c. Let outer be lastIterationEnv's outer environment reference.\n    let outer = lastIterationEnv.parent;\n    // d. Assert: outer is not null.\n    invariant(outer !== null);\n    // e. Let thisIterationEnv be NewDeclarativeEnvironment(outer).\n    let thisIterationEnv = Environment.NewDeclarativeEnvironment(realm, outer);\n    // f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord.\n    realm.onDestroyScope(lastIterationEnv);\n    let thisIterationEnvRec = thisIterationEnv.environmentRecord;\n    // g. For each element bn of perIterationBindings do,\n    for (let bn of perIterationBindings) {\n      // i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false).\n      thisIterationEnvRec.CreateMutableBinding(bn, false);\n      // ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true).\n      let lastValue = lastIterationEnvRec.GetBindingValue(bn, true);\n      // iii.Perform thisIterationEnvRec.InitializeBinding(bn, lastValue).\n      thisIterationEnvRec.InitializeBinding(bn, lastValue);\n    }\n    // h. Set the running execution context's LexicalEnvironment to thisIterationEnv.\n    realm.getRunningContext().lexicalEnvironment = thisIterationEnv;\n  }\n  // 2. Return undefined.\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 13.7.4.8\nfunction ForBodyEvaluation(\n  realm: Realm,\n  test,\n  increment,\n  stmt,\n  perIterationBindings: Array<string>,\n  labelSet,\n  strictCode: boolean\n): Value {\n  // 1. Let V be undefined.\n  let V: Value = realm.intrinsics.undefined;\n\n  // 2. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n  CreatePerIterationEnvironment(realm, perIterationBindings);\n  let env = realm.getRunningContext().lexicalEnvironment;\n\n  // 3. Repeat\n  while (true) {\n    // a. If test is not [empty], then\n    if (test) {\n      // i. Let testRef be the result of evaluating test.\n      let testRef = env.evaluate(test, strictCode);\n\n      // ii. Let testValue be ? GetValue(testRef).\n      let testValue = Environment.GetValue(realm, testRef);\n\n      // iii. If ToBoolean(testValue) is false, return NormalCompletion(V).\n      if (!To.ToBooleanPartial(realm, testValue)) return V;\n    }\n\n    // b. Let result be the result of evaluating stmt.\n    let result = env.evaluateCompletion(stmt, strictCode);\n    invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n    // c. If LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)).\n    if (!LoopContinues(realm, result, labelSet)) {\n      invariant(result instanceof AbruptCompletion);\n      // ECMA262 13.1.7\n      if (result instanceof BreakCompletion) {\n        if (!result.target) return (UpdateEmpty(realm, result, V): any).value;\n      }\n      throw UpdateEmpty(realm, result, V);\n    }\n\n    // d. If result.[[Value]] is not empty, let V be result.[[Value]].\n    let resultValue = InternalGetResultValue(realm, result);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n\n    // e. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n    CreatePerIterationEnvironment(realm, perIterationBindings);\n    env = realm.getRunningContext().lexicalEnvironment;\n\n    // f. If increment is not [empty], then\n    if (increment) {\n      // i. Let incRef be the result of evaluating increment.\n      let incRef = env.evaluate(increment, strictCode);\n\n      // ii. Perform ? GetValue(incRef).\n      Environment.GetValue(realm, incRef);\n    }\n  }\n\n  invariant(false);\n}\n\n// ECMA262 13.7.4.7\nexport default function(\n  ast: BabelNodeForStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { init, test, update, body } = ast;\n\n  if (init && init.type === \"VariableDeclaration\") {\n    if (init.kind === \"var\") {\n      // for (var VariableDeclarationList; Expression; Expression) Statement\n      // 1. Let varDcl be the result of evaluating VariableDeclarationList.\n      let varDcl = env.evaluate(init, strictCode);\n\n      // 2. ReturnIfAbrupt(varDcl).\n      varDcl;\n\n      // 3. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet).\n      return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n    } else {\n      // for (LexicalDeclaration Expression; Expression) Statement\n      // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n      let oldEnv = env;\n\n      // 2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).\n      let loopEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n      // 3. Let loopEnvRec be loopEnv's EnvironmentRecord.\n      let loopEnvRec = loopEnv.environmentRecord;\n\n      // 4. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration.\n      let isConst = init.kind === \"const\";\n\n      // 5. Let boundNames be the BoundNames of LexicalDeclaration.\n      let boundNames = Environment.BoundNames(realm, init);\n\n      // 6. For each element dn of boundNames do\n      for (let dn of boundNames) {\n        // a. If isConst is true, then\n        if (isConst) {\n          // i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true).\n          loopEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // b. Else,\n          // i. Perform ! loopEnvRec.CreateMutableBinding(dn, false).\n          loopEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n\n      // 7. Set the running execution context's LexicalEnvironment to loopEnv.\n      realm.getRunningContext().lexicalEnvironment = loopEnv;\n\n      // 8. Let forDcl be the result of evaluating LexicalDeclaration.\n      let forDcl = loopEnv.evaluateCompletion(init, strictCode);\n\n      // 9. If forDcl is an abrupt completion, then\n      if (forDcl instanceof AbruptCompletion) {\n        // a. Set the running execution context's LexicalEnvironment to oldEnv.\n        let currentEnv = realm.getRunningContext().lexicalEnvironment;\n        realm.onDestroyScope(currentEnv);\n        if (currentEnv !== loopEnv) invariant(loopEnv.destroyed);\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n\n        // b. Return Completion(forDcl).\n        throw forDcl;\n      }\n\n      // 10. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ».\n      let perIterationLets = !isConst ? boundNames : [];\n\n      let bodyResult;\n      try {\n        // 11. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).\n        bodyResult = ForBodyEvaluation(realm, test, update, body, perIterationLets, labelSet, strictCode);\n      } finally {\n        // 12. Set the running execution context's LexicalEnvironment to oldEnv.\n        let currentEnv = realm.getRunningContext().lexicalEnvironment;\n        realm.onDestroyScope(currentEnv);\n        if (currentEnv !== loopEnv) invariant(loopEnv.destroyed);\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n      }\n      // 13. Return Completion(bodyResult).\n      return bodyResult;\n    }\n  } else {\n    // for (Expression; Expression; Expression) Statement\n    // 1. If the first Expression is present, then\n    if (init) {\n      // a. Let exprRef be the result of evaluating the first Expression.\n      let exprRef = env.evaluate(init, strictCode);\n\n      // b. Perform ? GetValue(exprRef).\n      Environment.GetValue(realm, exprRef);\n    }\n\n    // 2. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet).\n    return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n  }\n}\n"]}