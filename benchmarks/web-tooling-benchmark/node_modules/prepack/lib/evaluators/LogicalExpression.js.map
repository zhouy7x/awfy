{"version":3,"sources":["../../src/evaluators/LogicalExpression.js"],"names":["ast","strictCode","env","realm","lref","evaluate","left","lval","GetValue","lbool","ToBoolean","operator","rref","right","lcond","GetConditionValue","mightNotBeFalse","mightNotBeTrue","compl1","gen1","bindings1","properties1","createdObj1","wrapper","withCondition","withInverseCondition","compl2","gen2","bindings2","properties2","createdObj2","evaluateNodeForEffects","joinedEffects","joinEffects","completion","composeWithSavedCompletion","applyEffects","createFromLogicalOp","loc"],"mappings":"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","file":"LogicalExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { Environment } from \"../singletons.js\";\nimport type { BabelNodeLogicalExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Join, Path, To } from \"../singletons.js\";\n\nexport default function(\n  ast: BabelNodeLogicalExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value | Reference {\n  let lref = env.evaluate(ast.left, strictCode);\n  let lval = Environment.GetValue(realm, lref);\n\n  if (lval instanceof ConcreteValue) {\n    let lbool = To.ToBoolean(realm, lval);\n\n    if (ast.operator === \"&&\") {\n      // ECMA262 12.13.3\n      if (lbool === false) return lval;\n    } else {\n      invariant(ast.operator === \"||\");\n      // ECMA262 12.13.3\n      if (lbool === true) return lval;\n    }\n\n    let rref = env.evaluate(ast.right, strictCode);\n    return Environment.GetValue(realm, rref);\n  }\n  invariant(lval instanceof AbstractValue);\n  let lcond = Environment.GetConditionValue(realm, lref);\n\n  if (!lcond.mightNotBeFalse()) return ast.operator === \"||\" ? env.evaluate(ast.right, strictCode) : lval;\n  if (!lcond.mightNotBeTrue()) return ast.operator === \"&&\" ? env.evaluate(ast.right, strictCode) : lval;\n\n  // Create empty effects for the case where ast.right is not evaluated\n  let [compl1, gen1, bindings1, properties1, createdObj1] = construct_empty_effects(realm);\n  compl1; // ignore\n\n  // Evaluate ast.right in a sandbox to get its effects\n  let wrapper = ast.operator === \"&&\" ? Path.withCondition : Path.withInverseCondition;\n  let [compl2, gen2, bindings2, properties2, createdObj2] = wrapper(lval, () =>\n    realm.evaluateNodeForEffects(ast.right, strictCode, env)\n  );\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of lval.\n  // Note that converting a value to boolean never has a side effect, so we can\n  // use lval as is for the join condition.\n  let joinedEffects;\n  if (ast.operator === \"&&\") {\n    joinedEffects = Join.joinEffects(\n      realm,\n      lval,\n      [compl2, gen2, bindings2, properties2, createdObj2],\n      [lval, gen1, bindings1, properties1, createdObj1]\n    );\n  } else {\n    joinedEffects = Join.joinEffects(\n      realm,\n      lval,\n      [lval, gen1, bindings1, properties1, createdObj1],\n      [compl2, gen2, bindings2, properties2, createdObj2]\n    );\n  }\n  let completion = joinedEffects[0];\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case the evaluation of ast.right may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value); // references do not survive join\n  if (lval instanceof Value && compl2 instanceof Value) {\n    // joinEffects does the right thing for the side effects of the second expression but for the result the join\n    // produces a conditional expressions of the form (a ? b : a) for a && b and (a ? a : b) for a || b\n    // Rather than look for this pattern everywhere, we override this behavior and replace the completion with\n    // the actual logical operator. This helps with simplification and reasoning when dealing with path conditions.\n    completion = AbstractValue.createFromLogicalOp(realm, ast.operator, lval, compl2, ast.loc);\n  }\n  return completion;\n}\n"]}