{"version":3,"sources":["../../src/evaluators/VariableDeclaration.js"],"names":["ast","strictCode","env","realm","kind","letAndConst","declar","declarations","Initializer","init","id","type","bindingId","name","lhs","ResolveBinding","rhs","evaluate","value","GetValue","__originalName","hasNameProperty","SetFunctionName","PutValue","rval","BindingInitialization","undefined","intrinsics","empty","InitializeReferencedBinding"],"mappings":"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","file":"VariableDeclaration.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport type { Value } from \"../values/index.js\";\nimport { ObjectValue, StringValue } from \"../values/index.js\";\nimport { IsAnonymousFunctionDefinition, HasOwnProperty } from \"../methods/index.js\";\nimport { Environment, Functions, Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeVariableDeclaration } from \"babel-types\";\n\n// ECMA262 13.3.1.4\nfunction letAndConst(\n  ast: BabelNodeVariableDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  for (let declar of ast.declarations) {\n    if (declar.id.type !== \"Identifier\") {\n      throw new FatalError(\"TODO #415: Patterns aren't supported yet\");\n    }\n\n    let Initializer = declar.init;\n    if (!Initializer) {\n      invariant(ast.kind !== \"const\", \"const without an initializer\");\n\n      // 1. Let lhs be ResolveBinding(StringValue of BindingIdentifier).\n      let bindingId = declar.id.name;\n      let lhs = Environment.ResolveBinding(realm, bindingId, strictCode);\n\n      // 2. Return InitializeReferencedBinding(lhs, undefined).\n      Environment.InitializeReferencedBinding(realm, lhs, realm.intrinsics.undefined);\n      continue;\n    }\n\n    // 1. Let bindingId be StringValue of BindingIdentifier.\n    let bindingId = declar.id.name;\n\n    // 2. Let lhs be ResolveBinding(bindingId).\n    let lhs = Environment.ResolveBinding(realm, bindingId, strictCode);\n\n    // 3. Let rhs be the result of evaluating Initializer.\n    let rhs = env.evaluate(Initializer, strictCode);\n\n    // 4. Let value be ? GetValue(rhs).\n    let value = Environment.GetValue(realm, rhs);\n\n    // 5. If IsAnonymousFunctionDefinition(Initializer) is true, then\n    if (IsAnonymousFunctionDefinition(realm, Initializer)) {\n      invariant(value instanceof ObjectValue);\n\n      // a. Let hasNameProperty be ? HasOwnProperty(value, \"name\").\n      let hasNameProperty = HasOwnProperty(realm, value, \"name\");\n\n      // b. If hasNameProperty is false, perform SetFunctionName(value, bindingId).\n      if (!hasNameProperty) Functions.SetFunctionName(realm, value, new StringValue(realm, bindingId));\n    }\n\n    // 6. Return InitializeReferencedBinding(lhs, value).\n    Environment.InitializeReferencedBinding(realm, lhs, value);\n  }\n\n  return realm.intrinsics.empty;\n}\n\n// ECMA262 13.3.2.4\nexport default function(\n  ast: BabelNodeVariableDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (ast.kind === \"let\" || ast.kind === \"const\") {\n    return letAndConst(ast, strictCode, env, realm);\n  }\n\n  for (let declar of ast.declarations) {\n    let Initializer = declar.init;\n\n    if (declar.id.type === \"Identifier\" && !Initializer) {\n      // VariableDeclaration : BindingIdentifier\n\n      // 1. Return NormalCompletion(empty).\n      continue;\n    } else if (declar.id.type === \"Identifier\" && Initializer) {\n      // VariableDeclaration : BindingIdentifier Initializer\n\n      // 1. Let bindingId be StringValue of BindingIdentifier.\n      let bindingId = declar.id.name;\n\n      // 2. Let lhs be ? ResolveBinding(bindingId).\n      let lhs = Environment.ResolveBinding(realm, bindingId, strictCode);\n\n      // 3. Let rhs be the result of evaluating Initializer.\n      let rhs = env.evaluate(Initializer, strictCode);\n\n      // 4. Let value be ? GetValue(rhs).\n      let value = Environment.GetValue(realm, rhs);\n      if (declar.id && declar.id.name) value.__originalName = bindingId;\n\n      // 5. If IsAnonymousFunctionDefinition(Initializer) is true, then\n      if (IsAnonymousFunctionDefinition(realm, Initializer)) {\n        invariant(value instanceof ObjectValue);\n\n        // a. Let hasNameProperty be ? HasOwnProperty(value, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, value, \"name\");\n\n        // b. If hasNameProperty is false, perform SetFunctionName(value, bindingId).\n        if (!hasNameProperty) Functions.SetFunctionName(realm, value, new StringValue(realm, bindingId));\n      }\n\n      // 6. Return ? PutValue(lhs, value).\n      Properties.PutValue(realm, lhs, value);\n    } else if ((declar.id.type === \"ObjectPattern\" || declar.id.type === \"ArrayPattern\") && Initializer) {\n      // 1. Let rhs be the result of evaluating Initializer.\n      let rhs = env.evaluate(Initializer, strictCode);\n\n      // 2. Let rval be ? GetValue(rhs).\n      let rval = Environment.GetValue(realm, rhs);\n\n      // 3. Return the result of performing BindingInitialization for BindingPattern passing rval and undefined as arguments.\n      Environment.BindingInitialization(realm, declar.id, rval, strictCode, undefined);\n    } else {\n      invariant(false, \"unrecognized declaration\");\n    }\n  }\n\n  return realm.intrinsics.empty;\n}\n"]}