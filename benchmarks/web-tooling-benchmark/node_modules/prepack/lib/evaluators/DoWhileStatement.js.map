{"version":3,"sources":["../../src/evaluators/DoWhileStatement.js"],"names":["ast","strictCode","env","realm","labelSet","body","test","V","intrinsics","undefined","resultOrDiagnostic","evaluateWithUndoForDiagnostic","stmt","evaluateCompletion","target","value","resultValue","exprRef","evaluate","exprValue","GetConditionValue","ToBooleanPartial","ftest","fbody","effects","evaluateForFixpointEffects","outsideEffects","insideEffects","rval","bodyGenerator","applyEffects","GetValue","cond","derive","types","values","n","skipInvariant","generator","emitDoWhileStatement","handleError"],"mappings":"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","file":"DoWhileStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { AbstractValue, Value } from \"../values/index.js\";\nimport { EmptyValue } from \"../values/index.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { LoopContinues, InternalGetResultValue } from \"./ForOfStatement.js\";\nimport { AbruptCompletion, BreakCompletion } from \"../completions.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeDoWhileStatement } from \"babel-types\";\n\nexport default function(\n  ast: BabelNodeDoWhileStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { body, test } = ast;\n\n  // 1. Let V be undefined.\n  let V = realm.intrinsics.undefined;\n\n  // 2. Repeat\n  let resultOrDiagnostic = realm.evaluateWithUndoForDiagnostic(() => {\n    while (true) {\n      // a. Let stmt be the result of evaluating Statement.\n      let stmt = env.evaluateCompletion(body, strictCode);\n      //todo: check if stmt is a PossiblyNormalCompletion and defer to fixpoint computation below\n      invariant(stmt instanceof Value || stmt instanceof AbruptCompletion);\n\n      // b. If LoopContinues(stmt, labelSet) is false, return Completion(UpdateEmpty(stmt, V)).\n      if (LoopContinues(realm, stmt, labelSet) === false) {\n        invariant(stmt instanceof AbruptCompletion);\n        // ECMA262 13.1.7\n        if (stmt instanceof BreakCompletion) {\n          if (!stmt.target) return (UpdateEmpty(realm, stmt, V): any).value;\n        }\n        throw UpdateEmpty(realm, stmt, V);\n      }\n\n      // c. If stmt.[[Value]] is not empty, let V be stmt.[[Value]].\n      let resultValue = InternalGetResultValue(realm, stmt);\n      if (!(resultValue instanceof EmptyValue)) V = resultValue;\n\n      // d. Let exprRef be the result of evaluating Expression.\n      let exprRef = env.evaluate(test, strictCode);\n\n      // e. Let exprValue be ? GetValue(exprRef).\n      let exprValue = Environment.GetConditionValue(realm, exprRef);\n\n      // f. If ToBoolean(exprValue) is false, return NormalCompletion(V).\n      if (To.ToBooleanPartial(realm, exprValue) === false) return V;\n    }\n    invariant(false);\n  });\n  if (resultOrDiagnostic instanceof Value) return resultOrDiagnostic;\n\n  // If we get here then unrolling the loop did not work, possibly because the value of the loop condition is not known,\n  // so instead try to compute a fixpoint for it\n  let ftest = () => {\n    let exprRef = env.evaluate(test, strictCode);\n    return Environment.GetConditionValue(realm, exprRef);\n  };\n  let fbody = () => env.evaluateCompletion(body, strictCode);\n  let effects = realm.evaluateForFixpointEffects(ftest, fbody);\n  if (effects !== undefined) {\n    let [outsideEffects, insideEffects] = effects;\n    let [rval] = outsideEffects;\n    let [, bodyGenerator] = insideEffects;\n    realm.applyEffects(outsideEffects);\n    let exprRef = env.evaluate(test, strictCode);\n    let exprValue = Environment.GetValue(realm, exprRef);\n    invariant(exprValue instanceof AbstractValue);\n    let cond = bodyGenerator.derive(exprValue.types, exprValue.values, [exprValue], ([n]) => n, {\n      skipInvariant: true,\n    });\n    let generator = realm.generator;\n    invariant(generator !== undefined);\n    generator.emitDoWhileStatement(cond, bodyGenerator);\n    invariant(rval instanceof Value, \"todo: handle loops that throw exceptions or return\");\n    return rval;\n  }\n\n  // If we get here the fixpoint computation failed as well. Report the diagnostic from the unrolling and throw.\n  realm.handleError(resultOrDiagnostic);\n  throw new FatalError();\n}\n"]}