{"version":3,"sources":["../../src/evaluators/Program.js"],"names":["GlobalDeclarationInstantiation","ast","strictCode","env","realm","val","node","body","type","res","evaluateCompletionDeref","useAbstractInterpretation","incorporateSavedCompletion","emitConditionalThrow","joinCondition","consequent","alternate","value","emitThrow","intrinsics","undefined","directives","length","directive","evaluate","stopEffectCaptureJoinApplyAndReturnCompletion","empty","issueThrowCompilerDiagnostic","message","object","objectMessage","evaluateWithUndo","$Get","objectStack","diagnostic","expressionLocation","handleError","generator","emitStatement","argument","t","throwStatement","condition","trueBranch","falseBranch","args","buildfunc","deconstruct","targs","tfunc","fargs","ffunc","nodes","emptyStatement","concat","func","ifStatement","slice","splice","getRunningContext","isStrict","envRec","environmentRecord","lexNames","varNames","kind","BoundNames","name","HasVarDeclaration","createErrorThrowCompletion","SyntaxError","HasLexicalDeclaration","hasRestrictedGlobal","HasRestrictedGlobalProperty","varDeclarations","FindVarScopedDeclarations","functionsToInitialize","declaredFunctionNames","d","reverse","fn","indexOf","fnDefinable","CanDeclareGlobalFunction","TypeError","push","unshift","declaredVarNames","vn","vnDefinable","CanDeclareGlobalVar","lexDeclarations","s","dn","CreateImmutableBinding","CreateMutableBinding","f","fo","CreateGlobalFunctionBinding","CreateGlobalVarBinding"],"mappings":"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","file":"Program.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  AbruptCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  PossiblyNormalCompletion,\n  ReturnCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ObjectValue, StringValue, Value, EmptyValue } from \"../values/index.js\";\nimport { GlobalEnvironmentRecord } from \"../environment.js\";\nimport { Environment, Functions, Join } from \"../singletons.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport invariant from \"../invariant.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport type { BabelNodeProgram } from \"babel-types\";\nimport * as t from \"babel-types\";\nimport { CompilerDiagnostic } from \"../errors.js\";\n\n// ECMA262 15.1.11\nexport function GlobalDeclarationInstantiation(\n  realm: Realm,\n  ast: BabelNodeProgram,\n  env: LexicalEnvironment,\n  strictCode: boolean\n) {\n  realm.getRunningContext().isStrict = realm.isStrict = strictCode;\n\n  // 1. Let envRec be env's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a global Environment Record.\n  invariant(envRec instanceof GlobalEnvironmentRecord, \"expected global environment record\");\n\n  // 3. Let lexNames be the LexicallyDeclaredNames of script.\n  let lexNames = [];\n\n  // 4. Let varNames be the VarDeclaredNames of script.\n  let varNames = [];\n\n  traverseFast(ast, node => {\n    if (node.type === \"VariableDeclaration\") {\n      if (node.kind === \"var\") {\n        varNames = varNames.concat(Environment.BoundNames(realm, node));\n      } else {\n        lexNames = lexNames.concat(Environment.BoundNames(realm, node));\n      }\n    } else if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n      return true;\n    }\n    return false;\n  });\n\n  // 5. For each name in lexNames, do\n  for (let name of lexNames) {\n    // a. If envRec.HasVarDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasVarDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + \" already declared with var\");\n    }\n\n    // b. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasLexicalDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.SyntaxError,\n        name + \" already declared with let or const\"\n      );\n    }\n\n    // c. Let hasRestrictedGlobal be ? envRec.HasRestrictedGlobalProperty(name).\n    let hasRestrictedGlobal = envRec.HasRestrictedGlobalProperty(name);\n\n    // d. If hasRestrictedGlobal is true, throw a SyntaxError exception.\n    if (hasRestrictedGlobal) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + \" global object is restricted\");\n    }\n  }\n\n  // 6. For each name in varNames, do\n  for (let name of varNames) {\n    // a. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasLexicalDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.SyntaxError,\n        name + \" already declared with let or const\"\n      );\n    }\n  }\n\n  // 7. Let varDeclarations be the VarScopedDeclarations of script.\n  let varDeclarations = Functions.FindVarScopedDeclarations(ast);\n\n  // 8. Let functionsToInitialize be a new empty List.\n  let functionsToInitialize = [];\n\n  // 9. Let declaredFunctionNames be a new empty List.\n  let declaredFunctionNames = [];\n\n  // 10. For each d in varDeclarations, in reverse list order do\n  for (let d of varDeclarations.reverse()) {\n    // a. If d is neither a VariableDeclaration or a ForBinding, then\n    if (d.type !== \"VariableDeclaration\") {\n      // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n      invariant(d.type === \"FunctionDeclaration\", \"expected function\");\n\n      // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.\n\n      // iii. Let fn be the sole element of the BoundNames of d.\n      let fn = Environment.BoundNames(realm, d)[0];\n\n      // iv. If fn is not an element of declaredFunctionNames, then\n      if (declaredFunctionNames.indexOf(fn) < 0) {\n        // 1. Let fnDefinable be ? envRec.CanDeclareGlobalFunction(fn).\n        let fnDefinable = envRec.CanDeclareGlobalFunction(fn);\n\n        // 2. If fnDefinable is false, throw a TypeError exception.\n        if (!fnDefinable) {\n          throw realm.createErrorThrowCompletion(\n            realm.intrinsics.TypeError,\n            fn + \": global function declarations are not allowed\"\n          );\n        }\n\n        // 3. Append fn to declaredFunctionNames.\n        declaredFunctionNames.push(fn);\n\n        // 4. Insert d as the first element of functionsToInitialize.\n        functionsToInitialize.unshift(d);\n      }\n    }\n  }\n\n  // 11. Let declaredVarNames be a new empty List.\n  let declaredVarNames = [];\n\n  // 12. For each d in varDeclarations, do\n  for (let d of varDeclarations) {\n    // a. If d is a VariableDeclaration or a ForBinding, then\n    if (d.type === \"VariableDeclaration\") {\n      // i. For each String vn in the BoundNames of d, do\n      for (let vn of Environment.BoundNames(realm, d)) {\n        // ii. If vn is not an element of declaredFunctionNames, then\n        if (declaredFunctionNames.indexOf(vn) < 0) {\n          // 1. Let vnDefinable be ? envRec.CanDeclareGlobalVar(vn).\n          let vnDefinable = envRec.CanDeclareGlobalVar(vn);\n\n          // 2. If vnDefinable is false, throw a TypeError exception.\n          if (!vnDefinable) {\n            throw realm.createErrorThrowCompletion(\n              realm.intrinsics.TypeError,\n              vn + \": global variable declarations are not allowed\"\n            );\n          }\n\n          // 3. If vn is not an element of declaredVarNames, then\n          if (declaredVarNames.indexOf(vn) < 0) {\n            // a. Append vn to declaredVarNames.\n            declaredVarNames.push(vn);\n          }\n        }\n      }\n    }\n  }\n\n  // 13. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.\n\n  // 14. NOTE: Annex B.3.3.2 adds additional steps at this point.\n\n  // 15. Let lexDeclarations be the LexicallyScopedDeclarations of script.\n  let lexDeclarations = [];\n  for (let s of ast.body) {\n    if (s.type === \"VariableDeclaration\" && s.kind !== \"var\") {\n      lexDeclarations.push(s);\n    }\n  }\n\n  // 16. For each element d in lexDeclarations do\n  for (let d of lexDeclarations) {\n    // a. NOTE Lexically declared names are only instantiated here but not initialized.\n\n    // b. For each element dn of the BoundNames of d do\n    for (let dn of Environment.BoundNames(realm, d)) {\n      // i. If IsConstantDeclaration of d is true, then\n      if (d.kind === \"const\") {\n        // 1. Perform ? envRec.CreateImmutableBinding(dn, true).\n        envRec.CreateImmutableBinding(dn, true);\n      } else {\n        // ii. Else,\n        // 1. Perform ? envRec.CreateMutableBinding(dn, false).\n        envRec.CreateMutableBinding(dn, false);\n      }\n    }\n  }\n\n  // 17. For each production f in functionsToInitialize, do\n  for (let f of functionsToInitialize) {\n    // a. Let fn be the sole element of the BoundNames of f.\n    let fn = Environment.BoundNames(realm, f)[0];\n\n    // b. Let fo be the result of performing InstantiateFunctionObject for f with argument env.\n    let fo = env.evaluate(f, strictCode);\n    invariant(fo instanceof Value);\n\n    // c. Perform ? envRec.CreateGlobalFunctionBinding(fn, fo, false).\n    envRec.CreateGlobalFunctionBinding(fn, fo, false);\n  }\n\n  // 18. For each String vn in declaredVarNames, in list order do\n  for (let vn of declaredVarNames) {\n    // a. Perform ? envRec.CreateGlobalVarBinding(vn, false).\n    envRec.CreateGlobalVarBinding(vn, false);\n  }\n\n  // 19. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n\nexport default function(ast: BabelNodeProgram, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  strictCode = IsStrict(ast);\n\n  GlobalDeclarationInstantiation(realm, ast, env, strictCode);\n\n  let val;\n\n  for (let node of ast.body) {\n    if (node.type !== \"FunctionDeclaration\") {\n      let res = env.evaluateCompletionDeref(node, strictCode);\n      if (res instanceof AbruptCompletion) {\n        if (!realm.useAbstractInterpretation) throw res;\n        // We are about the leave this program and this presents a join point where all non exeptional control flows\n        // converge into a single flow using the joined effects as the new state.\n        res = Functions.incorporateSavedCompletion(realm, res);\n        // The call to incorporateSavedCompletion above, has taken care of the join because res is abrupt.\n        // What remains to be done is to emit throw statements to the generator.\n        if (res instanceof JoinedAbruptCompletions) {\n          emitConditionalThrow(res.joinCondition, res.consequent, res.alternate);\n          res = res.value;\n        } else if (res instanceof ThrowCompletion) {\n          emitThrow(res.value);\n          res = realm.intrinsics.undefined;\n        } else {\n          invariant(false); // other kinds of abrupt completions should not get this far\n        }\n      }\n      if (!(res instanceof EmptyValue)) {\n        val = res;\n      }\n    }\n  }\n  let directives = ast.directives;\n  if (!val && directives && directives.length) {\n    let directive = directives[directives.length - 1];\n    val = env.evaluate(directive, strictCode);\n    invariant(val instanceof Value);\n  }\n\n  // We are about to leave this program and this presents a join point where all control flows\n  // converge into a single flow and the joined effects become the final state.\n  if (val instanceof Value) {\n    val = Functions.incorporateSavedCompletion(realm, val);\n    if (val instanceof PossiblyNormalCompletion) {\n      // There are still some conditional throws to emit and state still has to be joined in.\n      Join.stopEffectCaptureJoinApplyAndReturnCompletion(val, new ReturnCompletion(realm.intrinsics.undefined), realm);\n      // The global state has now been updated to the join of all the flows reaching this join point\n      emitConditionalThrow(val.joinCondition, val.consequent, val.alternate);\n      val = val.value;\n    }\n  } else {\n    // program was empty. Nothing to do.\n  }\n\n  invariant(val === undefined || val instanceof Value);\n  return val || realm.intrinsics.empty;\n\n  function issueThrowCompilerDiagnostic(value: Value) {\n    let message = \"Program may terminate with exception\";\n    if (value instanceof ObjectValue) {\n      let object = ((value: any): ObjectValue);\n      let objectMessage = realm.evaluateWithUndo(() => object.$Get(\"message\", value));\n      if (objectMessage instanceof StringValue) message += `: ${objectMessage.value}`;\n      const objectStack = realm.evaluateWithUndo(() => object.$Get(\"stack\", value));\n      if (objectStack instanceof StringValue)\n        message += `\n  ${objectStack.value}`;\n    }\n    const diagnostic = new CompilerDiagnostic(message, value.expressionLocation, \"PP1023\", \"Warning\");\n    realm.handleError(diagnostic);\n  }\n\n  function emitThrow(value: Value) {\n    issueThrowCompilerDiagnostic(value);\n    let generator = realm.generator;\n    invariant(generator !== undefined);\n    generator.emitStatement([value], ([argument]) => t.throwStatement(argument));\n  }\n\n  function emitConditionalThrow(\n    condition: AbstractValue,\n    trueBranch: Completion | Value,\n    falseBranch: Completion | Value\n  ) {\n    let generator = realm.generator;\n    invariant(generator !== undefined);\n    let [args, buildfunc] = deconstruct(condition, trueBranch, falseBranch);\n    generator.emitStatement(args, buildfunc);\n  }\n\n  function deconstruct(condition: AbstractValue, trueBranch: Completion | Value, falseBranch: Completion | Value) {\n    let targs;\n    let tfunc;\n    let fargs;\n    let ffunc;\n    if (trueBranch instanceof JoinedAbruptCompletions) {\n      [targs, tfunc] = deconstruct(trueBranch.joinCondition, trueBranch.consequent, trueBranch.alternate);\n    } else if (trueBranch instanceof ThrowCompletion) {\n      targs = [trueBranch.value];\n      issueThrowCompilerDiagnostic(trueBranch.value);\n      tfunc = ([argument]) => t.throwStatement(argument);\n    } else {\n      targs = [];\n      tfunc = nodes => t.emptyStatement();\n    }\n    if (falseBranch instanceof JoinedAbruptCompletions) {\n      [fargs, ffunc] = deconstruct(falseBranch.joinCondition, falseBranch.consequent, falseBranch.alternate);\n    } else if (falseBranch instanceof ThrowCompletion) {\n      fargs = [falseBranch.value];\n      issueThrowCompilerDiagnostic(falseBranch.value);\n      ffunc = ([argument]) => t.throwStatement(argument);\n    } else {\n      fargs = [];\n      ffunc = nodes => t.emptyStatement();\n    }\n    let args = [condition].concat(targs).concat(fargs);\n    let func = nodes => {\n      return t.ifStatement(\n        nodes[0],\n        tfunc(nodes.slice().splice(1, targs.length)),\n        ffunc(nodes.slice().splice(targs.length + 1, fargs.length))\n      );\n    };\n    return [args, func];\n  }\n}\n"]}