{"version":3,"sources":["../../src/evaluators/JSXElement.js"],"names":["ast","strictCode","env","realm","react","enabled","openingElement","type","evaluateJSXIdentifier","name","children","evaluateJSXChildren","config","evaluateJSXAttributes","attributes","t","cleanJSXElementLiteralChild","child","lines","split","lastNonEmptyLine","i","length","match","str","line","isFirstLine","isLastLine","isLastNonEmptyLine","trimmedLine","replace","evaluateJSXMemberExpression","GetValue","ResolveBinding","evaluate","isTagName","evaluateJSXValue","value","expression","test","intrinsics","undefined","singleChild","text","array","ArrayCreate","dynamicChildrenLength","dynamicIterator","lastChildValue","CreateDataPropertyOrThrow","Set","isObjectEmpty","object","propertyCount","binding","properties","descriptor","enumerable","astAttributes","ObjectCreate","ObjectPrototype","abstractPropsArgs","containsAbstractSpreadAttribute","mayContainRefOrKey","attributesAssigned","spreadValue","setConfigProperty","astAttribute","argument","isPartialObject","spreadPropKey","push","makePartial","makeSimple","size","globalObj","$GlobalObject","objAssign","generator","createTemporalFromBuildFunction","methodNode","_args","callExpression"],"mappings":"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","file":"JSXElement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type {\n  BabelNode,\n  BabelNodeStringLiteral,\n  BabelNodeJSXText,\n  BabelNodeJSXElement,\n  BabelNodeJSXIdentifier,\n  BabelNodeJSXMemberExpression,\n  BabelNodeJSXAttribute,\n  BabelNodeJSXSpreadAttribute,\n  BabelNodeJSXExpressionContainer,\n} from \"babel-types\";\nimport {\n  AbstractObjectValue,\n  ArrayValue,\n  StringValue,\n  Value,\n  NumberValue,\n  ObjectValue,\n  FunctionValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport { convertJSXExpressionToIdentifier } from \"../react/jsx.js\";\nimport * as t from \"babel-types\";\nimport { Get } from \"../methods/index.js\";\nimport { Create, Environment, Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport { createReactElement } from \"../react/elements.js\";\nimport { objectHasNoPartialKeyAndRef, deleteRefAndKeyFromProps } from \"../react/utils.js\";\n\n// taken from Babel\nfunction cleanJSXElementLiteralChild(child: string): null | string {\n  let lines = child.split(/\\r\\n|\\n|\\r/);\n\n  let lastNonEmptyLine = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].match(/[^ \\t]/)) {\n      lastNonEmptyLine = i;\n    }\n  }\n\n  let str = \"\";\n\n  for (let i = 0; i < lines.length; i++) {\n    let line = lines[i];\n\n    let isFirstLine = i === 0;\n    let isLastLine = i === lines.length - 1;\n    let isLastNonEmptyLine = i === lastNonEmptyLine;\n\n    // replace rendered whitespace tabs with spaces\n    let trimmedLine = line.replace(/\\t/g, \" \");\n\n    // trim whitespace touching a newline\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^[ ]+/, \"\");\n    }\n\n    // trim whitespace touching an endline\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/[ ]+$/, \"\");\n    }\n\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n\n      str += trimmedLine;\n    }\n  }\n\n  if (str) {\n    return str;\n  }\n  return null;\n}\n\nfunction evaluateJSXMemberExpression(\n  ast: BabelNode,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  switch (ast.type) {\n    case \"JSXIdentifier\":\n      return Environment.GetValue(\n        realm,\n        Environment.ResolveBinding(realm, ((ast: any): BabelNodeJSXIdentifier).name, strictCode, env)\n      );\n    case \"JSXMemberExpression\":\n      return Environment.GetValue(\n        realm,\n        env.evaluate(convertJSXExpressionToIdentifier(((ast: any): BabelNodeJSXMemberExpression)), strictCode)\n      );\n    default:\n      invariant(false, \"Unknown JSX Identifier\");\n  }\n}\n\nfunction evaluateJSXIdentifier(ast, strictCode, env, realm): Value {\n  if (isTagName(ast)) {\n    // special cased lower-case and custom elements\n    return new StringValue(realm, ((ast: any): BabelNodeJSXIdentifier).name);\n  }\n  return evaluateJSXMemberExpression(ast, strictCode, env, realm);\n}\n\nfunction evaluateJSXValue(value: BabelNode, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  if (value != null) {\n    switch (value.type) {\n      case \"JSXText\":\n        return new StringValue(realm, ((value: any): BabelNodeJSXText).value);\n      case \"StringLiteral\":\n        return new StringValue(realm, ((value: any): BabelNodeStringLiteral).value);\n      case \"JSXExpressionContainer\":\n        return Environment.GetValue(\n          realm,\n          env.evaluate(((value: any): BabelNodeJSXExpressionContainer).expression, strictCode)\n        );\n      case \"JSXElement\":\n        return Environment.GetValue(realm, env.evaluate(value, strictCode));\n      default:\n        invariant(false, `Unknown JSX value type: ${value.type}`);\n    }\n  }\n  invariant(false, `Null or undefined value passed when trying to evaluate JSX node value`);\n}\n\nfunction isTagName(ast: BabelNode): boolean {\n  return ast.type === \"JSXIdentifier\" && /^[a-z]|\\-/.test(((ast: any): BabelNodeJSXIdentifier).name);\n}\n\nfunction evaluateJSXChildren(\n  children: Array<BabelNode>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ArrayValue | Value {\n  if (children.length === 0) {\n    return realm.intrinsics.undefined;\n  }\n  if (children.length === 1) {\n    let singleChild = evaluateJSXValue(children[0], strictCode, env, realm);\n\n    if (singleChild instanceof StringValue) {\n      let text = cleanJSXElementLiteralChild(singleChild.value);\n      if (text !== null) {\n        singleChild.value = text;\n      }\n    }\n    return singleChild;\n  }\n  let array = Create.ArrayCreate(realm, 0);\n  let dynamicChildrenLength = children.length;\n  let dynamicIterator = 0;\n  let lastChildValue = realm.intrinsics.undefined;\n  for (let i = 0; i < children.length; i++) {\n    let value = evaluateJSXValue(children[i], strictCode, env, realm);\n    if (value instanceof StringValue) {\n      let text = cleanJSXElementLiteralChild(value.value);\n      if (text === null) {\n        dynamicChildrenLength--;\n        // this is a space full of whitespace, so let's proceed\n        continue;\n      } else {\n        value.value = text;\n      }\n    }\n    lastChildValue = value;\n    Create.CreateDataPropertyOrThrow(realm, array, \"\" + dynamicIterator, value);\n    dynamicIterator++;\n  }\n  if (dynamicChildrenLength === 1) {\n    return lastChildValue;\n  }\n\n  Properties.Set(realm, array, \"length\", new NumberValue(realm, dynamicChildrenLength), false);\n  return array;\n}\n\nfunction isObjectEmpty(object: ObjectValue) {\n  let propertyCount = 0;\n  for (let [, binding] of object.properties) {\n    if (binding && binding.descriptor && binding.descriptor.enumerable) {\n      propertyCount++;\n    }\n  }\n  return propertyCount === 0;\n}\n\nfunction evaluateJSXAttributes(\n  astAttributes: Array<BabelNodeJSXAttribute | BabelNodeJSXSpreadAttribute>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ObjectValue | AbstractValue {\n  let config = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n  // start by having key and ref deleted, if they actually exist, they will be added later\n  deleteRefAndKeyFromProps(realm, config);\n  let abstractPropsArgs = [];\n  let containsAbstractSpreadAttribute = false;\n  let mayContainRefOrKey = false;\n  let attributesAssigned = 0;\n  let spreadValue;\n\n  const setConfigProperty = (name: string, value: Value): void => {\n    invariant(config instanceof ObjectValue);\n    if (name === \"key\" || name === \"ref\") {\n      mayContainRefOrKey = true;\n    }\n    Properties.Set(realm, config, name, value, true);\n    attributesAssigned++;\n  };\n\n  for (let astAttribute of astAttributes) {\n    switch (astAttribute.type) {\n      case \"JSXAttribute\":\n        let { name, value } = astAttribute;\n\n        invariant(name.type === \"JSXIdentifier\", `JSX attribute name type not supported: ${astAttribute.type}`);\n        setConfigProperty(name.name, evaluateJSXValue(((value: any): BabelNodeJSXIdentifier), strictCode, env, realm));\n        break;\n      case \"JSXSpreadAttribute\":\n        spreadValue = Environment.GetValue(realm, env.evaluate(astAttribute.argument, strictCode));\n\n        if (spreadValue instanceof ObjectValue && !spreadValue.isPartialObject()) {\n          for (let [spreadPropKey, binding] of spreadValue.properties) {\n            if (binding && binding.descriptor && binding.descriptor.enumerable) {\n              setConfigProperty(spreadPropKey, Get(realm, spreadValue, spreadPropKey));\n            }\n          }\n        } else {\n          containsAbstractSpreadAttribute = true;\n          invariant(spreadValue instanceof AbstractValue || spreadValue instanceof ObjectValue);\n\n          if (!objectHasNoPartialKeyAndRef(realm, spreadValue)) {\n            mayContainRefOrKey = true;\n          }\n          if (!isObjectEmpty(config)) {\n            abstractPropsArgs.push(config);\n          }\n          abstractPropsArgs.push(spreadValue);\n          config = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n          deleteRefAndKeyFromProps(realm, config);\n        }\n        break;\n      default:\n        invariant(false, `Unknown JSX attribute type: ${astAttribute.type}`);\n    }\n  }\n\n  if (containsAbstractSpreadAttribute) {\n    // if we haven't assigned any attributes and we are dealing with a single\n    // spread attribute, we can just make the spread object the props\n    if (\n      attributesAssigned === 0 &&\n      ((spreadValue instanceof ObjectValue && spreadValue.isPartialObject()) || spreadValue instanceof AbstractValue)\n    ) {\n      // the spread is partial, so we can re-use that value\n      config = spreadValue;\n      if (config instanceof ObjectValue || config instanceof AbstractObjectValue) {\n        // as we're applying a spread, the config needs to be simple/partial\n        config.makePartial();\n        config.makeSimple();\n      }\n    } else {\n      // we create an abstract Object.assign() to deal with the fact that we don't what\n      // the props are because they contain abstract spread attributes that we can't\n      // evaluate ahead of time\n      // push the current config\n      if (config.properties.size > 0) {\n        abstractPropsArgs.push(config);\n      }\n      // create a new config object that will be the target of the Object.assign\n      config = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n      // as this is \"config that is abstract, we need to make it partial and simple\n      config.makePartial();\n      config.makeSimple();\n      // get the global Object.assign\n      let globalObj = Get(realm, realm.$GlobalObject, \"Object\");\n      invariant(globalObj instanceof ObjectValue);\n      let objAssign = Get(realm, globalObj, \"assign\");\n      invariant(realm.generator);\n\n      invariant(realm.generator);\n      AbstractValue.createTemporalFromBuildFunction(\n        realm,\n        FunctionValue,\n        [objAssign, config, ...abstractPropsArgs],\n        ([methodNode, ..._args]) => {\n          return t.callExpression(methodNode, ((_args: any): Array<any>));\n        }\n      );\n      if (!mayContainRefOrKey) {\n        deleteRefAndKeyFromProps(realm, config);\n      }\n    }\n  }\n  invariant(config instanceof ObjectValue || config instanceof AbstractValue);\n  return config;\n}\n\nexport default function(\n  ast: BabelNodeJSXElement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ObjectValue {\n  invariant(realm.react.enabled, \"JSXElements can only be evaluated with the reactEnabled option\");\n  let openingElement = ast.openingElement;\n  let type = evaluateJSXIdentifier(openingElement.name, strictCode, env, realm);\n  let children = evaluateJSXChildren(ast.children, strictCode, env, realm);\n  let config = evaluateJSXAttributes(openingElement.attributes, strictCode, env, realm);\n  invariant(type instanceof Value);\n  return createReactElement(realm, type, config, children);\n}\n"]}