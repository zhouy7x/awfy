{"version":3,"sources":["../../src/evaluators/UnaryExpression.js"],"names":["ast","strictCode","env","realm","expr","evaluate","argument","operator","evaluateDeleteOperation","isInPureScope","tryToEvaluateOperationOrLeaveAsAbstract","evaluateOperation","isInstance","proto","Constructor","prototype","ref","intrinsics","true","IsUnresolvableReference","IsStrictReference","IsPropertyReference","IsSuperReference","createErrorThrowCompletion","ReferenceError","base","GetBase","baseObj","ToObject","deleteStatus","$Delete","GetReferencedName","TypeError","bindings","referencedName","DeleteBinding","func","effects","evaluateForEffects","error","evaluateWithPossibleThrowCompletion","value","GetValue","createFromUnaryOp","topVal","completion","composeWithSavedCompletion","applyEffects","reportError","loc","handleError","IsToNumberPure","createFromNumberValue","ToNumber","oldValue","isNaN","NaN","ToInt32","ToBoolean","false","undefined","val","getType"],"mappings":"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","file":"UnaryExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport {\n  AbstractObjectValue,\n  Value,\n  BooleanValue,\n  ConcreteValue,\n  NumberValue,\n  IntegralValue,\n  StringValue,\n  UndefinedValue,\n  NullValue,\n  SymbolValue,\n  ObjectValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport { Reference, EnvironmentRecord } from \"../environment.js\";\nimport invariant from \"../invariant.js\";\nimport { IsCallable } from \"../methods/index.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport type { BabelNodeUnaryExpression } from \"babel-types\";\n\nfunction isInstance(proto, Constructor): boolean {\n  return proto instanceof Constructor || proto === Constructor.prototype;\n}\n\nfunction evaluateDeleteOperation(expr: Value | Reference, realm: Realm) {\n  // ECMA262 12.5.3.2\n\n  // 1. Let ref be the result of evaluating UnaryExpression.\n  let ref = expr;\n\n  // 2. ReturnIfAbrupt(ref).\n\n  // 3. If Type(ref) is not Reference, return true.\n  if (!(ref instanceof Reference)) return realm.intrinsics.true;\n\n  // 4. If IsUnresolvableReference(ref) is true, then\n  if (Environment.IsUnresolvableReference(realm, ref)) {\n    // a. Assert: IsStrictReference(ref) is false.\n    invariant(!Environment.IsStrictReference(realm, ref), \"did not expect a strict reference\");\n\n    // b. Return true.\n    return realm.intrinsics.true;\n  }\n\n  // 5. If IsPropertyReference(ref) is true, then\n  if (Environment.IsPropertyReference(realm, ref)) {\n    // a. If IsSuperReference(ref) is true, throw a ReferenceError exception.\n    if (Environment.IsSuperReference(realm, ref)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // b. Let baseObj be ! ToObject(GetBase(ref)).\n    let base = Environment.GetBase(realm, ref);\n    // Constructing the reference checks that base is coercible to an object hence\n    invariant(base instanceof ConcreteValue || base instanceof AbstractObjectValue);\n    let baseObj = base instanceof ConcreteValue ? To.ToObject(realm, base) : base;\n\n    // c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).\n    let deleteStatus = baseObj.$Delete(Environment.GetReferencedName(realm, ref));\n\n    // d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.\n    if (!deleteStatus && Environment.IsStrictReference(realm, ref)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // e. Return deleteStatus.\n    return new BooleanValue(realm, deleteStatus);\n  }\n\n  // 6. Else ref is a Reference to an Environment Record binding,\n  // a. Let bindings be GetBase(ref).\n  let bindings = Environment.GetBase(realm, ref);\n  invariant(bindings instanceof EnvironmentRecord);\n\n  // b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).\n  let referencedName = Environment.GetReferencedName(realm, ref);\n  invariant(typeof referencedName === \"string\");\n  return new BooleanValue(realm, bindings.DeleteBinding(referencedName));\n}\n\nfunction tryToEvaluateOperationOrLeaveAsAbstract(\n  ast: BabelNodeUnaryExpression,\n  expr: Value | Reference,\n  func: (ast: BabelNodeUnaryExpression, expr: Value | Reference, strictCode: boolean, realm: Realm) => Value,\n  strictCode: boolean,\n  realm: Realm\n) {\n  let effects;\n  try {\n    effects = realm.evaluateForEffects(() => func(ast, expr, strictCode, realm));\n  } catch (error) {\n    if (error instanceof FatalError) {\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => {\n          let value = Environment.GetValue(realm, expr);\n\n          // if the value is abstract, then create a unary op for it,\n          // otherwise we rethrow the error as we don't handle it at this\n          // point in time\n          if (value instanceof AbstractValue) {\n            return AbstractValue.createFromUnaryOp(realm, ast.operator, value);\n          }\n          throw error;\n        },\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    } else {\n      throw error;\n    }\n  }\n  let completion = effects[0];\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(effects);\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value);\n  return completion;\n}\n\nfunction evaluateOperation(\n  ast: BabelNodeUnaryExpression,\n  expr: Value | Reference,\n  strictCode: boolean,\n  realm: Realm\n): Value {\n  function reportError() {\n    let error = new CompilerDiagnostic(\n      \"might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method\",\n      ast.argument.loc,\n      \"PP0008\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(error) === \"Fail\") throw new FatalError();\n  }\n\n  if (ast.operator === \"+\") {\n    // ECMA262 12.5.6.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Return ? ToNumber(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!To.IsToNumberPure(realm, value)) reportError();\n      return AbstractValue.createFromUnaryOp(realm, \"+\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n\n    return IntegralValue.createFromNumberValue(realm, To.ToNumber(realm, value));\n  } else if (ast.operator === \"-\") {\n    // ECMA262 12.5.7.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!To.IsToNumberPure(realm, value)) reportError();\n      return AbstractValue.createFromUnaryOp(realm, \"-\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n    let oldValue = To.ToNumber(realm, value);\n\n    // 3. If oldValue is NaN, return NaN.\n    if (isNaN(oldValue)) {\n      return realm.intrinsics.NaN;\n    }\n\n    // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.\n    return IntegralValue.createFromNumberValue(realm, -oldValue);\n  } else if (ast.operator === \"~\") {\n    // ECMA262 12.5.8\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToInt32(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!To.IsToNumberPure(realm, value)) reportError();\n      return AbstractValue.createFromUnaryOp(realm, \"~\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n    let oldValue = To.ToInt32(realm, value);\n\n    // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.\n    return IntegralValue.createFromNumberValue(realm, ~oldValue);\n  } else if (ast.operator === \"!\") {\n    // ECMA262 12.6.9\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ToBoolean(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) return AbstractValue.createFromUnaryOp(realm, \"!\", value);\n    invariant(value instanceof ConcreteValue);\n    let oldValue = To.ToBoolean(realm, value);\n\n    // 3. If oldValue is true, return false.\n    if (oldValue === true) return realm.intrinsics.false;\n\n    // 4. Return true.\n    return realm.intrinsics.true;\n  } else if (ast.operator === \"void\") {\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Perform ? GetValue(expr).\n    Environment.GetValue(realm, expr);\n\n    // 3. Return undefined.\n    return realm.intrinsics.undefined;\n  } else {\n    invariant(ast.operator === \"typeof\");\n    // ECMA262 12.6.5\n\n    // 1. Let val be the result of evaluating UnaryExpression.\n    let val = expr;\n\n    // 2. If Type(val) is Reference, then\n    if (val instanceof Reference) {\n      // a. If IsUnresolvableReference(val) is true, return \"undefined\".\n      if (Environment.IsUnresolvableReference(realm, val)) {\n        return new StringValue(realm, \"undefined\");\n      }\n    }\n\n    // 3. Let val be ? GetValue(val).\n    val = Environment.GetValue(realm, val);\n\n    // 4. Return a String according to Table 35.\n    let proto = val.getType().prototype;\n    if (isInstance(proto, UndefinedValue)) {\n      return new StringValue(realm, \"undefined\");\n    } else if (isInstance(proto, NullValue)) {\n      return new StringValue(realm, \"object\");\n    } else if (isInstance(proto, StringValue)) {\n      return new StringValue(realm, \"string\");\n    } else if (isInstance(proto, BooleanValue)) {\n      return new StringValue(realm, \"boolean\");\n    } else if (isInstance(proto, NumberValue)) {\n      return new StringValue(realm, \"number\");\n    } else if (isInstance(proto, SymbolValue)) {\n      return new StringValue(realm, \"symbol\");\n    } else if (isInstance(proto, ObjectValue)) {\n      if (IsCallable(realm, val)) {\n        return new StringValue(realm, \"function\");\n      }\n      return new StringValue(realm, \"object\");\n    } else {\n      invariant(val instanceof AbstractValue);\n      return AbstractValue.createFromUnaryOp(realm, \"typeof\", val);\n    }\n  }\n}\n\nexport default function(\n  ast: BabelNodeUnaryExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  let expr = env.evaluate(ast.argument, strictCode);\n\n  if (ast.operator === \"delete\") {\n    return evaluateDeleteOperation(expr, realm);\n  }\n  if (realm.isInPureScope()) {\n    return tryToEvaluateOperationOrLeaveAsAbstract(ast, expr, evaluateOperation, strictCode, realm);\n  } else {\n    return evaluateOperation(ast, expr, strictCode, realm);\n  }\n}\n"]}