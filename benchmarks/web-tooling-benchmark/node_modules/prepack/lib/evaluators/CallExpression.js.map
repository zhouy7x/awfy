{"version":3,"sources":["../../src/evaluators/CallExpression.js"],"names":["ast","strictCode","env","realm","callee","type","arguments","setNextExecutionContextLocation","loc","ref","evaluate","func","GetValue","EvaluateCall","t","callBothFunctionsAndJoinTheirEffects","args","cond","func1","func2","getType","isTypeCompatibleWith","compl1","gen1","bindings1","properties1","createdObj1","evaluateForEffects","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","joinEffects","completion","composeWithSavedCompletion","applyEffects","generateRuntimeCall","thisArg","propName","base","referencedName","undefined","push","concat","arg","value","resultType","functionResultType","createTemporalFromBuildFunction","nodes","callFunc","argStart","isValidIdentifier","memberExpression","identifier","stringLiteral","fun_args","slice","callExpression","tryToEvaluateCallOrLeaveAsAbstract","thisValue","tailCall","effects","error","evaluateWithPossibleThrowCompletion","topVal","property","isInPureScope","handleError","kind","IsPropertyReference","GetReferencedName","intrinsics","eval","argList","length","evalText","strictCaller","evalRealm","PerformEval","refEnv","GetBase","WithBaseObject","thisCall"],"mappings":"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","file":"CallExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { EnvironmentRecord } from \"../environment.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { Value } from \"../values/index.js\";\nimport { AbstractValue, AbstractObjectValue, BooleanValue, ConcreteValue, FunctionValue } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { Environment, Functions, Havoc, Join } from \"../singletons.js\";\nimport {\n  ArgumentListEvaluation,\n  EvaluateDirectCall,\n  GetThisValue,\n  IsInTailPosition,\n  SameValue,\n} from \"../methods/index.js\";\nimport type { BabelNodeCallExpression, BabelNodeExpression, BabelNodeSpreadElement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\nimport SuperCall from \"./SuperCall\";\n\nexport default function(\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (ast.callee.type === \"Super\") {\n    return SuperCall(ast.arguments, strictCode, env, realm);\n  }\n\n  // ECMA262 12.3.4.1\n  realm.setNextExecutionContextLocation(ast.loc);\n\n  // 1. Let ref be the result of evaluating MemberExpression.\n  let ref = env.evaluate(ast.callee, strictCode);\n\n  // 2. Let func be ? GetValue(ref).\n  let func = Environment.GetValue(realm, ref);\n\n  return EvaluateCall(ref, func, ast, strictCode, env, realm);\n}\n\nfunction callBothFunctionsAndJoinTheirEffects(\n  args: Array<Value>,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  let [cond, func1, func2] = args;\n  invariant(cond instanceof AbstractValue && cond.getType() === BooleanValue);\n  invariant(Value.isTypeCompatibleWith(func1.getType(), FunctionValue));\n  invariant(Value.isTypeCompatibleWith(func2.getType(), FunctionValue));\n\n  let [compl1, gen1, bindings1, properties1, createdObj1] = realm.evaluateForEffects(() =>\n    EvaluateCall(func1, func1, ast, strictCode, env, realm)\n  );\n\n  let [compl2, gen2, bindings2, properties2, createdObj2] = realm.evaluateForEffects(() =>\n    EvaluateCall(func2, func2, ast, strictCode, env, realm)\n  );\n\n  let joinedEffects = Join.joinEffects(\n    realm,\n    cond,\n    [compl1, gen1, bindings1, properties1, createdObj1],\n    [compl2, gen2, bindings2, properties2, createdObj2]\n  );\n  let completion = joinedEffects[0];\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value);\n  return completion;\n}\n\nfunction generateRuntimeCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n) {\n  let args = [func];\n  let [thisArg, propName] = ref instanceof Reference ? [ref.base, ref.referencedName] : [];\n  if (thisArg instanceof Value) args = [thisArg];\n  if (propName !== undefined && typeof propName !== \"string\") args.push(propName);\n  args = args.concat(ArgumentListEvaluation(realm, strictCode, env, ast.arguments));\n  for (let arg of args) {\n    if (arg !== func) {\n      // Since we don't know which function we are calling, we assume that any unfrozen object\n      // passed as an argument has leaked to the environment and is henceforth in an unknown (havoced) state,\n      // as is any other object that is known to be reachable from this object.\n      // NB: Note that this is still optimistic, particularly if the environment exposes the same object\n      // to Prepack via alternative means, thus creating aliasing that is not tracked by Prepack.\n      Havoc.value(realm, arg, ast.loc);\n    }\n  }\n  let resultType = (func instanceof AbstractObjectValue ? func.functionResultType : undefined) || Value;\n  return AbstractValue.createTemporalFromBuildFunction(realm, resultType, args, nodes => {\n    let callFunc;\n    let argStart = 1;\n    if (thisArg instanceof Value) {\n      if (typeof propName === \"string\") {\n        callFunc = t.isValidIdentifier(propName)\n          ? t.memberExpression(nodes[0], t.identifier(propName), false)\n          : t.memberExpression(nodes[0], t.stringLiteral(propName), true);\n      } else {\n        callFunc = t.memberExpression(nodes[0], nodes[1], true);\n        argStart = 2;\n      }\n    } else {\n      callFunc = nodes[0];\n    }\n    let fun_args = ((nodes.slice(argStart): any): Array<BabelNodeExpression | BabelNodeSpreadElement>);\n    return t.callExpression(callFunc, fun_args);\n  });\n}\n\nfunction tryToEvaluateCallOrLeaveAsAbstract(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  thisValue: Value,\n  tailCall: boolean\n): Value {\n  let effects;\n  try {\n    effects = realm.evaluateForEffects(() =>\n      EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall)\n    );\n  } catch (error) {\n    if (error instanceof FatalError) {\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => generateRuntimeCall(ref, func, ast, strictCode, env, realm),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    } else {\n      throw error;\n    }\n  }\n  let completion = effects[0];\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in effects, but are tracked separately inside completion.\n  realm.applyEffects(effects);\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value);\n  return completion;\n}\n\nfunction EvaluateCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (func instanceof AbstractValue) {\n    let loc = ast.callee.type === \"MemberExpression\" ? ast.callee.property.loc : ast.callee.loc;\n    if (!Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n      if (!realm.isInPureScope()) {\n        // If this is not a function, this call might throw which can change the state of the program.\n        // If this is called from a pure function we handle it using evaluateWithPossiblyAbruptCompletion.\n        let error = new CompilerDiagnostic(\"might not be a function\", loc, \"PP0005\", \"RecoverableError\");\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n      }\n    } else if (func.kind === \"conditional\") {\n      return callBothFunctionsAndJoinTheirEffects(func.args, ast, strictCode, env, realm);\n    } else {\n      // Assume that it is a safe function. TODO #705: really?\n    }\n    if (realm.isInPureScope()) {\n      // In pure functions we allow abstract functions to throw, which this might.\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => generateRuntimeCall(ref, func, ast, strictCode, env, realm),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    }\n    return generateRuntimeCall(ref, func, ast, strictCode, env, realm);\n  }\n  invariant(func instanceof ConcreteValue);\n\n  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n  if (\n    ref instanceof Reference &&\n    !Environment.IsPropertyReference(realm, ref) &&\n    Environment.GetReferencedName(realm, ref) === \"eval\"\n  ) {\n    // a. If SameValue(func, %eval%) is true, then\n    if (SameValue(realm, func, realm.intrinsics.eval)) {\n      // i. Let argList be ? ArgumentListEvaluation(Arguments).\n      let argList = ArgumentListEvaluation(realm, strictCode, env, ast.arguments);\n      // ii. If argList has no elements, return undefined.\n      if (argList.length === 0) return realm.intrinsics.undefined;\n      // iii. Let evalText be the first element of argList.\n      let evalText = argList[0];\n      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.\n      let strictCaller = strictCode;\n      // v. Let evalRealm be the current Realm Record.\n      let evalRealm = realm;\n      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      if (evalText instanceof AbstractValue) {\n        let loc = ast.arguments[0].loc;\n        let error = new CompilerDiagnostic(\"eval argument must be a known value\", loc, \"PP0006\", \"RecoverableError\");\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n        // Assume that it is a safe eval with no visible heap changes or abrupt control flow.\n        return generateRuntimeCall(ref, func, ast, strictCode, env, realm);\n      }\n      return Functions.PerformEval(realm, evalText, evalRealm, strictCaller, true);\n    }\n  }\n\n  let thisValue;\n\n  // 4. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = Environment.GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 5. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 6. Let thisCall be this CallExpression.\n  let thisCall = ast;\n\n  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)\n  let tailCall = IsInTailPosition(realm, thisCall);\n\n  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).\n  if (realm.isInPureScope()) {\n    return tryToEvaluateCallOrLeaveAsAbstract(ref, func, ast, strictCode, env, realm, thisValue, tailCall);\n  } else {\n    return EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall);\n  }\n}\n"]}