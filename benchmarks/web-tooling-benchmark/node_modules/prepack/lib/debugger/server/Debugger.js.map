{"version":3,"sources":["../../../src/debugger/server/Debugger.js"],"names":["DebugServer","constructor","channel","realm","_channel","_realm","_breakpointManager","_variableManager","_stepManager","_stopEventManager","waitForRun","undefined","ast","keepRunning","request","readIn","processDebuggerCommand","checkForActions","_checkAndUpdateLastExecuted","stoppables","getAndDeleteCompletedSteppers","breakpoint","getStoppableBreakpoint","push","reason","getDebuggeeStopReason","loc","source","sendStoppedResponse","start","line","column","requestID","id","command","args","arguments","BREAKPOINT_ADD_COMMAND","kind","addBreakpointMulti","breakpoints","sendBreakpointsAcknowledge","BREAKPOINT_ADD_ACKNOWLEDGE","BREAKPOINT_REMOVE_COMMAND","removeBreakpointMulti","BREAKPOINT_REMOVE_ACKNOWLEDGE","BREAKPOINT_ENABLE_COMMAND","enableBreakpointMulti","BREAKPOINT_ENABLE_ACKNOWLEDGE","BREAKPOINT_DISABLE_COMMAND","disableBreakpointMulti","BREAKPOINT_DISABLE_ACKNOWLEDGE","PREPACK_RUN_COMMAND","_onDebuggeeResume","STACKFRAMES_COMMAND","processStackframesCommand","SCOPES_COMMAND","processScopesCommand","VARIABLES_COMMAND","processVariablesCommand","STEPINTO_COMMAND","processStepCommand","STEPOVER_COMMAND","EVALUATE_COMMAND","processEvaluateCommand","frameInfos","_getFrameLocation","fileName","i","contextStack","length","frame","functionName","function","__originalName","frameInfo","sendStackframeResponse","frameId","stackIndex","context","scopes","lexicalEnv","lexicalEnvironment","scope","name","_getScopeName","environmentRecord","variablesReference","getReferenceForValue","expensive","parent","sendScopesResponse","envRec","$FunctionObject","variables","getVariablesByReference","sendVariablesResponse","evalResult","evaluate","expression","sendEvaluateResponse","clean","filePath","_lastExecuted","shutdown"],"mappings":"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","file":"Debugger.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { BreakpointManager } from \"./BreakpointManager.js\";\nimport type { BabelNode, BabelNodeSourceLocation } from \"babel-types\";\nimport invariant from \"../common/invariant.js\";\nimport type { DebugChannel } from \"./channel/DebugChannel.js\";\nimport { DebugMessage } from \"./../common/channel/DebugMessage.js\";\nimport { DebuggerError } from \"./../common/DebuggerError.js\";\nimport type {\n  DebuggerRequest,\n  StackframeArguments,\n  ScopesArguments,\n  Stackframe,\n  Scope,\n  VariablesArguments,\n  EvaluateArguments,\n  SourceData,\n} from \"./../common/types.js\";\nimport type { Realm } from \"./../../realm.js\";\nimport { ExecutionContext } from \"./../../realm.js\";\nimport { VariableManager } from \"./VariableManager.js\";\nimport { SteppingManager } from \"./SteppingManager.js\";\nimport type { StoppableObject } from \"./StopEventManager.js\";\nimport { StopEventManager } from \"./StopEventManager.js\";\nimport {\n  EnvironmentRecord,\n  GlobalEnvironmentRecord,\n  FunctionEnvironmentRecord,\n  DeclarativeEnvironmentRecord,\n  ObjectEnvironmentRecord,\n} from \"./../../environment.js\";\n\nexport class DebugServer {\n  constructor(channel: DebugChannel, realm: Realm) {\n    this._channel = channel;\n    this._realm = realm;\n    this._breakpointManager = new BreakpointManager();\n    this._variableManager = new VariableManager(realm);\n    this._stepManager = new SteppingManager(this._realm, /* default discard old steppers */ false);\n    this._stopEventManager = new StopEventManager();\n    this.waitForRun(undefined);\n  }\n  // the collection of breakpoints\n  _breakpointManager: BreakpointManager;\n  // the channel to communicate with the adapter\n  _channel: DebugChannel;\n  _realm: Realm;\n  _variableManager: VariableManager;\n  _stepManager: SteppingManager;\n  _stopEventManager: StopEventManager;\n  _lastExecuted: SourceData;\n\n  /* Block until adapter says to run\n  /* ast: the current ast node we are stopped on\n  /* reason: the reason the debuggee is stopping\n  */\n  waitForRun(ast: void | BabelNode) {\n    let keepRunning = false;\n    let request;\n    while (!keepRunning) {\n      request = this._channel.readIn();\n      keepRunning = this.processDebuggerCommand(request, ast);\n    }\n  }\n\n  // Checking if the debugger needs to take any action on reaching this ast node\n  checkForActions(ast: BabelNode) {\n    if (this._checkAndUpdateLastExecuted(ast)) {\n      let stoppables: Array<StoppableObject> = this._stepManager.getAndDeleteCompletedSteppers(ast);\n      let breakpoint = this._breakpointManager.getStoppableBreakpoint(ast);\n      if (breakpoint) stoppables.push(breakpoint);\n      let reason = this._stopEventManager.getDebuggeeStopReason(ast, stoppables);\n      if (reason) {\n        invariant(ast.loc && ast.loc.source);\n        this._channel.sendStoppedResponse(reason, ast.loc.source, ast.loc.start.line, ast.loc.start.column);\n        this.waitForRun(ast);\n      }\n    }\n  }\n\n  // Process a command from a debugger. Returns whether Prepack should unblock\n  // if it is blocked\n  processDebuggerCommand(request: DebuggerRequest, ast: void | BabelNode) {\n    let requestID = request.id;\n    let command = request.command;\n    let args = request.arguments;\n    switch (command) {\n      case DebugMessage.BREAKPOINT_ADD_COMMAND:\n        invariant(args.kind === \"breakpoint\");\n        this._breakpointManager.addBreakpointMulti(args.breakpoints);\n        this._channel.sendBreakpointsAcknowledge(DebugMessage.BREAKPOINT_ADD_ACKNOWLEDGE, requestID, args);\n        break;\n      case DebugMessage.BREAKPOINT_REMOVE_COMMAND:\n        invariant(args.kind === \"breakpoint\");\n        this._breakpointManager.removeBreakpointMulti(args.breakpoints);\n        this._channel.sendBreakpointsAcknowledge(DebugMessage.BREAKPOINT_REMOVE_ACKNOWLEDGE, requestID, args);\n        break;\n      case DebugMessage.BREAKPOINT_ENABLE_COMMAND:\n        invariant(args.kind === \"breakpoint\");\n        this._breakpointManager.enableBreakpointMulti(args.breakpoints);\n        this._channel.sendBreakpointsAcknowledge(DebugMessage.BREAKPOINT_ENABLE_ACKNOWLEDGE, requestID, args);\n        break;\n      case DebugMessage.BREAKPOINT_DISABLE_COMMAND:\n        invariant(args.kind === \"breakpoint\");\n        this._breakpointManager.disableBreakpointMulti(args.breakpoints);\n        this._channel.sendBreakpointsAcknowledge(DebugMessage.BREAKPOINT_DISABLE_ACKNOWLEDGE, requestID, args);\n        break;\n      case DebugMessage.PREPACK_RUN_COMMAND:\n        invariant(args.kind === \"run\");\n        this._onDebuggeeResume();\n        return true;\n      case DebugMessage.STACKFRAMES_COMMAND:\n        invariant(args.kind === \"stackframe\");\n        this.processStackframesCommand(requestID, args, ast);\n        break;\n      case DebugMessage.SCOPES_COMMAND:\n        invariant(args.kind === \"scopes\");\n        this.processScopesCommand(requestID, args);\n        break;\n      case DebugMessage.VARIABLES_COMMAND:\n        invariant(args.kind === \"variables\");\n        this.processVariablesCommand(requestID, args);\n        break;\n      case DebugMessage.STEPINTO_COMMAND:\n        invariant(ast !== undefined);\n        this._stepManager.processStepCommand(\"in\", ast);\n        this._onDebuggeeResume();\n        return true;\n      case DebugMessage.STEPOVER_COMMAND:\n        invariant(ast !== undefined);\n        this._stepManager.processStepCommand(\"over\", ast);\n        this._onDebuggeeResume();\n        return true;\n      case DebugMessage.EVALUATE_COMMAND:\n        invariant(args.kind === \"evaluate\");\n        this.processEvaluateCommand(requestID, args);\n        break;\n      default:\n        throw new DebuggerError(\"Invalid command\", \"Invalid command from adapter: \" + command);\n    }\n    return false;\n  }\n\n  processStackframesCommand(requestID: number, args: StackframeArguments, ast: void | BabelNode) {\n    let frameInfos: Array<Stackframe> = [];\n    let loc = this._getFrameLocation(ast ? ast.loc : null);\n    let fileName = loc.fileName;\n    let line = loc.line;\n    let column = loc.column;\n\n    // the UI displays the current frame as index 0, so we iterate backwards\n    // from the current frame\n    for (let i = this._realm.contextStack.length - 1; i >= 0; i--) {\n      let frame = this._realm.contextStack[i];\n      let functionName = \"(anonymous function)\";\n      if (frame.function && frame.function.__originalName) {\n        functionName = frame.function.__originalName;\n      }\n\n      let frameInfo: Stackframe = {\n        id: this._realm.contextStack.length - 1 - i,\n        functionName: functionName,\n        fileName: fileName,\n        line: line,\n        column: column,\n      };\n      frameInfos.push(frameInfo);\n      loc = this._getFrameLocation(frame.loc);\n      fileName = loc.fileName;\n      line = loc.line;\n      column = loc.column;\n    }\n    this._channel.sendStackframeResponse(requestID, frameInfos);\n  }\n\n  _getFrameLocation(loc: void | null | BabelNodeSourceLocation): { fileName: string, line: number, column: number } {\n    let fileName = \"unknown\";\n    let line = 0;\n    let column = 0;\n    if (loc && loc.source) {\n      fileName = loc.source;\n      line = loc.start.line;\n      column = loc.start.column;\n    }\n    return {\n      fileName: fileName,\n      line: line,\n      column: column,\n    };\n  }\n\n  processScopesCommand(requestID: number, args: ScopesArguments) {\n    // first check that frameId is in the valid range\n    if (args.frameId < 0 || args.frameId >= this._realm.contextStack.length) {\n      throw new DebuggerError(\"Invalid command\", \"Invalid frame id for scopes request: \" + args.frameId);\n    }\n    // here the frameId is in reverse order of the contextStack, ie frameId 0\n    // refers to last element of contextStack\n    let stackIndex = this._realm.contextStack.length - 1 - args.frameId;\n    let context = this._realm.contextStack[stackIndex];\n    invariant(context instanceof ExecutionContext);\n    let scopes = [];\n    let lexicalEnv = context.lexicalEnvironment;\n    while (lexicalEnv) {\n      let scope: Scope = {\n        name: this._getScopeName(lexicalEnv.environmentRecord),\n        // key used by UI to retrieve variables in this scope\n        variablesReference: this._variableManager.getReferenceForValue(lexicalEnv),\n        // the variables are easy to retrieve\n        expensive: false,\n      };\n      scopes.push(scope);\n      lexicalEnv = lexicalEnv.parent;\n    }\n    this._channel.sendScopesResponse(requestID, scopes);\n  }\n\n  _getScopeName(envRec: EnvironmentRecord): string {\n    if (envRec instanceof GlobalEnvironmentRecord) {\n      return \"Global\";\n    } else if (envRec instanceof DeclarativeEnvironmentRecord) {\n      if (envRec instanceof FunctionEnvironmentRecord) {\n        return \"Local: \" + (envRec.$FunctionObject.__originalName || \"anonymous function\");\n      } else {\n        return \"Block\";\n      }\n    } else if (envRec instanceof ObjectEnvironmentRecord) {\n      return \"With\";\n    } else {\n      invariant(false, \"Invalid type of environment record\");\n    }\n  }\n\n  processVariablesCommand(requestID: number, args: VariablesArguments) {\n    let variables = this._variableManager.getVariablesByReference(args.variablesReference);\n    this._channel.sendVariablesResponse(requestID, variables);\n  }\n\n  processEvaluateCommand(requestID: number, args: EvaluateArguments) {\n    let evalResult = this._variableManager.evaluate(args.frameId, args.expression);\n    this._channel.sendEvaluateResponse(requestID, evalResult);\n  }\n\n  // actions that need to happen before Prepack can resume\n  _onDebuggeeResume() {\n    // resets the variable manager\n    this._variableManager.clean();\n  }\n\n  _checkAndUpdateLastExecuted(ast: BabelNode): boolean {\n    if (ast.loc && ast.loc.source) {\n      let filePath = ast.loc.source;\n      let line = ast.loc.start.line;\n      let column = ast.loc.start.column;\n      // check if the current location is same as the last one\n      if (\n        this._lastExecuted &&\n        filePath === this._lastExecuted.filePath &&\n        line === this._lastExecuted.line &&\n        column === this._lastExecuted.column\n      ) {\n        return false;\n      }\n      this._lastExecuted = {\n        filePath: filePath,\n        line: line,\n        column: column,\n      };\n      return true;\n    }\n    return false;\n  }\n\n  shutdown() {\n    // clean the channel pipes\n    this._channel.shutdown();\n  }\n}\n"]}