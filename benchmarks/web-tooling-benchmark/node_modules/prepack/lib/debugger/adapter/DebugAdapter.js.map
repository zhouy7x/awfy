{"version":3,"sources":["../../../src/debugger/adapter/DebugAdapter.js"],"names":["DebugProtocol","PrepackDebugSession","constructor","setDebuggerLinesStartAt1","setDebuggerColumnsStartAt1","_generateDebugFilePath","direction","time","Date","now","filePath","_registerMessageCallbacks","_adapterChannel","registerChannelEvent","STOPPED_RESPONSE","response","result","kind","sendEvent","reason","line","column","PREPACK_THREAD_ID","STEPINTO_RESPONSE","initializeRequest","args","_clientID","clientID","body","supportsConfigurationDoneRequest","sendResponse","configurationDoneRequest","CLI_CLIENTID","run","DEFAULT_REQUEST_ID","runResponse","launchRequest","inFilePath","outFilePath","launchArgs","sourceFile","prepackRuntime","prepackArguments","debugInFilePath","debugOutFilePath","outputCallback","data","outputEvent","toString","exitCallback","process","exit","launch","request_seq","dbgResponse","continueRequest","setBreakPointsRequest","source","path","breakpoints","breakpointInfos","breakpoint","breakpointInfo","requestID","push","setBreakpoints","verified","stackTraceRequest","getStackFrames","frameInfos","stackframes","frames","frameInfo","fileName","frame","id","name","functionName","stackFrames","threadsRequest","thread","threads","scopesRequest","getScopes","frameId","scopeInfos","scopes","scopeInfo","scope","variablesReference","expensive","variablesRequest","getVariables","variableInfos","variables","varInfo","variable","value","stepInRequest","stepInto","nextRequest","stepOver","evaluateRequest","evaluate","expression","evalResult","displayValue","type"],"mappings":"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","file":"DebugAdapter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { DebugSession, InitializedEvent, OutputEvent, TerminatedEvent, StoppedEvent } from \"vscode-debugadapter\";\nimport * as DebugProtocol from \"vscode-debugprotocol\";\nimport { AdapterChannel } from \"./channel/AdapterChannel.js\";\nimport invariant from \"./../common/invariant.js\";\nimport { DebugMessage } from \"./../common/channel/DebugMessage.js\";\nimport type {\n  Breakpoint,\n  DebuggerResponse,\n  LaunchRequestArguments,\n  PrepackLaunchArguments,\n} from \"./../common/types.js\";\nimport { DebuggerConstants } from \"./../common/DebuggerConstants.js\";\n\n/* An implementation of an debugger adapter adhering to the VSCode Debug protocol\n * The adapter is responsible for communication between the UI and Prepack\n*/\nclass PrepackDebugSession extends DebugSession {\n  /**\n   * Creates a new debug adapter that is used for one debug session.\n   * We configure the default implementation of a debug adapter here.\n   */\n  constructor() {\n    super();\n    this.setDebuggerLinesStartAt1(true);\n    this.setDebuggerColumnsStartAt1(true);\n  }\n  _clientID: void | string;\n  _adapterChannel: AdapterChannel;\n\n  _generateDebugFilePath(direction: \"in\" | \"out\") {\n    let time = Date.now();\n    let filePath = \"/tmp/\";\n    if (direction === \"in\") {\n      filePath += `prepack-debug-engine2adapter-${time}.txt`;\n    } else {\n      filePath += `prepack-debug-adapter2engine-${time}.txt`;\n    }\n    return filePath;\n  }\n\n  _registerMessageCallbacks() {\n    this._adapterChannel.registerChannelEvent(DebugMessage.STOPPED_RESPONSE, (response: DebuggerResponse) => {\n      let result = response.result;\n      invariant(result.kind === \"stopped\");\n      this.sendEvent(\n        new StoppedEvent(\n          `${result.reason}: ${result.filePath} ${result.line}:${result.column}`,\n          DebuggerConstants.PREPACK_THREAD_ID\n        )\n      );\n    });\n    this._adapterChannel.registerChannelEvent(DebugMessage.STEPINTO_RESPONSE, (response: DebuggerResponse) => {\n      let result = response.result;\n      invariant(result.kind === \"stepInto\");\n      this.sendEvent(\n        new StoppedEvent(\n          \"Stepped into \" + `${result.filePath} ${result.line}:${result.column}`,\n          DebuggerConstants.PREPACK_THREAD_ID\n        )\n      );\n    });\n  }\n\n  /**\n   * The 'initialize' request is the first request called by the UI\n   * to interrogate the features the debug adapter provides.\n   */\n  // Override\n  initializeRequest(response: DebugProtocol.InitializeResponse, args: DebugProtocol.InitializeRequestArguments): void {\n    // Let the UI know that we can start accepting breakpoint requests.\n    // The UI will end the configuration sequence by calling 'configurationDone' request.\n    this.sendEvent(new InitializedEvent());\n\n    this._clientID = args.clientID;\n    response.body = response.body || {};\n    response.body.supportsConfigurationDoneRequest = true;\n    // Respond back to the UI with the configurations. Will add more configurations gradually as needed.\n    // Adapter can respond immediately here because no message is sent to Prepack\n    this.sendResponse(response);\n  }\n\n  // Override\n  configurationDoneRequest(\n    response: DebugProtocol.ConfigurationDoneResponse,\n    args: DebugProtocol.ConfigurationDoneArguments\n  ): void {\n    // initial handshake with UI is complete\n    if (this._clientID !== DebuggerConstants.CLI_CLIENTID) {\n      // for all ui except the CLI, autosend the first run request\n      this._adapterChannel.run(DebuggerConstants.DEFAULT_REQUEST_ID, (runResponse: DebuggerResponse) => {});\n    }\n    this.sendResponse(response);\n  }\n\n  // Override\n  launchRequest(response: DebugProtocol.LaunchResponse, args: LaunchRequestArguments): void {\n    let inFilePath = this._generateDebugFilePath(\"in\");\n    let outFilePath = this._generateDebugFilePath(\"out\");\n    // set up the communication channel\n    this._adapterChannel = new AdapterChannel(inFilePath, outFilePath);\n    this._registerMessageCallbacks();\n    let launchArgs: PrepackLaunchArguments = {\n      kind: \"launch\",\n      sourceFile: args.sourceFile,\n      prepackRuntime: args.prepackRuntime,\n      prepackArguments: args.prepackArguments,\n      debugInFilePath: inFilePath,\n      debugOutFilePath: outFilePath,\n      outputCallback: (data: Buffer) => {\n        let outputEvent = new OutputEvent(data.toString(), \"stdout\");\n        this.sendEvent(outputEvent);\n      },\n      exitCallback: () => {\n        this.sendEvent(new TerminatedEvent());\n        process.exit();\n      },\n    };\n    this._adapterChannel.launch(response.request_seq, launchArgs, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  /**\n   * Request Prepack to continue running when it is stopped\n  */\n  // Override\n  continueRequest(response: DebugProtocol.ContinueResponse, args: DebugProtocol.ContinueArguments): void {\n    // send a Run request to Prepack and try to send the next request\n    this._adapterChannel.run(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  setBreakPointsRequest(\n    response: DebugProtocol.SetBreakpointsResponse,\n    args: DebugProtocol.SetBreakpointsArguments\n  ): void {\n    if (!args.source.path || !args.breakpoints) return;\n    let filePath = args.source.path;\n    let breakpointInfos = [];\n    for (const breakpoint of args.breakpoints) {\n      let line = breakpoint.line;\n      let column = 0;\n      if (breakpoint.column) {\n        column = breakpoint.column;\n      }\n      let breakpointInfo: Breakpoint = {\n        kind: \"breakpoint\",\n        requestID: response.request_seq,\n        filePath: filePath,\n        line: line,\n        column: column,\n      };\n      breakpointInfos.push(breakpointInfo);\n    }\n    this._adapterChannel.setBreakpoints(response.request_seq, breakpointInfos, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"breakpoint-add\");\n      let breakpoints: Array<DebugProtocol.Breakpoint> = [];\n      for (const breakpointInfo of result.breakpoints) {\n        let source: DebugProtocol.Source = {\n          path: breakpointInfo.filePath,\n        };\n        let breakpoint: DebugProtocol.Breakpoint = {\n          verified: true,\n          source: source,\n          line: breakpointInfo.line,\n          column: breakpointInfo.column,\n        };\n        breakpoints.push(breakpoint);\n      }\n      response.body = {\n        breakpoints: breakpoints,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  stackTraceRequest(response: DebugProtocol.StackTraceResponse, args: DebugProtocol.StackTraceArguments): void {\n    this._adapterChannel.getStackFrames(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"stackframe\");\n      let frameInfos = result.stackframes;\n      let frames: Array<DebugProtocol.StackFrame> = [];\n      for (const frameInfo of frameInfos) {\n        let source: DebugProtocol.Source = {\n          path: frameInfo.fileName,\n        };\n        let frame: DebugProtocol.StackFrame = {\n          id: frameInfo.id,\n          name: frameInfo.functionName,\n          source: source,\n          line: frameInfo.line,\n          column: frameInfo.column,\n        };\n        frames.push(frame);\n      }\n      response.body = {\n        stackFrames: frames,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  threadsRequest(response: DebugProtocol.ThreadsResponse): void {\n    // There will only be 1 thread, so respond immediately\n    let thread: DebugProtocol.Thread = {\n      id: DebuggerConstants.PREPACK_THREAD_ID,\n      name: \"main\",\n    };\n    response.body = {\n      threads: [thread],\n    };\n    this.sendResponse(response);\n  }\n\n  // Override\n  scopesRequest(response: DebugProtocol.ScopesResponse, args: DebugProtocol.ScopesArguments): void {\n    this._adapterChannel.getScopes(response.request_seq, args.frameId, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"scopes\");\n      let scopeInfos = result.scopes;\n      let scopes: Array<DebugProtocol.Scope> = [];\n      for (const scopeInfo of scopeInfos) {\n        let scope: DebugProtocol.Scope = {\n          name: scopeInfo.name,\n          variablesReference: scopeInfo.variablesReference,\n          expensive: scopeInfo.expensive,\n        };\n        scopes.push(scope);\n      }\n      response.body = {\n        scopes: scopes,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  variablesRequest(response: DebugProtocol.VariablesResponse, args: DebugProtocol.VariablesArguments): void {\n    this._adapterChannel.getVariables(\n      response.request_seq,\n      args.variablesReference,\n      (dbgResponse: DebuggerResponse) => {\n        let result = dbgResponse.result;\n        invariant(result.kind === \"variables\");\n        let variableInfos = result.variables;\n        let variables: Array<DebugProtocol.Variable> = [];\n        for (const varInfo of variableInfos) {\n          let variable: DebugProtocol.Variable = {\n            name: varInfo.name,\n            value: varInfo.value,\n            variablesReference: varInfo.variablesReference,\n          };\n          variables.push(variable);\n        }\n        response.body = {\n          variables: variables,\n        };\n        this.sendResponse(response);\n      }\n    );\n  }\n\n  // Override\n  stepInRequest(response: DebugProtocol.StepInResponse, args: DebugProtocol.StepInArguments): void {\n    this._adapterChannel.stepInto(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  nextRequest(response: DebugProtocol.NextResponse, args: DebugProtocol.NextArguments): void {\n    this._adapterChannel.stepOver(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  evaluateRequest(response: DebugProtocol.EvaluateResponse, args: DebugProtocol.EvaluateArguments): void {\n    this._adapterChannel.evaluate(\n      response.request_seq,\n      args.frameId,\n      args.expression,\n      (dbgResponse: DebuggerResponse) => {\n        let evalResult = dbgResponse.result;\n        invariant(evalResult.kind === \"evaluate\");\n        response.body = {\n          result: evalResult.displayValue,\n          type: evalResult.type,\n          variablesReference: evalResult.variablesReference,\n        };\n        this.sendResponse(response);\n      }\n    );\n  }\n}\n\nDebugSession.run(PrepackDebugSession);\n"]}