{"version":3,"sources":["../../src/serializer/ResidualFunctionInitializers.js"],"names":["t","ResidualFunctionInitializers","constructor","locationService","prelude","initializerNameGenerator","functionInitializerInfos","Map","initializers","sharedInitializers","registerValueOnlyReferencedByResidualFunctions","functionValues","val","length","infos","functionValue","info","get","undefined","set","ownId","size","toString","initializerIds","Set","push","id","map","sort","join","add","initializer","order","values","body","type","parentBody","entries","done","scrubFunctionInitializers","delete","_conditionalInitialization","initializedValues","initializationStatements","isIfStatement","location","value","mightBeUndefined","getLocation","createLocation","unshift","expressionStatement","assignmentExpression","ifStatement","binaryExpression","blockStatement","hasInitializerStatement","factorifyInitializers","nameGenerator","getInitializerStatement","initializerInfo","ownInitializer","initializerId","i","j","concat","ast","count","file","program","node","identifier","generate","functionDeclaration","callExpression"],"mappings":"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","file":"ResidualFunctionInitializers.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { FunctionValue, Value } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeStatement } from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport invariant from \"../invariant.js\";\nimport { voidExpression, nullExpression } from \"../utils/internalizer.js\";\nimport type { LocationService, SerializedBody } from \"./types.js\";\nimport { factorifyObjects } from \"./factorify.js\";\n\n// This class manages information about values\n// which are only referenced by residual functions,\n// and it provides the ability to generate initialization code for those values that\n// can be placed into the residual functions.\nexport class ResidualFunctionInitializers {\n  constructor(\n    locationService: LocationService,\n    prelude: Array<BabelNodeStatement>,\n    initializerNameGenerator: NameGenerator\n  ) {\n    this.functionInitializerInfos = new Map();\n    this.initializers = new Map();\n    this.sharedInitializers = new Map();\n    this.locationService = locationService;\n    this.initializerNameGenerator = initializerNameGenerator;\n    this.prelude = prelude;\n  }\n\n  // ownId: uid of the FunctionValue, initializer ids are strings of sorted lists of FunctionValues referencing the value\n  functionInitializerInfos: Map<FunctionValue, { ownId: string, initializerIds: Set<string> }>;\n  initializers: Map<string, { id: string, order: number, body: SerializedBody, values: Array<Value> }>;\n  sharedInitializers: Map<string, BabelNodeStatement>;\n  locationService: LocationService;\n  prelude: Array<BabelNodeStatement>;\n  initializerNameGenerator: NameGenerator;\n\n  registerValueOnlyReferencedByResidualFunctions(functionValues: Array<FunctionValue>, val: Value): SerializedBody {\n    invariant(functionValues.length >= 1);\n    let infos = [];\n    for (let functionValue of functionValues) {\n      let info = this.functionInitializerInfos.get(functionValue);\n      if (info === undefined)\n        this.functionInitializerInfos.set(\n          functionValue,\n          (info = { ownId: this.functionInitializerInfos.size.toString(), initializerIds: new Set() })\n        );\n      infos.push(info);\n    }\n    let id = infos.map(info => info.ownId).sort().join();\n    for (let info of infos) info.initializerIds.add(id);\n    let initializer = this.initializers.get(id);\n    if (initializer === undefined)\n      this.initializers.set(\n        id,\n        (initializer = {\n          id,\n          order: infos.length,\n          values: [],\n          body: { type: \"DelayInitializations\", parentBody: undefined, entries: [], done: false },\n        })\n      );\n    initializer.values.push(val);\n    return initializer.body;\n  }\n\n  scrubFunctionInitializers() {\n    // Deleting trivial entries in order to avoid creating empty initialization functions that serve no purpose.\n    for (let initializer of this.initializers.values())\n      if (initializer.body.entries.length === 0) this.initializers.delete(initializer.id);\n    for (let [functionValue, info] of this.functionInitializerInfos) {\n      for (let id of info.initializerIds) {\n        let initializer = this.initializers.get(id);\n        if (initializer === undefined) {\n          info.initializerIds.delete(id);\n        }\n      }\n      if (info.initializerIds.size === 0) this.functionInitializerInfos.delete(functionValue);\n    }\n  }\n\n  _conditionalInitialization(\n    initializedValues: Array<Value>,\n    initializationStatements: Array<BabelNodeStatement>\n  ): BabelNodeStatement {\n    if (initializationStatements.length === 1 && t.isIfStatement(initializationStatements[0])) {\n      return initializationStatements[0];\n    }\n\n    // We have some initialization code, and it should only get executed once,\n    // so we are going to guard it.\n    // First, let's see if one of the initialized values is guaranteed to not\n    // be undefined after initialization. In that case, we can use that state-change\n    // to figure out if initialization needs to run.\n    let location;\n    for (let value of initializedValues) {\n      if (!value.mightBeUndefined()) {\n        location = this.locationService.getLocation(value);\n        if (location !== undefined) break;\n      }\n    }\n    if (location === undefined) {\n      // Second, if we didn't find a non-undefined value, let's make one up.\n      // It will transition from `undefined` to `null`.\n      location = this.locationService.createLocation();\n      initializationStatements.unshift(t.expressionStatement(t.assignmentExpression(\"=\", location, nullExpression)));\n    }\n    return t.ifStatement(\n      t.binaryExpression(\"===\", location, voidExpression),\n      t.blockStatement(initializationStatements)\n    );\n  }\n\n  hasInitializerStatement(functionValue: FunctionValue): boolean {\n    return !!this.functionInitializerInfos.get(functionValue);\n  }\n\n  factorifyInitializers(nameGenerator: NameGenerator) {\n    for (const initializer of this.initializers.values()) {\n      factorifyObjects(initializer.body.entries, nameGenerator);\n    }\n  }\n\n  getInitializerStatement(functionValue: FunctionValue): void | BabelNodeStatement {\n    let initializerInfo = this.functionInitializerInfos.get(functionValue);\n    if (initializerInfo === undefined) return undefined;\n\n    invariant(initializerInfo.initializerIds.size > 0);\n    let ownInitializer = this.initializers.get(initializerInfo.ownId);\n    let initializedValues;\n    let initializationStatements = [];\n    let initializers = [];\n    for (let initializerId of initializerInfo.initializerIds) {\n      let initializer = this.initializers.get(initializerId);\n      invariant(initializer !== undefined);\n      invariant(initializer.body.entries.length > 0);\n      initializers.push(initializer);\n    }\n    // Sorting initializers by the number of scopes they are required by.\n    // Note that the scope sets form a lattice, and this sorting effectively\n    // ensures that value initializers that depend on other value initializers\n    // get called in the right order.\n    initializers.sort((i, j) => j.order - i.order);\n    for (let initializer of initializers) {\n      if (initializerInfo.initializerIds.size === 1 || initializer === ownInitializer) {\n        initializedValues = initializer.values;\n      }\n      if (initializer === ownInitializer) {\n        initializationStatements = initializationStatements.concat(initializer.body.entries);\n      } else {\n        let ast = this.sharedInitializers.get(initializer.id);\n        if (ast === undefined) {\n          ast = this._conditionalInitialization(initializer.values, initializer.body.entries);\n          // We inline compact initializers, as calling a function would introduce too much\n          // overhead. To determine if an initializer is compact, we count the number of\n          // nodes in the AST, and check if it exceeds a certain threshold.\n          // TODO #885: Study in more detail which threshold is the best compromise in terms of\n          // code size and performance.\n          let count = 0;\n          traverseFast(t.file(t.program([ast])), node => {\n            count++;\n            return false;\n          });\n          if (count > 24) {\n            let id = t.identifier(this.initializerNameGenerator.generate());\n            this.prelude.push(t.functionDeclaration(id, [], t.blockStatement([ast])));\n            ast = t.expressionStatement(t.callExpression(id, []));\n          }\n          this.sharedInitializers.set(initializer.id, ast);\n        }\n        initializationStatements.push(ast);\n      }\n    }\n\n    return this._conditionalInitialization(initializedValues || [], initializationStatements);\n  }\n}\n"]}