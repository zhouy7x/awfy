{"version":3,"sources":["../../src/serializer/ResidualHeapVisitor.js"],"names":["t","ResidualHeapVisitor","constructor","realm","logger","modules","additionalFunctionValuesAndEffects","referentializer","useAbstractInterpretation","undefined","declarativeEnvironmentRecordsBindings","Map","globalBindings","functionInfos","classMethodInstances","functionInstances","values","generator","scope","commonScope","inspector","referencedDeclaredValues","delayedVisitGeneratorEntries","someReactElement","equivalenceSet","reactElementEquivalenceSet","additionalFunctionValueInfos","containingAdditionalFunction","additionalRoots","inClass","functionToCapturedScopes","generatorParents","_registerAdditionalRoot","value","additionalFunction","s","get","set","Set","add","_withScope","f","oldScope","visitObjectProperty","binding","desc","descriptor","obj","object","canIgnoreProperty","key","visitDescriptor","visitObjectProperties","kind","skipPrototype","symbol","propertyBinding","symbols","visitValue","propertyBindingKey","propertyBindingValue","properties","$FunctionKind","has","pathNode","unknownProperty","val","visitObjectPropertiesWithComputedNames","visitObjectPrototype","visitConstructorPrototype","proto","$Prototype","getKind","intrinsics","$IsClassPrototype","null","func","prototype","getPropertyValue","originalConstructor","isDefaultPrototype","absVal","args","length","cond","P","V","earlier_props","visitEquivalentValue","consequent","alternate","joinCondition","descriptor1","descriptor2","visitValueArray","lenProperty","isHavocedObject","evaluateWithoutLeakLogic","ToLength","visitValueMap","entries","$MapData","$WeakMapData","len","i","entry","$Key","$Value","visitValueSet","$SetData","$WeakSetData","visitValueFunction","parentScope","isClass","homeObject","$HomeObject","$BoundTargetFunction","$BoundThis","boundArg","$BoundArguments","formalParameters","$FormalParameters","code","$ECMAScriptCode","functionInfo","residualFunctionBindings","initializationStatements","functionValue","scopeInstances","unbound","modified","usesArguments","usesThis","state","tryQuery","bind","file","program","expressionStatement","functionExpression","isResidual","size","isUnsafeResidual","logError","loc","Object","keys","join","additionalFunctionEffects","_visitAdditionalFunction","innerName","residualBinding","visitBinding","_visitClass","_recordBindingVisitedAndRevisit","residualFunctionBinding","refScope","funcToScopes","envRec","declarativeEnvironmentRecord","bindingState","capturedBindings","capturingFunctionsToCommonScope","functionCommonScope","prevCommonScope","name","createBinding","doesNotMatter","reference","ResolveBinding","$Environment","getFromMap","map","defaultFn","IsUnresolvableReference","base","getGlobalLetBinding","referencedBase","referencedName","createdBinding","bindings","deletable","initialized","referencedOnlyFromAdditionalFunctions","classFunc","classPrototype","visitClassMethod","propertyNameOrSymbol","methodFunc","methodType","isStatic","_visitClassMethod","propertyName","method","$HasEmptyConstructor","visitClassProperty","constructorFunc","classSuperNode","classMethodIsStatic","classMethodKeyNode","classMethodComputed","$HasComputedName","visitValueObject","dateValue","$DateValue","buf","$ViewedArrayBuffer","$ParameterMap","react","enabled","fbLibraries","visitValueSymbol","$Description","visitValueProxy","$ProxyTarget","$ProxyHandler","visitAbstractValue","n","preProcessValue","_mark","postProcessValue","scopes","equivalentValue","equivalentReactElementValue","refuseSerialization","isIntrinsic","_isScopedTemplate","isLeaf","createGeneratorVisitCallbacks","visitValues","visitGenerator","parent","canSkip","recordDeclaration","recordDelayedEntry","push","visit","_visitEffects","additionalFunctionInfo","effects","result","modifiedBindings","modifiedProperties","createdObjects","intrinsicName","additionalBinding","previousValue","modifiedBinding","funcInstance","instance","newValue","additionalFunctionOverridesValue","additionalEffects","oldReactElementEquivalenceSet","oldcontainingAdditionalFunction","prevReVisit","modifiedBindingInfo","captures","withEffectsAppliedInGlobalEnv","createdObject","delete","additionalParentGenerators","visitRoots","moduleValue","initializedModules","_visitReactLibrary","oldDelayedEntries","entryGenerator","visitEntry","bodyToInstances","funcBody","instances","referentialize","reactLibraryObject","output","createElement","reactCreateElement"],"mappings":"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","file":"ResidualHeapVisitor.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { GlobalEnvironmentRecord, DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { Realm } from \"../realm.js\";\nimport type { Effects } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding, ObjectKind } from \"../types.js\";\nimport { HashSet, IsArray, Get } from \"../methods/index.js\";\nimport {\n  BoundFunctionValue,\n  ProxyValue,\n  SymbolValue,\n  AbstractValue,\n  EmptyValue,\n  ECMAScriptSourceFunctionValue,\n  FunctionValue,\n  Value,\n  ObjectValue,\n  AbstractObjectValue,\n  NativeFunctionValue,\n  UndefinedValue,\n} from \"../values/index.js\";\nimport { describeLocation } from \"../intrinsics/ecma262/Error.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeBlockStatement } from \"babel-types\";\nimport { Generator } from \"../utils/generator.js\";\nimport type { GeneratorEntry, VisitEntryCallbacks } from \"../utils/generator.js\";\nimport traverse from \"babel-traverse\";\nimport invariant from \"../invariant.js\";\nimport type {\n  ResidualFunctionBinding,\n  FunctionInfo,\n  AdditionalFunctionInfo,\n  FunctionInstance,\n  ClassMethodInstance,\n  AdditionalFunctionEffects,\n} from \"./types.js\";\nimport { ClosureRefVisitor } from \"./visitors.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { ResidualHeapInspector } from \"./ResidualHeapInspector.js\";\nimport { Referentializer } from \"./Referentializer.js\";\nimport type { ReferentializationScope } from \"./Referentializer.js\";\nimport {\n  getSuggestedArrayLiteralLength,\n  getOrDefault,\n  ClassPropertiesToIgnore,\n  withDescriptorValue,\n  canIgnoreClassLengthProperty,\n  getObjectPrototypeMetadata,\n} from \"./utils.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport { isReactElement, valueIsReactLibraryObject } from \"../react/utils.js\";\nimport { canHoistReactElement } from \"../react/hoisting.js\";\nimport ReactElementSet from \"../react/ReactElementSet.js\";\n\nexport type Scope = FunctionValue | Generator;\ntype BindingState = {|\n  capturedBindings: Set<ResidualFunctionBinding>,\n  capturingFunctionsToCommonScope: Map<FunctionValue, Scope>,\n|};\n\n/* This class visits all values that are reachable in the residual heap.\n   In particular, this \"filters out\" values that are:\n   - captured by a DeclarativeEnvironmentRecord, but not actually used by any closure.\n   - Unmodified prototype objects\n   TODO #680: Figure out minimal set of values that need to be kept alive for WeakSet and WeakMap instances.\n*/\nexport class ResidualHeapVisitor {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects>,\n    // Referentializer is null if we're just checking what values exist\n    referentializer: Referentializer | \"NO_REFERENTIALIZE\"\n  ) {\n    invariant(realm.useAbstractInterpretation);\n    this.realm = realm;\n    this.logger = logger;\n    this.modules = modules;\n    this.referentializer = referentializer === \"NO_REFERENTIALIZE\" ? undefined : referentializer;\n\n    this.declarativeEnvironmentRecordsBindings = new Map();\n    this.globalBindings = new Map();\n    this.functionInfos = new Map();\n    this.classMethodInstances = new Map();\n    this.functionInstances = new Map();\n    this.values = new Map();\n    let generator = this.realm.generator;\n    invariant(generator);\n    this.scope = this.commonScope = generator;\n    this.inspector = new ResidualHeapInspector(realm, logger);\n    this.referencedDeclaredValues = new Map();\n    this.delayedVisitGeneratorEntries = [];\n    this.someReactElement = undefined;\n    this.additionalFunctionValuesAndEffects = additionalFunctionValuesAndEffects;\n    this.equivalenceSet = new HashSet();\n    this.reactElementEquivalenceSet = new ReactElementSet(realm, this.equivalenceSet);\n    this.additionalFunctionValueInfos = new Map();\n    this.containingAdditionalFunction = undefined;\n    this.additionalRoots = new Map();\n    this.inClass = false;\n    this.functionToCapturedScopes = new Map();\n    this.generatorParents = new Map();\n  }\n\n  realm: Realm;\n  logger: Logger;\n  modules: Modules;\n  referentializer: Referentializer | void;\n\n  // Caches that ensure one ResidualFunctionBinding exists per (record, name) pair\n  declarativeEnvironmentRecordsBindings: Map<DeclarativeEnvironmentRecord, Map<string, ResidualFunctionBinding>>;\n  globalBindings: Map<string, ResidualFunctionBinding>;\n\n  functionToCapturedScopes: Map<ReferentializationScope, Map<DeclarativeEnvironmentRecord, BindingState>>;\n  functionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  scope: Scope;\n  // Either the realm's generator or the FunctionValue of an additional function to serialize\n  commonScope: Scope;\n  values: Map<Value, Set<Scope>>;\n  inspector: ResidualHeapInspector;\n  referencedDeclaredValues: Map<AbstractValue, void | FunctionValue>;\n  delayedVisitGeneratorEntries: Array<{| commonScope: Scope, generator: Generator, entry: GeneratorEntry |}>;\n  additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects>;\n  functionInstances: Map<FunctionValue, FunctionInstance>;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  equivalenceSet: HashSet<AbstractValue>;\n  classMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  someReactElement: void | ObjectValue;\n  reactElementEquivalenceSet: ReactElementSet;\n  generatorParents: Map<Generator, Generator>;\n\n  // We only want to add to additionalRoots when we're in an additional function\n  containingAdditionalFunction: void | FunctionValue;\n  // Tracks objects + functions that were visited from inside additional functions that need to be serialized in a\n  // parent scope of the additional function (e.g. functions/objects only used from additional functions that were\n  // declared outside the additional function need to be serialized in the additional function's parent scope for\n  // identity to work).\n  additionalRoots: Map<ObjectValue, Set<FunctionValue>>;\n  inClass: boolean;\n\n  _registerAdditionalRoot(value: ObjectValue) {\n    let additionalFunction = this.containingAdditionalFunction;\n    if (additionalFunction !== undefined && !this.inClass) {\n      let s = this.additionalRoots.get(value);\n      if (s === undefined) this.additionalRoots.set(value, (s = new Set()));\n      s.add(additionalFunction);\n    }\n  }\n\n  _withScope(scope: Scope, f: () => void) {\n    let oldScope = this.scope;\n    this.scope = scope;\n    try {\n      f();\n    } finally {\n      this.scope = oldScope;\n    }\n  }\n\n  visitObjectProperty(binding: PropertyBinding) {\n    let desc = binding.descriptor;\n    if (desc === undefined) return; //deleted\n    let obj = binding.object;\n    if (obj instanceof AbstractObjectValue || !this.inspector.canIgnoreProperty(obj, binding.key)) {\n      this.visitDescriptor(desc);\n    }\n  }\n\n  visitObjectProperties(obj: ObjectValue, kind?: ObjectKind): void {\n    let { skipPrototype, constructor } = getObjectPrototypeMetadata(this.realm, obj);\n\n    // visit properties\n    if (!isReactElement(obj)) {\n      for (let [symbol, propertyBinding] of obj.symbols) {\n        invariant(propertyBinding);\n        let desc = propertyBinding.descriptor;\n        if (desc === undefined) continue; //deleted\n        this.visitDescriptor(desc);\n        this.visitValue(symbol);\n      }\n    }\n\n    // visit properties\n    for (let [propertyBindingKey, propertyBindingValue] of obj.properties) {\n      // we don't want to visit these as we handle the serialization ourselves\n      // via a different logic route for classes\n      let descriptor = propertyBindingValue.descriptor;\n      if (\n        obj.$FunctionKind === \"classConstructor\" &&\n        (ClassPropertiesToIgnore.has(propertyBindingKey) ||\n          (propertyBindingKey === \"length\" && canIgnoreClassLengthProperty(obj, descriptor, this.logger)))\n      ) {\n        continue;\n      }\n      if (propertyBindingKey.pathNode !== undefined) continue; // property is written to inside a loop\n      invariant(propertyBindingValue);\n      this.visitObjectProperty(propertyBindingValue);\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        this.visitObjectPropertiesWithComputedNames(val);\n      }\n    }\n\n    // prototype\n    if (!isReactElement(obj) && !skipPrototype) {\n      // we don't want to the ReactElement prototype visited\n      // as this is contained within the JSXElement, otherwise\n      // they we be need to be emitted during serialization\n      this.visitObjectPrototype(obj);\n    }\n    if (obj instanceof FunctionValue) {\n      this.visitConstructorPrototype(constructor ? constructor : obj);\n    } else if (obj instanceof ObjectValue && skipPrototype && constructor) {\n      this.visitValue(constructor);\n    }\n  }\n\n  visitObjectPrototype(obj: ObjectValue) {\n    let proto = obj.$Prototype;\n\n    let kind = obj.getKind();\n    if (proto === this.realm.intrinsics[kind + \"Prototype\"]) return;\n\n    if (!obj.$IsClassPrototype || proto !== this.realm.intrinsics.null) {\n      this.visitValue(proto);\n    }\n  }\n\n  visitConstructorPrototype(func: Value) {\n    // If the original prototype object was mutated,\n    // request its serialization here as this might be observable by\n    // residual code.\n    invariant(func instanceof FunctionValue);\n    let prototype = ResidualHeapInspector.getPropertyValue(func, \"prototype\");\n    if (\n      prototype instanceof ObjectValue &&\n      prototype.originalConstructor === func &&\n      !this.inspector.isDefaultPrototype(prototype)\n    ) {\n      this.visitValue(prototype);\n    }\n  }\n\n  visitObjectPropertiesWithComputedNames(absVal: AbstractValue): void {\n    if (absVal.kind === \"widened property\") return;\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      invariant(P instanceof AbstractValue);\n      let V = absVal.args[1];\n      let earlier_props = absVal.args[2];\n      if (earlier_props instanceof AbstractValue) this.visitObjectPropertiesWithComputedNames(earlier_props);\n      this.visitValue(P);\n      this.visitValue(V);\n    } else {\n      // conditional assignment\n      absVal.args[0] = this.visitEquivalentValue(cond);\n      let consequent = absVal.args[1];\n      invariant(consequent instanceof AbstractValue);\n      let alternate = absVal.args[2];\n      invariant(alternate instanceof AbstractValue);\n      this.visitObjectPropertiesWithComputedNames(consequent);\n      this.visitObjectPropertiesWithComputedNames(alternate);\n    }\n  }\n\n  visitDescriptor(desc: Descriptor): void {\n    invariant(desc.value === undefined || desc.value instanceof Value);\n    if (desc.joinCondition !== undefined) {\n      desc.joinCondition = this.visitEquivalentValue(desc.joinCondition);\n      if (desc.descriptor1 !== undefined) this.visitDescriptor(desc.descriptor1);\n      if (desc.descriptor2 !== undefined) this.visitDescriptor(desc.descriptor2);\n      return;\n    }\n    if (desc.value !== undefined) desc.value = this.visitEquivalentValue(desc.value);\n    if (desc.get !== undefined) this.visitValue(desc.get);\n    if (desc.set !== undefined) this.visitValue(desc.set);\n  }\n\n  visitValueArray(val: ObjectValue): void {\n    this.visitObjectProperties(val);\n    const realm = this.realm;\n    let lenProperty;\n    if (val.isHavocedObject()) {\n      lenProperty = this.realm.evaluateWithoutLeakLogic(() => Get(realm, val, \"length\"));\n    } else {\n      lenProperty = Get(realm, val, \"length\");\n    }\n    if (\n      lenProperty instanceof AbstractValue ||\n      To.ToLength(realm, lenProperty) !== getSuggestedArrayLiteralLength(realm, val)\n    ) {\n      this.visitValue(lenProperty);\n    }\n  }\n\n  visitValueMap(val: ObjectValue): void {\n    let kind = val.getKind();\n\n    let entries;\n    if (kind === \"Map\") {\n      entries = val.$MapData;\n    } else {\n      invariant(kind === \"WeakMap\");\n      entries = val.$WeakMapData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined) continue;\n      this.visitValue(key);\n      this.visitValue(value);\n    }\n  }\n\n  visitValueSet(val: ObjectValue): void {\n    let kind = val.getKind();\n\n    let entries;\n    if (kind === \"Set\") {\n      entries = val.$SetData;\n    } else {\n      invariant(kind === \"WeakSet\");\n      entries = val.$WeakSetData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined) continue;\n      this.visitValue(entry);\n    }\n  }\n\n  visitValueFunction(val: FunctionValue, parentScope: Scope): void {\n    let isClass = false;\n\n    this._registerAdditionalRoot(val);\n    if (val.$FunctionKind === \"classConstructor\") {\n      invariant(val instanceof ECMAScriptSourceFunctionValue);\n      let homeObject = val.$HomeObject;\n      if (homeObject instanceof ObjectValue && homeObject.$IsClassPrototype) {\n        isClass = true;\n        this.inClass = true;\n      }\n    }\n    this.visitObjectProperties(val);\n    if (isClass && this.inClass) {\n      this.inClass = false;\n    }\n\n    if (val instanceof BoundFunctionValue) {\n      this.visitValue(val.$BoundTargetFunction);\n      this.visitValue(val.$BoundThis);\n      for (let boundArg of val.$BoundArguments) this.visitValue(boundArg);\n      return;\n    }\n\n    invariant(!(val instanceof NativeFunctionValue), \"all native function values should be intrinsics\");\n\n    invariant(val instanceof ECMAScriptSourceFunctionValue);\n    invariant(val.constructor === ECMAScriptSourceFunctionValue);\n    let formalParameters = val.$FormalParameters;\n    let code = val.$ECMAScriptCode;\n\n    let functionInfo = this.functionInfos.get(code);\n    let residualFunctionBindings = new Map();\n    this.functionInstances.set(val, {\n      residualFunctionBindings,\n      initializationStatements: [],\n      functionValue: val,\n      scopeInstances: new Map(),\n    });\n\n    if (!functionInfo) {\n      functionInfo = {\n        unbound: new Set(),\n        modified: new Set(),\n        usesArguments: false,\n        usesThis: false,\n      };\n      let state = {\n        tryQuery: this.logger.tryQuery.bind(this.logger),\n        val,\n        functionInfo,\n        realm: this.realm,\n      };\n\n      traverse(\n        t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])),\n        ClosureRefVisitor,\n        null,\n        state\n      );\n      this.functionInfos.set(code, functionInfo);\n\n      if (val.isResidual && functionInfo.unbound.size) {\n        if (!val.isUnsafeResidual) {\n          this.logger.logError(\n            val,\n            `residual function ${describeLocation(this.realm, val, undefined, code.loc) ||\n              \"(unknown)\"} refers to the following identifiers defined outside of the local scope: ${Object.keys(\n              functionInfo.unbound\n            ).join(\", \")}`\n          );\n        }\n      }\n    }\n\n    let additionalFunctionEffects = this.additionalFunctionValuesAndEffects.get(val);\n    if (additionalFunctionEffects) {\n      this._visitAdditionalFunction(val, additionalFunctionEffects, parentScope);\n    } else {\n      this._withScope(val, () => {\n        invariant(functionInfo);\n        for (let innerName of functionInfo.unbound) {\n          let residualBinding = this.visitBinding(val, innerName);\n          invariant(residualBinding !== undefined);\n          residualFunctionBindings.set(innerName, residualBinding);\n          if (functionInfo.modified.has(innerName)) {\n            residualBinding.modified = true;\n          }\n        }\n      });\n    }\n    if (isClass && val.$HomeObject instanceof ObjectValue) {\n      this._visitClass(val, val.$HomeObject);\n    }\n    this.functionInstances.set(val, {\n      residualFunctionBindings,\n      initializationStatements: [],\n      functionValue: val,\n      scopeInstances: new Map(),\n    });\n  }\n\n  // Addresses the case:\n  // let x = [];\n  // let y = [];\n  // function a() { x.push(\"hi\"); }\n  // function b() { y.push(\"bye\"); }\n  // function c() { return x.length + y.length; }\n  // Here we need to make sure that a and b both initialize x and y because x and y will be in the same\n  // captured scope because c captures both x and y.\n  _recordBindingVisitedAndRevisit(val: FunctionValue, residualFunctionBinding: ResidualFunctionBinding) {\n    let refScope = this.containingAdditionalFunction ? this.containingAdditionalFunction : \"GLOBAL\";\n    invariant(!(refScope instanceof Generator));\n    let funcToScopes = getOrDefault(this.functionToCapturedScopes, refScope, () => new Map());\n    let envRec = residualFunctionBinding.declarativeEnvironmentRecord;\n    invariant(envRec !== null);\n    let bindingState = getOrDefault(funcToScopes, envRec, () => ({\n      capturedBindings: new Set(),\n      capturingFunctionsToCommonScope: new Map(),\n    }));\n    // If the binding is new for this bindingState, have all functions capturing bindings from that scope visit it\n    if (!bindingState.capturedBindings.has(residualFunctionBinding)) {\n      if (residualFunctionBinding.value) {\n        invariant(this);\n        for (let [functionValue, functionCommonScope] of bindingState.capturingFunctionsToCommonScope) {\n          invariant(this);\n          let prevCommonScope = this.commonScope;\n          try {\n            this.commonScope = functionCommonScope;\n            let value = residualFunctionBinding.value;\n            this._withScope(functionValue, () => this.visitValue(value));\n          } finally {\n            this.commonScope = prevCommonScope;\n          }\n        }\n      }\n      bindingState.capturedBindings.add(residualFunctionBinding);\n    }\n    // If the function is new for this bindingState, visit all existent bindings in this scope\n    if (!bindingState.capturingFunctionsToCommonScope.has(val)) {\n      for (let residualBinding of bindingState.capturedBindings) {\n        if (residualBinding.value) this.visitValue(residualBinding.value);\n      }\n      bindingState.capturingFunctionsToCommonScope.set(val, this.commonScope);\n    }\n  }\n\n  // Visits a binding, if createBinding is true, will always return a ResidualFunctionBinding\n  // otherwise visits + returns the binding only if one already exists.\n  visitBinding(val: FunctionValue, name: string, createBinding: boolean = true): ResidualFunctionBinding | void {\n    let residualFunctionBinding;\n    let doesNotMatter = true;\n    let reference = this.logger.tryQuery(\n      () => Environment.ResolveBinding(this.realm, name, doesNotMatter, val.$Environment),\n      undefined\n    );\n    let getFromMap = createBinding ? getOrDefault : (map, key, defaultFn) => map.get(key);\n    if (\n      reference === undefined ||\n      Environment.IsUnresolvableReference(this.realm, reference) ||\n      reference.base instanceof GlobalEnvironmentRecord\n    ) {\n      // Global Binding\n      residualFunctionBinding = getFromMap(\n        this.globalBindings,\n        name,\n        () =>\n          ({\n            value: this.realm.getGlobalLetBinding(name),\n            modified: true,\n            declarativeEnvironmentRecord: null,\n          }: ResidualFunctionBinding)\n      );\n    } else {\n      // DeclarativeEnvironmentRecord binding\n      invariant(!Environment.IsUnresolvableReference(this.realm, reference));\n      let referencedBase = reference.base;\n      let referencedName: string = (reference.referencedName: any);\n      if (typeof referencedName !== \"string\") {\n        throw new FatalError(\"TODO: do not know how to visit reference with symbol\");\n      }\n      invariant(referencedBase instanceof DeclarativeEnvironmentRecord);\n      let residualFunctionBindings = getOrDefault(\n        this.declarativeEnvironmentRecordsBindings,\n        referencedBase,\n        () => new Map()\n      );\n      let createdBinding = !residualFunctionBindings.has(referencedName);\n      residualFunctionBinding = getFromMap(residualFunctionBindings, referencedName, (): ResidualFunctionBinding => {\n        invariant(referencedBase instanceof DeclarativeEnvironmentRecord);\n        let binding = referencedBase.bindings[referencedName];\n        invariant(!binding.deletable);\n        return {\n          value: (binding.initialized && binding.value) || this.realm.intrinsics.undefined,\n          modified: false,\n          declarativeEnvironmentRecord: referencedBase,\n        };\n      });\n      if (residualFunctionBinding) {\n        if (this.containingAdditionalFunction && createdBinding)\n          residualFunctionBinding.referencedOnlyFromAdditionalFunctions = this.containingAdditionalFunction;\n        if (!this.containingAdditionalFunction && residualFunctionBinding.referencedOnlyFromAdditionalFunctions)\n          delete residualFunctionBinding.referencedOnlyFromAdditionalFunctions;\n        this._recordBindingVisitedAndRevisit(val, residualFunctionBinding);\n      }\n    }\n    if (residualFunctionBinding && residualFunctionBinding.value) {\n      residualFunctionBinding.value = this.visitEquivalentValue(residualFunctionBinding.value);\n    }\n    return residualFunctionBinding;\n  }\n\n  _visitClass(classFunc: ECMAScriptSourceFunctionValue, classPrototype: ObjectValue): void {\n    let visitClassMethod = (propertyNameOrSymbol, methodFunc, methodType, isStatic) => {\n      if (methodFunc instanceof ECMAScriptSourceFunctionValue) {\n        // if the method does not have a $HomeObject, it's not a class method\n        if (methodFunc.$HomeObject !== undefined) {\n          if (methodFunc !== classFunc) {\n            this._visitClassMethod(methodFunc, methodType, classPrototype, !!isStatic);\n          }\n        }\n      }\n    };\n    for (let [propertyName, method] of classPrototype.properties) {\n      withDescriptorValue(propertyName, method.descriptor, visitClassMethod);\n    }\n    for (let [symbol, method] of classPrototype.symbols) {\n      withDescriptorValue(symbol, method.descriptor, visitClassMethod);\n    }\n\n    // handle class inheritance\n    if (!(classFunc.$Prototype instanceof NativeFunctionValue)) {\n      this.visitValue(classFunc.$Prototype);\n    }\n\n    if (classPrototype.properties.has(\"constructor\")) {\n      let constructor = classPrototype.properties.get(\"constructor\");\n\n      invariant(constructor !== undefined);\n      // check if the constructor was deleted, as it can't really be deleted\n      // it just gets set to empty (the default again)\n      if (constructor.descriptor === undefined) {\n        classFunc.$HasEmptyConstructor = true;\n      } else {\n        let visitClassProperty = (propertyNameOrSymbol, methodFunc, methodType) => {\n          visitClassMethod(propertyNameOrSymbol, methodFunc, methodType, true);\n        };\n        // check if we have any static methods we need to include\n        let constructorFunc = Get(this.realm, classPrototype, \"constructor\");\n        invariant(constructorFunc instanceof ObjectValue);\n        for (let [propertyName, method] of constructorFunc.properties) {\n          if (\n            !ClassPropertiesToIgnore.has(propertyName) &&\n            method.descriptor !== undefined &&\n            !(\n              propertyName === \"length\" && canIgnoreClassLengthProperty(constructorFunc, method.descriptor, this.logger)\n            )\n          ) {\n            withDescriptorValue(propertyName, method.descriptor, visitClassProperty);\n          }\n        }\n      }\n    }\n    this.classMethodInstances.set(classFunc, {\n      classPrototype,\n      methodType: \"constructor\",\n      classSuperNode: undefined,\n      classMethodIsStatic: false,\n      classMethodKeyNode: undefined,\n      classMethodComputed: false,\n    });\n  }\n\n  _visitClassMethod(\n    methodFunc: ECMAScriptSourceFunctionValue,\n    methodType: \"get\" | \"set\" | \"value\",\n    classPrototype: ObjectValue,\n    isStatic: boolean\n  ): void {\n    this.classMethodInstances.set(methodFunc, {\n      classPrototype,\n      methodType: methodType === \"value\" ? \"method\" : methodType,\n      classSuperNode: undefined,\n      classMethodIsStatic: isStatic,\n      classMethodKeyNode: undefined,\n      classMethodComputed: !!methodFunc.$HasComputedName,\n    });\n  }\n\n  visitValueObject(val: ObjectValue): void {\n    this._registerAdditionalRoot(val);\n    let kind = val.getKind();\n    this.visitObjectProperties(val, kind);\n\n    // If this object is a prototype object that was implicitly created by the runtime\n    // for a constructor, then we can obtain a reference to this object\n    // in a special way that's handled alongside function serialization.\n    let constructor = val.originalConstructor;\n    if (constructor !== undefined) {\n      this.visitValue(constructor);\n      return;\n    }\n\n    switch (kind) {\n      case \"RegExp\":\n      case \"Number\":\n      case \"String\":\n      case \"Boolean\":\n      case \"ArrayBuffer\":\n        return;\n      case \"ReactElement\":\n        this.someReactElement = val;\n        // check we can hoist a React Element\n        canHoistReactElement(this.realm, val, this);\n        return;\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        this.visitValue(dateValue);\n        return;\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        let buf = val.$ViewedArrayBuffer;\n        invariant(buf !== undefined);\n        this.visitValue(buf);\n        return;\n      case \"Map\":\n      case \"WeakMap\":\n        this.visitValueMap(val);\n        return;\n      case \"Set\":\n      case \"WeakSet\":\n        this.visitValueSet(val);\n        return;\n      default:\n        if (kind !== \"Object\") this.logger.logError(val, `Object of kind ${kind} is not supported in residual heap.`);\n        if (this.$ParameterMap !== undefined) {\n          this.logger.logError(val, `Arguments object is not supported in residual heap.`);\n        }\n        if (this.realm.react.enabled && valueIsReactLibraryObject(this.realm, val, this.logger)) {\n          this.realm.fbLibraries.react = val;\n        }\n        return;\n    }\n  }\n\n  visitValueSymbol(val: SymbolValue): void {\n    if (val.$Description) this.visitValue(val.$Description);\n  }\n\n  visitValueProxy(val: ProxyValue): void {\n    this.visitValue(val.$ProxyTarget);\n    this.visitValue(val.$ProxyHandler);\n  }\n\n  visitAbstractValue(val: AbstractValue): void {\n    if (val.kind === \"sentinel member expression\")\n      this.logger.logError(val, \"expressions of type o[p] are not yet supported for partially known o and unknown p\");\n    if (val.kind === \"sentinel ToObject\") this.logger.logError(val, \"Unknown object cannot be coerced to Object\");\n    for (let i = 0, n = val.args.length; i < n; i++) {\n      val.args[i] = this.visitEquivalentValue(val.args[i]);\n    }\n  }\n\n  // Overridable hook for pre-visiting the value.\n  // Return false will tell visitor to skip visiting children of this node.\n  preProcessValue(val: Value): boolean {\n    return this._mark(val);\n  }\n\n  // Overridable hook for post-visiting the value.\n  postProcessValue(val: Value) {}\n\n  _mark(val: Value): boolean {\n    let scopes = this.values.get(val);\n    if (scopes === undefined) this.values.set(val, (scopes = new Set()));\n    if (scopes.has(this.scope)) return false;\n    scopes.add(this.scope);\n    return true;\n  }\n\n  visitEquivalentValue<T: Value>(val: T): T {\n    if (val instanceof AbstractValue) {\n      let equivalentValue = this.equivalenceSet.add(val);\n      if (this.preProcessValue(equivalentValue)) this.visitAbstractValue(equivalentValue);\n      this.postProcessValue(equivalentValue);\n      return (equivalentValue: any);\n    }\n    if (val instanceof ObjectValue && isReactElement(val)) {\n      let equivalentReactElementValue = this.reactElementEquivalenceSet.add(val);\n      if (this._mark(equivalentReactElementValue)) this.visitValueObject(equivalentReactElementValue);\n      return (equivalentReactElementValue: any);\n    }\n    this.visitValue(val);\n    return val;\n  }\n\n  visitValue(val: Value): void {\n    invariant(!val.refuseSerialization);\n    if (val instanceof AbstractValue) {\n      if (this.preProcessValue(val)) this.visitAbstractValue(val);\n    } else if (val.isIntrinsic()) {\n      // All intrinsic values exist from the beginning of time...\n      // ...except for a few that come into existence as templates for abstract objects via executable code.\n      if (val._isScopedTemplate) this.preProcessValue(val);\n      else\n        this._withScope(this.commonScope, () => {\n          this.preProcessValue(val);\n        });\n    } else if (val instanceof EmptyValue) {\n      this.preProcessValue(val);\n    } else if (ResidualHeapInspector.isLeaf(val)) {\n      this.preProcessValue(val);\n    } else if (IsArray(this.realm, val)) {\n      invariant(val instanceof ObjectValue);\n      if (this.preProcessValue(val)) this.visitValueArray(val);\n    } else if (val instanceof ProxyValue) {\n      if (this.preProcessValue(val)) this.visitValueProxy(val);\n    } else if (val instanceof FunctionValue) {\n      // Function declarations should get hoisted in common scope so that instances only get allocated once\n      let parentScope = this.scope;\n      // Every function references itself through arguments, prevent the recursive double-visit\n      if (this.scope !== val && this.commonScope !== val)\n        this._withScope(this.commonScope, () => {\n          invariant(val instanceof FunctionValue);\n          if (this.preProcessValue(val)) this.visitValueFunction(val, parentScope);\n        });\n    } else if (val instanceof SymbolValue) {\n      if (this.preProcessValue(val)) this.visitValueSymbol(val);\n    } else {\n      invariant(val instanceof ObjectValue);\n\n      // Prototypes are reachable via function declarations, and those get hoisted, so we need to move\n      // prototype initialization to the common scope code as well.\n      if (val.originalConstructor !== undefined) {\n        this._withScope(this.commonScope, () => {\n          invariant(val instanceof ObjectValue);\n          if (this.preProcessValue(val)) this.visitValueObject(val);\n        });\n      } else {\n        if (this.preProcessValue(val)) this.visitValueObject(val);\n      }\n    }\n    this.postProcessValue(val);\n  }\n\n  createGeneratorVisitCallbacks(commonScope: Scope): VisitEntryCallbacks {\n    return {\n      visitValues: (values: Array<Value>) => {\n        for (let i = 0, n = values.length; i < n; i++) values[i] = this.visitEquivalentValue(values[i]);\n      },\n      visitGenerator: (generator, parent) => {\n        // TODO: The serializer assumes that each generator has a unique parent; however, in the presence of conditional exceptions that is not actually true.\n        // invariant(!this.generatorParents.has(generator));\n        this.generatorParents.set(generator, parent);\n        this.visitGenerator(generator);\n      },\n      canSkip: (value: AbstractValue): boolean => {\n        return !this.referencedDeclaredValues.has(value) && !this.values.has(value);\n      },\n      recordDeclaration: (value: AbstractValue) => {\n        this.referencedDeclaredValues.set(value, this.containingAdditionalFunction);\n      },\n      recordDelayedEntry: (generator, entry: GeneratorEntry) => {\n        this.delayedVisitGeneratorEntries.push({ commonScope, generator, entry });\n      },\n    };\n  }\n\n  visitGenerator(generator: Generator): void {\n    this._withScope(generator, () => {\n      generator.visit(this.createGeneratorVisitCallbacks(this.commonScope));\n    });\n  }\n\n  // result -- serialized as a return statement\n  // Generator -- visit all entries\n  // Bindings -- (modifications to named variables) only need to serialize bindings if they're\n  //             captured by a residual function\n  //          -- need to apply them and maybe need to revisit functions in ancestors to make sure\n  //             we don't overwrite anything they capture\n  // PropertyBindings -- (property modifications) visit any property bindings to pre-existing objects\n  // CreatedObjects -- should take care of itself\n  _visitEffects(additionalFunctionInfo: AdditionalFunctionInfo, effects: Effects) {\n    let functionValue = additionalFunctionInfo.functionValue;\n    invariant(functionValue instanceof ECMAScriptSourceFunctionValue);\n    let code = functionValue.$ECMAScriptCode;\n    let functionInfo = this.functionInfos.get(code);\n    invariant(functionInfo !== undefined);\n    let [result, , modifiedBindings, modifiedProperties, createdObjects] = effects;\n    for (let propertyBinding of modifiedProperties.keys()) {\n      let object = propertyBinding.object;\n      if (object instanceof ObjectValue && createdObjects.has(object)) continue; // Created Object's binding\n      if (object.refuseSerialization) continue; // modification to internal state\n      if (object.intrinsicName === \"global\") continue; // Avoid double-counting\n      this.visitObjectProperty(propertyBinding);\n    }\n    // Handing of ModifiedBindings\n    for (let [additionalBinding, previousValue] of modifiedBindings) {\n      let modifiedBinding = additionalBinding;\n      let residualBinding;\n      this._withScope(functionValue, () => {\n        // Also visit the original value of the binding\n        residualBinding = this.visitBinding(functionValue, modifiedBinding.name);\n        invariant(residualBinding !== undefined);\n        // named functions inside an additional function that have a global binding\n        // can be skipped, as we don't want them to bind to the global\n        if (\n          residualBinding.declarativeEnvironmentRecord === null &&\n          modifiedBinding.value instanceof ECMAScriptSourceFunctionValue\n        ) {\n          residualBinding = null;\n          return;\n        }\n        // Fixup the binding to have the correct value\n        // No previousValue means this is a binding for a nested function\n        if (previousValue && previousValue.value)\n          residualBinding.value = this.visitEquivalentValue(previousValue.value);\n        invariant(functionInfo !== undefined);\n        if (functionInfo.modified.has(modifiedBinding.name)) residualBinding.modified;\n      });\n      if (residualBinding === null) continue;\n      invariant(residualBinding);\n      let funcInstance = additionalFunctionInfo.instance;\n      invariant(funcInstance !== undefined);\n      funcInstance.residualFunctionBindings.set(modifiedBinding.name, residualBinding);\n      let newValue = modifiedBinding.value;\n      invariant(newValue);\n      this.visitValue(newValue);\n      residualBinding.modified = true;\n      // This should be enforced by checkThatFunctionsAreIndependent\n      invariant(\n        !residualBinding.additionalFunctionOverridesValue,\n        \"We should only have one additional function value modifying any given residual binding\"\n      );\n      if (previousValue && previousValue.value) residualBinding.additionalFunctionOverridesValue = functionValue;\n      additionalFunctionInfo.modifiedBindings.set(modifiedBinding, residualBinding);\n    }\n    invariant(result instanceof Value);\n    if (!(result instanceof UndefinedValue)) this.visitValue(result);\n  }\n\n  _visitAdditionalFunction(\n    functionValue: FunctionValue,\n    additionalEffects: AdditionalFunctionEffects,\n    parentScope: Scope\n  ) {\n    // Get Instance + Info\n    invariant(functionValue instanceof ECMAScriptSourceFunctionValue);\n    let code = functionValue.$ECMAScriptCode;\n    let functionInfo = this.functionInfos.get(code);\n    invariant(functionInfo !== undefined);\n    let funcInstance = this.functionInstances.get(functionValue);\n    invariant(funcInstance !== undefined);\n\n    // Set Visitor state\n    // Allows us to emit function declarations etc. inside of this additional\n    // function instead of adding them at global scope\n    let prevCommonScope = this.commonScope;\n    this.commonScope = functionValue;\n    let oldReactElementEquivalenceSet = this.reactElementEquivalenceSet;\n    this.reactElementEquivalenceSet = new ReactElementSet(this.realm, this.equivalenceSet);\n    let oldcontainingAdditionalFunction = this.containingAdditionalFunction;\n    this.containingAdditionalFunction = functionValue;\n    let prevReVisit = this.additionalRoots;\n    this.additionalRoots = new Map();\n\n    let modifiedBindingInfo = new Map();\n    let [, generator, , , createdObjects] = additionalEffects.effects;\n\n    invariant(funcInstance !== undefined);\n    invariant(functionInfo !== undefined);\n    let additionalFunctionInfo = {\n      functionValue,\n      captures: functionInfo.unbound,\n      modifiedBindings: modifiedBindingInfo,\n      instance: funcInstance,\n    };\n    this.additionalFunctionValueInfos.set(functionValue, additionalFunctionInfo);\n\n    this.realm.withEffectsAppliedInGlobalEnv((effects: Effects) => {\n      this.visitGenerator(generator);\n      // All modified properties and bindings should be accessible\n      // from its containing additional function scope.\n      this._withScope(functionValue, this._visitEffects.bind(this, additionalFunctionInfo, effects));\n      return this.realm.intrinsics.undefined;\n    }, additionalEffects.effects);\n    for (let createdObject of createdObjects) this.additionalRoots.delete(createdObject);\n\n    // Cleanup\n    this.commonScope = prevCommonScope;\n    this.reactElementEquivalenceSet = oldReactElementEquivalenceSet;\n    this._withScope(\n      parentScope,\n      // Re-visit any bindings corresponding to unbound values or values closed over from outside additional function\n      // they're serialized in the correct scope\n      () => {\n        invariant(functionInfo !== undefined);\n        invariant(funcInstance !== undefined);\n        for (let [value, additionalParentGenerators] of this.additionalRoots) {\n          // Populate old additionalRoots because we switched them out\n          prevReVisit.set(value, additionalParentGenerators);\n          this.visitValue(value);\n        }\n        for (let innerName of functionInfo.unbound) {\n          let residualBinding = this.visitBinding(functionValue, innerName, false);\n          if (residualBinding) {\n            funcInstance.residualFunctionBindings.set(innerName, residualBinding);\n            delete residualBinding.referencedOnlyFromAdditionalFunctions;\n          }\n        }\n        this.additionalRoots = prevReVisit;\n      }\n    );\n    this.containingAdditionalFunction = oldcontainingAdditionalFunction;\n  }\n\n  visitRoots(): void {\n    let generator = this.realm.generator;\n    invariant(generator);\n    this.visitGenerator(generator);\n    for (let moduleValue of this.modules.initializedModules.values()) this.visitValue(moduleValue);\n    if (this.realm.react.enabled && this.someReactElement !== undefined) {\n      this._visitReactLibrary(this.someReactElement);\n    }\n\n    // Do a fixpoint over all pure generator entries to make sure that we visit\n    // arguments of only BodyEntries that are required by some other residual value\n    let oldDelayedEntries = [];\n    while (oldDelayedEntries.length !== this.delayedVisitGeneratorEntries.length) {\n      oldDelayedEntries = this.delayedVisitGeneratorEntries;\n      this.delayedVisitGeneratorEntries = [];\n      for (let { commonScope, generator: entryGenerator, entry } of oldDelayedEntries) {\n        this.commonScope = commonScope;\n        this._withScope(entryGenerator, () => {\n          entryGenerator.visitEntry(entry, this.createGeneratorVisitCallbacks(commonScope));\n        });\n      }\n    }\n\n    let referentializer = this.referentializer;\n    if (referentializer !== undefined) {\n      let bodyToInstances = new Map();\n      for (let instance of this.functionInstances.values()) {\n        // TODO: do something for additional functions\n        if (!this.additionalFunctionValuesAndEffects.has(instance.functionValue)) {\n          let code = instance.functionValue.$ECMAScriptCode;\n          invariant(code !== undefined);\n          getOrDefault(bodyToInstances, code, () => []).push(instance);\n        }\n      }\n\n      for (let [funcBody, instances] of bodyToInstances) {\n        let functionInfo = this.functionInfos.get(funcBody);\n        invariant(functionInfo !== undefined);\n        referentializer.referentialize(\n          functionInfo.unbound,\n          instances,\n          instance => !this.additionalFunctionValuesAndEffects.has(instance.functionValue)\n        );\n      }\n    }\n  }\n\n  _visitReactLibrary(someReactElement: ObjectValue) {\n    // find and visit the React library\n    let reactLibraryObject = this.realm.fbLibraries.react;\n    if (this.realm.react.output === \"jsx\") {\n      // React might not be defined in scope, i.e. another library is using JSX\n      // we don't throw an error as we should support JSX stand-alone\n      if (reactLibraryObject !== undefined) {\n        this.visitValue(reactLibraryObject);\n      }\n    } else if (this.realm.react.output === \"create-element\") {\n      let logError = () => {\n        this.logger.logError(\n          someReactElement,\n          \"unable to visit createElement due to React not being referenced in scope\"\n        );\n      };\n      // createElement output needs React in scope\n      if (reactLibraryObject === undefined) {\n        logError();\n      } else {\n        invariant(reactLibraryObject instanceof ObjectValue);\n        let createElement = reactLibraryObject.properties.get(\"createElement\");\n        if (createElement === undefined || createElement.descriptor === undefined) {\n          logError();\n        } else {\n          let reactCreateElement = Get(this.realm, reactLibraryObject, \"createElement\");\n          this.visitValue(reactCreateElement);\n        }\n      }\n    }\n  }\n}\n"]}