{"version":3,"sources":["../../src/serializer/functions.js"],"names":["t","Functions","constructor","realm","functions","moduleTracer","writeEffects","Map","functionExpressions","_generateAdditionalFunctionCallsFromInput","additionalFunctions","fname","fun","fnameAst","expression","e","evaluateNodeForEffectsInGlobalEnv","undefined","ex","error","handleError","set","push","__generateAdditionalFunctionsMap","globalKey","recordedAdditionalFunctions","globalRecordedAdditionalFunctionsMap","modules","logger","tryQuery","$GlobalObject","intrinsics","funcId","getOwnPropertyKeysArray","property","properties","get","value","descriptor","config","rootComponent","validConfig","validRootComponent","_createAdditionalEffects","effects","transforms","_generateWriteEffectsForReactComponentTree","componentType","componentTreeState","evaluatedNode","additionalFunctionEffects","status","prototype","renderMethod","checkRootReactComponentTrees","statistics","react","recordedReactRootValues","componentRoot","reconciler","evaluatedRootNode","evaluatedRootNodes","hasEvaluatedRootNode","render","branchedComponentTrees","rootValue","branchRootValue","nested","branchComponentType","clearComponentTreeState","branchEffects","branchComponentTreeState","output","_generateAdditionalFunctionCallsFromDirective","calls","funcValue","callExpression","memberExpression","identifier","_callOfFunction","globalThis","$GlobalEnv","environmentRecord","WithBaseObject","call","$Call","numArgs","getLength","args","params","$FormalParameters","parameterId","isIdentifier","name","expressionLocation","bind","checkThatFunctionsAreIndependent","inputFunctions","concat","keys","evaluatePure","evaluateForEffectsInGlobalEnv","conflicts","fun1","fun1Name","intrinsicName","e1","location","fun2","reportWriteConflicts","size","diagnostic","values","getAdditionalFunctionValuesToEffects","pbs","call2","reportConflict","writtenObjects","Set","forEach","val","key","m","add","object","oldReportObjectGetOwnProperties","reportObjectGetOwnProperties","ob","currentLocation","has","oldReportPropertyAccess","reportPropertyAccess","pb"],"mappings":"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","file":"functions.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeCallExpression, BabelNodeSourceLocation } from \"babel-types\";\nimport { Completion, ThrowCompletion } from \"../completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport { type Effects, type PropertyBindings, Realm } from \"../realm.js\";\nimport type { PropertyBinding, ReactComponentTreeConfig } from \"../types.js\";\nimport { ignoreErrorsIn } from \"../utils/errors.js\";\nimport {\n  Value,\n  AbstractObjectValue,\n  FunctionValue,\n  ObjectValue,\n  AbstractValue,\n  ECMAScriptSourceFunctionValue,\n  UndefinedValue,\n} from \"../values/index.js\";\nimport { Get } from \"../methods/index.js\";\nimport { ModuleTracer } from \"../utils/modules.js\";\nimport buildTemplate from \"babel-template\";\nimport {\n  ReactStatistics,\n  type ReactSerializerState,\n  type AdditionalFunctionEffects,\n  type ReactEvaluatedNode,\n} from \"./types\";\nimport { Reconciler, type ComponentTreeState } from \"../react/reconcilation.js\";\nimport {\n  valueIsClassComponent,\n  convertSimpleClassComponentToFunctionalComponent,\n  convertFunctionalComponentToComplexClassComponent,\n  normalizeFunctionalComponentParamaters,\n  getComponentTypeFromRootValue,\n  valueIsKnownReactAbstraction,\n  evaluateComponentTreeBranch,\n  createReactEvaluatedNode,\n  getComponentName,\n  convertConfigObjectToReactComponentTreeConfig,\n} from \"../react/utils.js\";\nimport * as t from \"babel-types\";\nimport { createAbstractArgument } from \"../intrinsics/prepack/utils.js\";\n\nexport class Functions {\n  constructor(realm: Realm, functions: ?Array<string>, moduleTracer: ModuleTracer) {\n    this.realm = realm;\n    this.functions = functions;\n    this.moduleTracer = moduleTracer;\n    this.writeEffects = new Map();\n    this.functionExpressions = new Map();\n  }\n\n  realm: Realm;\n  functions: ?Array<string>;\n  // maps back from FunctionValue to the expression string\n  functionExpressions: Map<FunctionValue, string>;\n  moduleTracer: ModuleTracer;\n  writeEffects: Map<FunctionValue, AdditionalFunctionEffects>;\n\n  _generateAdditionalFunctionCallsFromInput(): Array<FunctionValue> {\n    // lookup functions\n    let additionalFunctions = [];\n    for (let fname of this.functions || []) {\n      let fun;\n      let fnameAst = buildTemplate(fname)({}).expression;\n      if (fnameAst) {\n        try {\n          let e = ignoreErrorsIn(this.realm, () => this.realm.evaluateNodeForEffectsInGlobalEnv(fnameAst));\n          fun = e ? e[0] : undefined;\n        } catch (ex) {\n          if (!(ex instanceof ThrowCompletion)) throw ex;\n        }\n      }\n      if (!(fun instanceof FunctionValue)) {\n        let error = new CompilerDiagnostic(\n          `Additional function ${fname} not defined in the global environment`,\n          null,\n          \"PP1001\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n      this.functionExpressions.set(fun, fname);\n      additionalFunctions.push(fun);\n    }\n    return additionalFunctions;\n  }\n\n  __generateAdditionalFunctionsMap(globalKey: string) {\n    let recordedAdditionalFunctions: Map<\n      ECMAScriptSourceFunctionValue | AbstractValue,\n      { funcId: string, config?: ReactComponentTreeConfig }\n    > = new Map();\n    let realm = this.realm;\n    let globalRecordedAdditionalFunctionsMap = this.moduleTracer.modules.logger.tryQuery(\n      () => Get(realm, realm.$GlobalObject, globalKey),\n      realm.intrinsics.undefined\n    );\n    invariant(globalRecordedAdditionalFunctionsMap instanceof ObjectValue);\n    for (let funcId of globalRecordedAdditionalFunctionsMap.getOwnPropertyKeysArray()) {\n      let property = globalRecordedAdditionalFunctionsMap.properties.get(funcId);\n      if (property) {\n        let value = property.descriptor && property.descriptor.value;\n\n        if (value instanceof ECMAScriptSourceFunctionValue) {\n          // additional function logic\n          recordedAdditionalFunctions.set(value, { funcId });\n          continue;\n        } else if (value instanceof ObjectValue) {\n          // React component tree logic\n          let config = Get(realm, value, \"config\");\n          let rootComponent = Get(realm, value, \"rootComponent\");\n          let validConfig = config instanceof ObjectValue || config === realm.intrinsics.undefined;\n          let validRootComponent =\n            rootComponent instanceof ECMAScriptSourceFunctionValue ||\n            (rootComponent instanceof AbstractValue && valueIsKnownReactAbstraction(this.realm, rootComponent));\n\n          if (validConfig && validRootComponent) {\n            recordedAdditionalFunctions.set(((rootComponent: any): ECMAScriptSourceFunctionValue | AbstractValue), {\n              funcId,\n              config: convertConfigObjectToReactComponentTreeConfig(\n                realm,\n                ((config: any): ObjectValue | UndefinedValue)\n              ),\n            });\n          }\n          continue;\n        }\n        realm.handleError(\n          new CompilerDiagnostic(\n            `Additional Function Value ${funcId} is an invalid value`,\n            undefined,\n            \"PP0001\",\n            \"FatalError\"\n          )\n        );\n        throw new FatalError(\"invalidf Additional Function value\");\n      }\n    }\n    return recordedAdditionalFunctions;\n  }\n\n  _createAdditionalEffects(effects: Effects): AdditionalFunctionEffects {\n    return {\n      effects,\n      transforms: [],\n    };\n  }\n\n  _generateWriteEffectsForReactComponentTree(\n    componentType: ECMAScriptSourceFunctionValue,\n    effects: Effects,\n    componentTreeState: ComponentTreeState,\n    evaluatedNode: ReactEvaluatedNode\n  ): void {\n    let additionalFunctionEffects = this._createAdditionalEffects(effects);\n    let value = effects[0];\n\n    if (value === this.realm.intrinsics.undefined) {\n      // if we get undefined, then this component tree failed and a message was already logged\n      // in the reconciler\n      return;\n    }\n    if (value instanceof Completion) {\n      // TODO we don't support this yet, but will do very soon\n      // to unblock work, we'll just return at this point right now\n      evaluatedNode.status = \"UNSUPPORTED_COMPLETION\";\n      return;\n    }\n    invariant(value instanceof Value);\n    if (valueIsClassComponent(this.realm, componentType)) {\n      if (componentTreeState.status === \"SIMPLE\") {\n        // if the root component was a class and is now simple, we can convert it from a class\n        // component to a functional component\n        convertSimpleClassComponentToFunctionalComponent(this.realm, componentType, additionalFunctionEffects);\n        normalizeFunctionalComponentParamaters(componentType);\n        this.writeEffects.set(componentType, additionalFunctionEffects);\n      } else {\n        let prototype = Get(this.realm, componentType, \"prototype\");\n        invariant(prototype instanceof ObjectValue);\n        let renderMethod = Get(this.realm, prototype, \"render\");\n        invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n        this.writeEffects.set(renderMethod, additionalFunctionEffects);\n      }\n    } else {\n      if (componentTreeState.status === \"COMPLEX\") {\n        convertFunctionalComponentToComplexClassComponent(\n          this.realm,\n          componentType,\n          componentTreeState.componentType,\n          additionalFunctionEffects\n        );\n        let prototype = Get(this.realm, componentType, \"prototype\");\n        invariant(prototype instanceof ObjectValue);\n        let renderMethod = Get(this.realm, prototype, \"render\");\n        invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n        this.writeEffects.set(renderMethod, additionalFunctionEffects);\n      } else {\n        normalizeFunctionalComponentParamaters(componentType);\n        this.writeEffects.set(componentType, additionalFunctionEffects);\n      }\n    }\n  }\n\n  checkRootReactComponentTrees(statistics: ReactStatistics, react: ReactSerializerState): void {\n    let recordedReactRootValues = this.__generateAdditionalFunctionsMap(\"__reactComponentTrees\");\n    // Get write effects of the components\n    for (let [componentRoot, { config }] of recordedReactRootValues) {\n      invariant(config);\n      let reconciler = new Reconciler(this.realm, this.moduleTracer, statistics, react, config);\n      let componentType = getComponentTypeFromRootValue(this.realm, componentRoot);\n      if (componentType === null) {\n        continue;\n      }\n      let evaluatedRootNode = createReactEvaluatedNode(\"ROOT\", getComponentName(this.realm, componentType));\n      statistics.evaluatedRootNodes.push(evaluatedRootNode);\n      if (reconciler.hasEvaluatedRootNode(componentType, evaluatedRootNode)) {\n        continue;\n      }\n      let effects = reconciler.render(componentType, null, null, true, evaluatedRootNode);\n      let componentTreeState = reconciler.componentTreeState;\n      this._generateWriteEffectsForReactComponentTree(componentType, effects, componentTreeState, evaluatedRootNode);\n\n      // for now we just use abstract props/context, in the future we'll create a new branch with a new component\n      // that used the props/context. It will extend the original component and only have a render method\n      for (let { rootValue: branchRootValue, nested, evaluatedNode } of componentTreeState.branchedComponentTrees) {\n        evaluateComponentTreeBranch(this.realm, effects, nested, () => {\n          let branchComponentType = getComponentTypeFromRootValue(this.realm, branchRootValue);\n          if (branchComponentType === null) {\n            evaluatedNode.status = \"UNKNOWN_TYPE\";\n            return;\n          }\n          // so we don't process the same component multiple times (we might change this logic later)\n          if (reconciler.hasEvaluatedRootNode(branchComponentType, evaluatedNode)) {\n            return;\n          }\n          reconciler.clearComponentTreeState();\n          let branchEffects = reconciler.render(branchComponentType, null, null, false, evaluatedNode);\n          let branchComponentTreeState = reconciler.componentTreeState;\n          this._generateWriteEffectsForReactComponentTree(\n            branchComponentType,\n            branchEffects,\n            branchComponentTreeState,\n            evaluatedNode\n          );\n        });\n      }\n      if (this.realm.react.output === \"bytecode\") {\n        throw new FatalError(\"TODO: implement React bytecode output format\");\n      }\n    }\n  }\n\n  _generateAdditionalFunctionCallsFromDirective(): Array<[FunctionValue, BabelNodeCallExpression]> {\n    let recordedAdditionalFunctions = this.__generateAdditionalFunctionsMap(\"__additionalFunctions\");\n\n    // The additional functions we registered at runtime are recorded at:\n    // global.__additionalFunctions.id\n    let calls = [];\n    for (let [funcValue, { funcId }] of recordedAdditionalFunctions) {\n      // TODO #987: Make Additional Functions work with arguments\n      invariant(funcValue instanceof FunctionValue);\n      calls.push([\n        funcValue,\n        t.callExpression(\n          t.memberExpression(\n            t.memberExpression(t.identifier(\"global\"), t.identifier(\"__additionalFunctions\")),\n            t.identifier(funcId)\n          ),\n          []\n        ),\n      ]);\n    }\n    return calls;\n  }\n\n  _callOfFunction(funcValue: FunctionValue): void => Value {\n    const globalThis = this.realm.$GlobalEnv.environmentRecord.WithBaseObject();\n    let call = funcValue.$Call;\n    invariant(call);\n    let numArgs = funcValue.getLength();\n    let args = [];\n    invariant(funcValue instanceof ECMAScriptSourceFunctionValue);\n    let params = funcValue.$FormalParameters;\n    if (numArgs && numArgs > 0 && params) {\n      for (let parameterId of params) {\n        if (t.isIdentifier(parameterId)) {\n          // Create an AbstractValue similar to __abstract being called\n          args.push(\n            createAbstractArgument(\n              this.realm,\n              ((parameterId: any): BabelNodeIdentifier).name,\n              funcValue.expressionLocation\n            )\n          );\n        } else {\n          this.realm.handleError(\n            new CompilerDiagnostic(\n              \"Non-identifier args to additional functions unsupported\",\n              funcValue.expressionLocation,\n              \"PP1005\",\n              \"FatalError\"\n            )\n          );\n          throw new FatalError(\"Non-identifier args to additional functions unsupported\");\n        }\n      }\n    }\n    return call.bind(this, globalThis, args);\n  }\n\n  checkThatFunctionsAreIndependent() {\n    let inputFunctions = this._generateAdditionalFunctionCallsFromInput();\n    let recordedAdditionalFunctions = this.__generateAdditionalFunctionsMap(\"__additionalFunctions\");\n    let additionalFunctions = inputFunctions.concat([...recordedAdditionalFunctions.keys()]);\n\n    for (let funcValue of additionalFunctions) {\n      invariant(funcValue instanceof FunctionValue);\n      let call = this._callOfFunction(funcValue);\n      let effects = this.realm.evaluatePure(() =>\n        this.realm.evaluateForEffectsInGlobalEnv(call, undefined, \"additional function\")\n      );\n      invariant(effects);\n      let additionalFunctionEffects = this._createAdditionalEffects(effects);\n      this.writeEffects.set(funcValue, additionalFunctionEffects);\n    }\n\n    // check that functions are independent\n    let conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic> = new Map();\n    for (let fun1 of additionalFunctions) {\n      invariant(fun1 instanceof FunctionValue);\n      let fun1Name = this.functionExpressions.get(fun1) || fun1.intrinsicName || \"(unknown function)\";\n      // Also do argument validation here\n      let additionalFunctionEffects = this.writeEffects.get(fun1);\n      invariant(additionalFunctionEffects !== undefined);\n      let e1 = additionalFunctionEffects.effects;\n      invariant(e1 !== undefined);\n      if (e1[0] instanceof Completion) {\n        let error = new CompilerDiagnostic(\n          `Additional function ${fun1Name} may terminate abruptly`,\n          e1[0].location,\n          \"PP1002\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n      for (let fun2 of additionalFunctions) {\n        if (fun1 === fun2) continue;\n        invariant(fun2 instanceof FunctionValue);\n        this.reportWriteConflicts(fun1Name, conflicts, e1[3], this._callOfFunction(fun2));\n      }\n    }\n    if (conflicts.size > 0) {\n      for (let diagnostic of conflicts.values()) this.realm.handleError(diagnostic);\n      throw new FatalError();\n    }\n  }\n\n  getAdditionalFunctionValuesToEffects(): Map<FunctionValue, AdditionalFunctionEffects> {\n    return this.writeEffects;\n  }\n\n  reportWriteConflicts(\n    fname: string,\n    conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic>,\n    pbs: PropertyBindings,\n    call2: void => Value\n  ) {\n    let reportConflict = (location: BabelNodeSourceLocation) => {\n      let error = new CompilerDiagnostic(\n        `Property access conflicts with write in additional function ${fname}`,\n        location,\n        \"PP1003\",\n        \"FatalError\"\n      );\n      conflicts.set(location, error);\n    };\n    let writtenObjects: Set<ObjectValue | AbstractObjectValue> = new Set();\n    pbs.forEach((val, key, m) => {\n      writtenObjects.add(key.object);\n    });\n    let oldReportObjectGetOwnProperties = this.realm.reportObjectGetOwnProperties;\n    this.realm.reportObjectGetOwnProperties = (ob: ObjectValue) => {\n      let location = this.realm.currentLocation;\n      invariant(location);\n      if (writtenObjects.has(ob) && !conflicts.has(location)) reportConflict(location);\n    };\n    let oldReportPropertyAccess = this.realm.reportPropertyAccess;\n    this.realm.reportPropertyAccess = (pb: PropertyBinding) => {\n      let location = this.realm.currentLocation;\n      if (!location) return; // happens only when accessing an additional function property\n      if (pbs.has(pb) && !conflicts.has(location)) reportConflict(location);\n    };\n    try {\n      ignoreErrorsIn(this.realm, () => this.realm.evaluateForEffectsInGlobalEnv(call2));\n    } finally {\n      this.realm.reportPropertyAccess = oldReportPropertyAccess;\n      this.realm.reportObjectGetOwnProperties = oldReportObjectGetOwnProperties;\n    }\n  }\n}\n"]}