{"version":3,"sources":["../../src/serializer/ResidualFunctions.js"],"names":["t","ResidualFunctions","constructor","realm","statistics","options","modules","requireReturns","locationService","prelude","initializerNameGenerator","factoryNameGenerator","residualFunctionInfos","residualFunctionInstances","residualClassMethodInstances","additionalFunctionValueInfos","additionalFunctionValueNestedFunctions","referentializer","functionPrototypes","Map","firstFunctionUsages","functions","classes","functionInstances","residualFunctionInitializers","instance","values","undefined","has","functionValue","addFunctionInstance","simpleClosures","push","code","$ECMAScriptCode","setFunctionPrototype","prototypeId","set","addFunctionUsage","val","bodyReference","_shouldUseFactoryFunction","funcBody","instances","shouldInlineFunction","shouldInline","start","end","bodySize","functionInfo","get","usesArguments","length","_hasRewrittenFunctionInstance","rewrittenAdditionalFunctions","find","_generateFactoryFunctionInfos","factoryFunctionInfos","functionBody","factoryId","suffix","__originalName","debugNames","identifier","generate","getLocation","functionUniqueTag","uniqueOrderedTag","_sortFunctionByOriginalOrdering","functionEntries","sort","funcA","funcB","funcAUniqueTag","funcBUniqueTag","spliceFunctions","scrubFunctionInitializers","functionBodies","additionalFunctionPreludes","additionalFunctionModifiedBindingsSegment","getModifiedBindingsSegment","additionalFunction","getFunctionBody","globalPrelude","getPrelude","containingAdditionalFunction","b","requireStatistics","replaced","count","Array","from","entries","unstrictFunctionBodies","strictFunctionBodies","funcNodes","defineFunction","funcId","funcOrClassNode","initializationStatements","initializationBody","prototype","apply","body","isFunctionExpression","isCallExpression","isClassExpression","variableDeclaration","variableDeclarator","id","memberExpression","funcValue","funcInfo","residualBinding","modifiedBindings","scope","referentialized","bodySegment","decl","name","numericLiteral","init","getReferentializedScopeInitialization","newValue","additionalValueSerialized","binding_reference","serializedValue","isLVal","expressionStatement","assignmentExpression","additionalFunctionInfo","params","$FormalParameters","rewrittenBody","blockStatement","funcParams","slice","classMethodInstance","methodType","classMethodKeyNode","classSuperNode","classMethodComputed","classPrototype","classMethodIsStatic","isConstructor","isExpression","isIdentifier","_getOrCreateClassNode","classMethod","unshift","superClass","functionExpression","$Strict","unbound","modified","usesThis","normalInstances","additionalFunctionNestedInstances","naiveProcessInstances","instancesToSplice","functionClones","residualFunctionBindings","scopeInstances","hasEmptyConstructor","$HasEmptyConstructor","methodParams","methodBody","cloneDeep","file","program","classExpression","classBody","getModuleIdIfNodeIsRequireFunction","getGetModuleIdIfNodeIsRequireFunction","scopeInitialization","scopeName","concat","factoryInfo","factoryNames","sameResidualBindings","isDifferent","lastBinding","firstBinding","factoryParams","key","factoryNode","factoryDeclaration","map","insertionPoint","functionId","hasFunctionArg","flatArgs","value","entry","funcNode","firstUsage","hasInitializerStatement","isNotEarlierThan","callArgs","thisExpression","flatArg","param","type","callee","childBody","returnStatement","callExpression","referentializationScope","referentializationState","keys","createCaptureScopeAccessFunction","createCapturedScopesArrayInitialization","reverse","splice","index","isReturnStatement","pop","initializerStatement","getInitializerStatement"],"mappings":"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","file":"ResidualFunctions.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { FatalError } from \"../errors.js\";\nimport { Realm } from \"../realm.js\";\nimport { FunctionValue, type ECMAScriptSourceFunctionValue, ObjectValue } from \"../values/index.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeSpreadElement,\n  BabelNodeFunctionExpression,\n  BabelNodeClassExpression,\n} from \"babel-types\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport type { NameGenerator } from \"../utils/generator.js\";\nimport traverse from \"babel-traverse\";\nimport invariant from \"../invariant.js\";\nimport type { FunctionInfo, FactoryFunctionInfo, FunctionInstance, AdditionalFunctionInfo } from \"./types.js\";\nimport { BodyReference, AreSameResidualBinding, SerializerStatistics } from \"./types.js\";\nimport { ClosureRefReplacer } from \"./visitors.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { ResidualFunctionInitializers } from \"./ResidualFunctionInitializers.js\";\nimport { nullExpression } from \"../utils/internalizer.js\";\nimport type { LocationService, ClassMethodInstance } from \"./types.js\";\nimport { Referentializer } from \"./Referentializer.js\";\nimport { getOrDefault } from \"./utils.js\";\n\ntype ResidualFunctionsResult = {\n  unstrictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeClassExpression>,\n  strictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeClassExpression>,\n  requireStatistics: { replaced: number, count: number },\n};\n\nexport class ResidualFunctions {\n  constructor(\n    realm: Realm,\n    statistics: SerializerStatistics,\n    options: SerializerOptions,\n    modules: Modules,\n    requireReturns: Map<number | string, BabelNodeExpression>,\n    locationService: LocationService,\n    prelude: Array<BabelNodeStatement>,\n    initializerNameGenerator: NameGenerator,\n    factoryNameGenerator: NameGenerator,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>,\n    residualFunctionInstances: Map<FunctionValue, FunctionInstance>,\n    residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>,\n    additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>,\n    additionalFunctionValueNestedFunctions: Set<FunctionValue>,\n    referentializer: Referentializer\n  ) {\n    this.realm = realm;\n    this.statistics = statistics;\n    this.modules = modules;\n    this.requireReturns = requireReturns;\n    this.locationService = locationService;\n    this.prelude = prelude;\n    this.factoryNameGenerator = factoryNameGenerator;\n    this.functionPrototypes = new Map();\n    this.firstFunctionUsages = new Map();\n    this.functions = new Map();\n    this.classes = new Map();\n    this.functionInstances = [];\n    this.residualFunctionInitializers = new ResidualFunctionInitializers(\n      locationService,\n      prelude,\n      initializerNameGenerator\n    );\n    this.residualFunctionInfos = residualFunctionInfos;\n    this.residualFunctionInstances = residualFunctionInstances;\n    this.residualClassMethodInstances = residualClassMethodInstances;\n    this.additionalFunctionValueInfos = additionalFunctionValueInfos;\n    this.referentializer = referentializer;\n    for (let instance of residualFunctionInstances.values()) {\n      invariant(instance !== undefined);\n      if (!additionalFunctionValueInfos.has(instance.functionValue)) this.addFunctionInstance(instance);\n    }\n    this.additionalFunctionValueNestedFunctions = additionalFunctionValueNestedFunctions;\n    this.simpleClosures = !!options.simpleClosures;\n  }\n\n  realm: Realm;\n  modules: Modules;\n  statistics: SerializerStatistics;\n  requireReturns: Map<number | string, BabelNodeExpression>;\n  locationService: LocationService;\n  prelude: Array<BabelNodeStatement>;\n  factoryNameGenerator: NameGenerator;\n  functionPrototypes: Map<FunctionValue, BabelNodeIdentifier>;\n  firstFunctionUsages: Map<FunctionValue, BodyReference>;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  classes: Map<ObjectValue, BabelNodeClassExpression>;\n  functionInstances: Array<FunctionInstance>;\n  residualFunctionInitializers: ResidualFunctionInitializers;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  residualFunctionInstances: Map<FunctionValue, FunctionInstance>;\n  residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  additionalFunctionValueNestedFunctions: Set<FunctionValue>;\n  referentializer: Referentializer;\n  simpleClosures: boolean;\n\n  addFunctionInstance(instance: FunctionInstance) {\n    this.functionInstances.push(instance);\n    let code = instance.functionValue.$ECMAScriptCode;\n    invariant(code != null);\n    getOrDefault(this.functions, code, () => []).push(instance);\n  }\n\n  setFunctionPrototype(constructor: FunctionValue, prototypeId: BabelNodeIdentifier) {\n    this.functionPrototypes.set(constructor, prototypeId);\n  }\n\n  addFunctionUsage(val: FunctionValue, bodyReference: BodyReference) {\n    if (!this.firstFunctionUsages.has(val)) this.firstFunctionUsages.set(val, bodyReference);\n  }\n\n  _shouldUseFactoryFunction(funcBody: BabelNodeBlockStatement, instances: Array<FunctionInstance>) {\n    function shouldInlineFunction(): boolean {\n      let shouldInline = true;\n      if (funcBody.start && funcBody.end) {\n        let bodySize = funcBody.end - funcBody.start;\n        shouldInline = bodySize <= 30;\n      }\n      return shouldInline;\n    }\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { usesArguments } = functionInfo;\n    return !shouldInlineFunction() && instances.length > 1 && !usesArguments && !this.simpleClosures;\n  }\n\n  // Note: this function takes linear time. Please do not call it inside loop.\n  _hasRewrittenFunctionInstance(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>,\n    instances: Array<FunctionInstance>\n  ): boolean {\n    return instances.find(instance => rewrittenAdditionalFunctions.has(instance.functionValue)) !== undefined;\n  }\n\n  _generateFactoryFunctionInfos(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): Map<number, FactoryFunctionInfo> {\n    const factoryFunctionInfos = new Map();\n    for (const [functionBody, instances] of this.functions) {\n      invariant(instances.length > 0);\n\n      let factoryId;\n      const suffix = instances[0].functionValue.__originalName || this.realm.debugNames ? \"factoryFunction\" : \"\";\n      if (this._shouldUseFactoryFunction(functionBody, instances)) {\n        // Rewritten function should never use factory function.\n        invariant(!this._hasRewrittenFunctionInstance(rewrittenAdditionalFunctions, instances));\n        factoryId = t.identifier(this.factoryNameGenerator.generate(suffix));\n      } else {\n        // For inline function body case, use the first function as the factory function.\n        factoryId = this.locationService.getLocation(instances[0].functionValue);\n      }\n\n      const functionUniqueTag = ((functionBody: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(functionUniqueTag);\n\n      const functionInfo = this.residualFunctionInfos.get(functionBody);\n      invariant(functionInfo);\n      factoryFunctionInfos.set(functionUniqueTag, { factoryId, functionInfo });\n    }\n    return factoryFunctionInfos;\n  }\n\n  // Preserve residual functions' ordering based on its ast dfs traversal order.\n  // This is necessary to prevent unexpected code locality issues.\n  _sortFunctionByOriginalOrdering(functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]>): void {\n    functionEntries.sort((funcA, funcB) => {\n      const funcAUniqueTag = ((funcA[0]: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(funcAUniqueTag);\n\n      const funcBUniqueTag = ((funcB[0]: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(funcBUniqueTag);\n      return funcAUniqueTag - funcBUniqueTag;\n    });\n  }\n\n  spliceFunctions(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): ResidualFunctionsResult {\n    this.residualFunctionInitializers.scrubFunctionInitializers();\n\n    let functionBodies = new Map();\n    // these need to get spliced in at the end\n    let additionalFunctionPreludes = new Map();\n    let additionalFunctionModifiedBindingsSegment: Map<FunctionValue, Array<BabelNodeStatement>> = new Map();\n    let getModifiedBindingsSegment = additionalFunction =>\n      getOrDefault(additionalFunctionModifiedBindingsSegment, additionalFunction, () => []);\n    let getFunctionBody = (instance: FunctionInstance): Array<BabelNodeStatement> =>\n      getOrDefault(functionBodies, instance, () => []);\n    let globalPrelude = this.prelude;\n    function getPrelude(instance: FunctionInstance): Array<BabelNodeStatement> {\n      let additionalFunction = instance.containingAdditionalFunction;\n      let b;\n      if (additionalFunction) {\n        b = getOrDefault(additionalFunctionPreludes, additionalFunction, () => []);\n      } else {\n        b = globalPrelude;\n      }\n      return b;\n    }\n\n    let requireStatistics = { replaced: 0, count: 0 };\n\n    let functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]> = Array.from(\n      this.functions.entries()\n    );\n    this._sortFunctionByOriginalOrdering(functionEntries);\n    this.statistics.functions = functionEntries.length;\n    let unstrictFunctionBodies = [];\n    let strictFunctionBodies = [];\n    let funcNodes: Map<FunctionValue, BabelNodeFunctionExpression> = new Map();\n\n    let defineFunction = (instance, funcId, funcOrClassNode) => {\n      let { functionValue } = instance;\n\n      if (instance.initializationStatements.length > 0) {\n        // always add initialization statements to insertion point\n        let initializationBody = getFunctionBody(instance);\n        Array.prototype.push.apply(initializationBody, instance.initializationStatements);\n      }\n\n      let body;\n      if (t.isFunctionExpression(funcOrClassNode)) {\n        funcNodes.set(functionValue, ((funcOrClassNode: any): BabelNodeFunctionExpression));\n        body = getPrelude(instance);\n      } else {\n        invariant(t.isCallExpression(funcOrClassNode) || t.isClassExpression(funcOrClassNode)); // .bind call\n        body = getFunctionBody(instance);\n      }\n      body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(funcId, funcOrClassNode)]));\n      let prototypeId = this.functionPrototypes.get(functionValue);\n      if (prototypeId !== undefined) {\n        let id = this.locationService.getLocation(functionValue);\n        invariant(id !== undefined);\n        body.push(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(prototypeId, t.memberExpression(id, t.identifier(\"prototype\"))),\n          ])\n        );\n      }\n    };\n\n    // Emit code for ModifiedBindings for additional functions\n    for (let [funcValue, funcInfo] of this.additionalFunctionValueInfos) {\n      for (let [, residualBinding] of funcInfo.modifiedBindings) {\n        let scope = residualBinding.scope;\n\n        // TODO #989: This should probably be an invariant once captures work properly\n        // Currently we don't referentialize bindings in additional functions (but we\n        // do for bindings nested in additional functions)\n        if (!residualBinding.referentialized) continue;\n\n        // Find the proper prelude to emit to (global vs additional function's prelude)\n        let bodySegment = getModifiedBindingsSegment(funcValue);\n\n        // binding has been referentialized, so setup the scope to be able to\n        // access bindings from other __captured_scopes initializers\n        if (scope && scope.containingAdditionalFunction !== funcValue) {\n          let decl = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(t.identifier(scope.name), t.numericLiteral(scope.id)),\n          ]);\n          let init = this.referentializer.getReferentializedScopeInitialization(scope);\n          bodySegment.push(decl);\n          // flow forces me to do this\n          Array.prototype.push.apply(bodySegment, init);\n        }\n\n        let newValue = residualBinding.additionalValueSerialized;\n        invariant(newValue);\n        let binding_reference = ((residualBinding.serializedValue: any): BabelNodeLVal);\n        invariant(binding_reference);\n        invariant(t.isLVal(binding_reference), \"Referentialized values are always LVals\");\n        // This mutation is safe because it should always be either a global identifier (for global bindings)\n        // or an accessor to a referentialized value.\n        bodySegment.push(t.expressionStatement(t.assignmentExpression(\"=\", binding_reference, newValue)));\n      }\n    }\n\n    // Process Additional Functions\n    for (let [funcValue, additionalFunctionInfo] of this.additionalFunctionValueInfos.entries()) {\n      let { instance } = additionalFunctionInfo;\n      let functionValue = ((funcValue: any): ECMAScriptSourceFunctionValue);\n      let params = functionValue.$FormalParameters;\n      invariant(params !== undefined);\n\n      let rewrittenBody = rewrittenAdditionalFunctions.get(funcValue);\n      invariant(rewrittenBody);\n\n      // rewritten functions shouldn't have references fixed up because the body,\n      // consists of serialized code. For simplicity we emit their instances in a naive way\n      let functionBody = t.blockStatement(rewrittenBody);\n      let funcParams = params.slice();\n      let funcOrClassNode;\n\n      if (this.residualClassMethodInstances.has(funcValue)) {\n        let classMethodInstance = this.residualClassMethodInstances.get(funcValue);\n        invariant(classMethodInstance);\n        let {\n          methodType,\n          classMethodKeyNode,\n          classSuperNode,\n          classMethodComputed,\n          classPrototype,\n          classMethodIsStatic,\n        } = classMethodInstance;\n\n        let isConstructor = methodType === \"constructor\";\n        invariant(classPrototype instanceof ObjectValue);\n        invariant(classMethodKeyNode && (t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode)));\n        // we use the classPrototype as the key to get the class expression ast node\n        funcOrClassNode = this._getOrCreateClassNode(classPrototype);\n        let classMethod = t.classMethod(\n          methodType,\n          classMethodKeyNode,\n          funcParams,\n          functionBody,\n          classMethodComputed,\n          classMethodIsStatic\n        );\n        // add the class method to the class expression node body\n        if (isConstructor) {\n          funcOrClassNode.body.body.unshift(classMethod);\n        } else {\n          funcOrClassNode.body.body.push(classMethod);\n        }\n        // we only return the funcOrClassNode if this is the constructor\n        if (!isConstructor) {\n          continue;\n        }\n        // handle the class super\n        if (classSuperNode !== undefined) {\n          funcOrClassNode.superClass = classSuperNode;\n        }\n      } else {\n        funcOrClassNode = t.functionExpression(null, funcParams, functionBody);\n      }\n      let id = this.locationService.getLocation(funcValue);\n      invariant(id !== undefined);\n\n      if (funcValue.$Strict) {\n        strictFunctionBodies.push(funcOrClassNode);\n      } else {\n        unstrictFunctionBodies.push(funcOrClassNode);\n      }\n      defineFunction(instance, id, funcOrClassNode);\n    }\n\n    // Process normal functions\n    const factoryFunctionInfos = this._generateFactoryFunctionInfos(rewrittenAdditionalFunctions);\n    for (let [funcBody, instances] of functionEntries) {\n      let functionInfo = this.residualFunctionInfos.get(funcBody);\n      invariant(functionInfo);\n      let { unbound, modified, usesThis } = functionInfo;\n      let params = instances[0].functionValue.$FormalParameters;\n      invariant(params !== undefined);\n\n      // Split instances into normal or nested in an additional function\n      let normalInstances = [];\n      let additionalFunctionNestedInstances = [];\n      for (let instance of instances) {\n        if (this.additionalFunctionValueNestedFunctions.has(instance.functionValue))\n          additionalFunctionNestedInstances.push(instance);\n        else normalInstances.push(instance);\n      }\n\n      let naiveProcessInstances = instancesToSplice => {\n        this.statistics.functionClones += instancesToSplice.length - 1;\n\n        for (let instance of instancesToSplice) {\n          let { functionValue, residualFunctionBindings, scopeInstances } = instance;\n          let funcOrClassNode;\n\n          if (this.residualClassMethodInstances.has(functionValue)) {\n            let classMethodInstance = this.residualClassMethodInstances.get(functionValue);\n            invariant(classMethodInstance);\n            let {\n              classSuperNode,\n              classMethodKeyNode,\n              methodType,\n              classMethodComputed,\n              classPrototype,\n              classMethodIsStatic,\n            } = classMethodInstance;\n\n            let isConstructor = methodType === \"constructor\";\n            invariant(classPrototype instanceof ObjectValue);\n            invariant(classMethodKeyNode);\n            invariant(t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode));\n            // we use the classPrototype as the key to get the class expression ast node\n            funcOrClassNode = this._getOrCreateClassNode(classPrototype);\n            // if we are dealing with a constructor, don't serialize it if the original\n            // had an empty user-land constructor (because we create a constructor behind the scenes for them)\n            let hasEmptyConstructor = !!functionValue.$HasEmptyConstructor;\n            if (!isConstructor || (isConstructor && !hasEmptyConstructor)) {\n              let methodParams = params.slice();\n              let methodBody = ((t.cloneDeep(funcBody): any): BabelNodeBlockStatement);\n              // create the class method AST\n              let classMethod = t.classMethod(\n                methodType,\n                classMethodKeyNode,\n                methodParams,\n                methodBody,\n                classMethodComputed,\n                classMethodIsStatic\n              );\n              // traverse and replace refs in the class method\n              traverse(\n                t.file(\n                  t.program([t.expressionStatement(t.classExpression(null, null, t.classBody([classMethod]), []))])\n                ),\n                ClosureRefReplacer,\n                null,\n                {\n                  residualFunctionBindings,\n                  modified,\n                  requireReturns: this.requireReturns,\n                  requireStatistics,\n                  getModuleIdIfNodeIsRequireFunction: this.modules.getGetModuleIdIfNodeIsRequireFunction(methodParams, [\n                    functionValue,\n                  ]),\n                  factoryFunctionInfos,\n                }\n              );\n              // add the class method to the class expression node body\n              if (isConstructor) {\n                funcOrClassNode.body.body.unshift(classMethod);\n              } else {\n                funcOrClassNode.body.body.push(classMethod);\n              }\n            }\n            // we only return the funcOrClassNode if this is the constructor\n            if (!isConstructor) {\n              continue;\n            }\n            // handle the class super\n            if (classSuperNode !== undefined) {\n              funcOrClassNode.superClass = classSuperNode;\n            }\n          } else {\n            let funcParams = params.slice();\n            funcOrClassNode = t.functionExpression(\n              null,\n              funcParams,\n              ((t.cloneDeep(funcBody): any): BabelNodeBlockStatement)\n            );\n            let scopeInitialization = [];\n            for (let [scopeName, scope] of scopeInstances) {\n              scopeInitialization.push(\n                t.variableDeclaration(\"var\", [\n                  t.variableDeclarator(t.identifier(scopeName), t.numericLiteral(scope.id)),\n                ])\n              );\n              scopeInitialization = scopeInitialization.concat(\n                this.referentializer.getReferentializedScopeInitialization(scope)\n              );\n            }\n            funcOrClassNode.body.body = scopeInitialization.concat(funcOrClassNode.body.body);\n\n            traverse(t.file(t.program([t.expressionStatement(funcOrClassNode)])), ClosureRefReplacer, null, {\n              residualFunctionBindings,\n              modified,\n              requireReturns: this.requireReturns,\n              requireStatistics,\n              getModuleIdIfNodeIsRequireFunction: this.modules.getGetModuleIdIfNodeIsRequireFunction(funcParams, [\n                functionValue,\n              ]),\n              factoryFunctionInfos,\n            });\n          }\n          let id = this.locationService.getLocation(functionValue);\n          invariant(id !== undefined);\n\n          if (functionValue.$Strict) {\n            strictFunctionBodies.push(funcOrClassNode);\n          } else {\n            unstrictFunctionBodies.push(funcOrClassNode);\n          }\n          invariant(id !== undefined);\n          invariant(funcOrClassNode !== undefined);\n          defineFunction(instance, id, funcOrClassNode);\n        }\n      };\n\n      if (additionalFunctionNestedInstances.length > 0) naiveProcessInstances(additionalFunctionNestedInstances);\n      if (!this._shouldUseFactoryFunction(funcBody, normalInstances)) {\n        naiveProcessInstances(normalInstances);\n      } else if (normalInstances.length > 0) {\n        const functionUniqueTag = ((funcBody: any): FunctionBodyAstNode).uniqueOrderedTag;\n        invariant(functionUniqueTag);\n        const factoryInfo = factoryFunctionInfos.get(functionUniqueTag);\n        invariant(factoryInfo);\n        const { factoryId } = factoryInfo;\n\n        // filter included variables to only include those that are different\n        let factoryNames: Array<string> = [];\n        let sameResidualBindings = new Map();\n        for (let name of unbound) {\n          let isDifferent = false;\n          let lastBinding;\n\n          let firstBinding = normalInstances[0].residualFunctionBindings.get(name);\n          invariant(firstBinding);\n          if (firstBinding.modified) {\n            // Must modify for traversal\n            sameResidualBindings.set(name, firstBinding);\n            continue;\n          }\n\n          for (let { residualFunctionBindings } of normalInstances) {\n            let residualBinding = residualFunctionBindings.get(name);\n\n            invariant(residualBinding);\n            invariant(!residualBinding.modified);\n            if (!lastBinding) {\n              lastBinding = residualBinding;\n            } else if (!AreSameResidualBinding(this.realm, residualBinding, lastBinding)) {\n              isDifferent = true;\n              break;\n            }\n          }\n\n          if (isDifferent) {\n            factoryNames.push(name);\n          } else {\n            invariant(lastBinding);\n            sameResidualBindings.set(name, lastBinding);\n          }\n        }\n\n        let factoryParams: Array<BabelNodeLVal> = [];\n        for (let key of factoryNames) {\n          factoryParams.push(t.identifier(key));\n        }\n\n        let scopeInitialization = [];\n        for (let [scopeName, scope] of normalInstances[0].scopeInstances) {\n          factoryParams.push(t.identifier(scopeName));\n          scopeInitialization = scopeInitialization.concat(\n            this.referentializer.getReferentializedScopeInitialization(scope)\n          );\n        }\n\n        factoryParams = factoryParams.concat(params).slice();\n\n        // The Replacer below mutates the AST while the original AST may still be referenced\n        // by another outer residual function so let's clone the original AST to avoid modifying it.\n        let factoryNode = t.functionExpression(\n          null,\n          factoryParams,\n          ((t.cloneDeep(funcBody): any): BabelNodeBlockStatement)\n        );\n\n        if (normalInstances[0].functionValue.$Strict) {\n          strictFunctionBodies.push(factoryNode);\n        } else {\n          unstrictFunctionBodies.push(factoryNode);\n        }\n\n        factoryNode.body.body = scopeInitialization.concat(factoryNode.body.body);\n\n        // factory functions do not depend on any nested generator scope, so they go to the prelude\n        let factoryDeclaration = t.variableDeclaration(\"var\", [t.variableDeclarator(factoryId, factoryNode)]);\n        this.prelude.push(factoryDeclaration);\n\n        traverse(t.file(t.program([t.expressionStatement(factoryNode)])), ClosureRefReplacer, null, {\n          residualFunctionBindings: sameResidualBindings,\n          modified,\n          requireReturns: this.requireReturns,\n          requireStatistics,\n          getModuleIdIfNodeIsRequireFunction: this.modules.getGetModuleIdIfNodeIsRequireFunction(\n            factoryParams,\n            normalInstances.map(instance => instance.functionValue)\n          ),\n          factoryFunctionInfos,\n        });\n\n        for (let instance of normalInstances) {\n          let { functionValue, residualFunctionBindings, insertionPoint } = instance;\n          let functionId = this.locationService.getLocation(functionValue);\n          invariant(functionId !== undefined);\n          let hasFunctionArg = false;\n          let flatArgs: Array<BabelNodeExpression> = factoryNames.map(name => {\n            let residualBinding = residualFunctionBindings.get(name);\n            invariant(residualBinding);\n            let serializedValue = residualBinding.serializedValue;\n            hasFunctionArg =\n              hasFunctionArg || (residualBinding.value && residualBinding.value instanceof FunctionValue);\n            invariant(serializedValue);\n            return serializedValue;\n          });\n          for (let entry of instance.scopeInstances) {\n            flatArgs.push(t.numericLiteral(entry[1].id));\n          }\n          let funcNode;\n          let firstUsage = this.firstFunctionUsages.get(functionValue);\n          invariant(insertionPoint !== undefined);\n          if (\n            // The same free variables in shared instances may refer to objects with different initialization values\n            // so a stub forward function is needed during delay initializations.\n            this.residualFunctionInitializers.hasInitializerStatement(functionValue) ||\n            usesThis ||\n            hasFunctionArg ||\n            (firstUsage !== undefined && !firstUsage.isNotEarlierThan(insertionPoint)) ||\n            this.functionPrototypes.get(functionValue) !== undefined ||\n            this.simpleClosures\n          ) {\n            let callArgs: Array<BabelNodeExpression | BabelNodeSpreadElement> = [t.thisExpression()];\n            for (let flatArg of flatArgs) callArgs.push(flatArg);\n            for (let param of params) {\n              if (param.type !== \"Identifier\") {\n                throw new FatalError(\"TODO: do not know how to deal with non-Identifier parameters\");\n              }\n              callArgs.push(((param: any): BabelNodeIdentifier));\n            }\n\n            let callee = t.memberExpression(factoryId, t.identifier(\"call\"));\n\n            let childBody = t.blockStatement([t.returnStatement(t.callExpression(callee, callArgs))]);\n\n            funcNode = t.functionExpression(null, params, childBody);\n            if (functionValue.$Strict) {\n              strictFunctionBodies.push(funcNode);\n            } else {\n              unstrictFunctionBodies.push(funcNode);\n            }\n          } else {\n            funcNode = t.callExpression(\n              t.memberExpression(factoryId, t.identifier(\"bind\")),\n              [nullExpression].concat(flatArgs)\n            );\n          }\n\n          defineFunction(instance, functionId, funcNode);\n        }\n      }\n    }\n\n    for (let referentializationScope of this.referentializer.referentializationState.keys()) {\n      let prelude = this.prelude;\n      // Get the prelude for this additional function value\n      if (referentializationScope !== \"GLOBAL\") {\n        let additionalFunction = referentializationScope;\n        prelude = getOrDefault(additionalFunctionPreludes, additionalFunction, () => []);\n      }\n      prelude.unshift(this.referentializer.createCaptureScopeAccessFunction(referentializationScope));\n      prelude.unshift(this.referentializer.createCapturedScopesArrayInitialization(referentializationScope));\n    }\n\n    for (let instance of this.functionInstances.reverse()) {\n      let functionBody = functionBodies.get(instance);\n      if (functionBody !== undefined) {\n        let insertionPoint = instance.insertionPoint;\n        invariant(insertionPoint instanceof BodyReference);\n        // v8 seems to do something clever with array splicing, so this potentially\n        // expensive operations seems to be actually cheap.\n        Array.prototype.splice.apply(\n          insertionPoint.body.entries,\n          ([insertionPoint.index, 0]: Array<any>).concat((functionBody: Array<any>))\n        );\n      }\n    }\n\n    for (let [additionalFunction, body] of rewrittenAdditionalFunctions.entries()) {\n      let bodySegment = additionalFunctionModifiedBindingsSegment.get(additionalFunction);\n      let prelude = additionalFunctionPreludes.get(additionalFunction);\n      if (prelude) body.unshift(...prelude);\n      if (bodySegment) {\n        if (body.length > 0 && t.isReturnStatement(body[body.length - 1])) {\n          let returnStatement = body.pop();\n          body.push(...bodySegment, returnStatement);\n        } else {\n          body.push(...bodySegment);\n        }\n      }\n    }\n\n    // Inject initializer code for indexed vars into functions (for delay initializations)\n    for (let [functionValue, funcNode] of funcNodes) {\n      let initializerStatement = this.residualFunctionInitializers.getInitializerStatement(functionValue);\n      if (initializerStatement !== undefined) {\n        invariant(t.isFunctionExpression(funcNode));\n        let blockStatement: BabelNodeBlockStatement = ((funcNode: any): BabelNodeFunctionExpression).body;\n        blockStatement.body.unshift(initializerStatement);\n      }\n    }\n\n    return { unstrictFunctionBodies, strictFunctionBodies, requireStatistics };\n  }\n  _getOrCreateClassNode(classPrototype: ObjectValue): BabelNodeClassExpression {\n    if (!this.classes.has(classPrototype)) {\n      let funcOrClassNode = t.classExpression(null, null, t.classBody([]), []);\n      this.classes.set(classPrototype, funcOrClassNode);\n      return funcOrClassNode;\n    } else {\n      let funcOrClassNode = this.classes.get(classPrototype);\n      invariant(funcOrClassNode && t.isClassExpression(funcOrClassNode));\n      return funcOrClassNode;\n    }\n  }\n}\n"]}