{"version":3,"sources":["../../src/serializer/factorify.js"],"names":["factorifyObjects","t","isLiteral","node","type","operator","argument","isSameNode","left","right","name","value","getObjectKeys","obj","keys","prop","properties","key","push","computed","indexOf","join","body","factoryNameGenerator","signatures","Object","create","declar","declarations","init","initializerAstNodeName","declars","expr","expression","signatureKey","length","split","rootFactoryParams","rootFactoryProps","keyIndex","id","identifier","keyNode","isValidIdentifier","stringLiteral","objectProperty","rootFactoryId","generate","rootFactoryBody","blockStatement","returnStatement","objectExpression","rootFactory","functionDeclaration","unshift","args","callExpression","seen","Set","has","common","Map","mostSharedArgsLength","declar2","initializerAstNodeName2","sharedArgs","i","arguments","Math","max","set","sharedPairs","entries","pair","highestPairArgs","highestPairCount","pairArgs","declarsSub","concat","removeArgs","subFactoryArgs","subFactoryParams","arg","subFactoryId","subFactoryBody","subFactory","declarSub","add","call","callee","filter","val"],"mappings":"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","file":"factorify.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport * as t from \"babel-types\";\nimport type { BabelNodeStatement, BabelNodeObjectExpression, BabelNodeLVal } from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\n\nfunction isLiteral(node) {\n  switch (node.type) {\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n      return true;\n    case \"UnaryExpression\":\n      return node.operator === \"void\" && isLiteral(node.argument);\n    default:\n      return false;\n  }\n}\n\nfunction isSameNode(left, right) {\n  let type = left.type;\n\n  if (type !== right.type) {\n    return false;\n  }\n\n  if (type === \"Identifier\") {\n    return left.name === right.name;\n  }\n\n  if (type === \"NullLiteral\") {\n    return true;\n  }\n\n  if (type === \"BooleanLiteral\" || type === \"StringLiteral\" || type === \"NumericLiteral\") {\n    return left.value === right.value;\n  }\n\n  if (type === \"UnaryExpression\") {\n    return (\n      left.operator === \"void\" && right.operator === \"void\" && isLiteral(left.argument) && isLiteral(right.argument)\n    );\n  }\n\n  return false;\n}\n\nfunction getObjectKeys(obj: BabelNodeObjectExpression): string | false {\n  let keys = [];\n\n  for (let prop of obj.properties) {\n    if (prop.type !== \"ObjectProperty\") return false;\n\n    let key = prop.key;\n    if (key.type === \"StringLiteral\") {\n      keys.push(key.value);\n    } else if (key.type === \"Identifier\") {\n      if (prop.computed) return false;\n      keys.push(key.name);\n    } else {\n      return false;\n    }\n  }\n\n  for (let key of keys) {\n    if (key.indexOf(\"|\") >= 0) return false;\n  }\n\n  return keys.join(\"|\");\n}\n\n// This function looks for recurring initialization patterns in the code of the form\n//   var x = { a: literal1, b: literal2 }\n//   var y = { a: literal1, b: literal3 }\n// and transforms them into something like\n//   function factory(b) { return { a: literal1, b } }\n//   var x = factory(literal2);\n//   var y = factory(literal3);\n// TODO #884: Right now, the visitor below only looks into top-level variable declaration\n// with a flat object literal initializer.\n// It should also look into conditional control flow, residual functions, and nested object literals.\nexport function factorifyObjects(body: Array<BabelNodeStatement>, factoryNameGenerator: NameGenerator) {\n  let signatures = Object.create(null);\n\n  for (let node of body) {\n    switch (node.type) {\n      case \"VariableDeclaration\":\n        for (let declar of node.declarations) {\n          let { init } = declar;\n          if (!init) continue;\n          if (init.type !== \"ObjectExpression\") continue;\n\n          let keys = getObjectKeys(init);\n          if (!keys) continue;\n\n          let initializerAstNodeName = \"init\";\n          let declars = (signatures[keys] = signatures[keys] || []);\n          declars.push({ declar, initializerAstNodeName });\n        }\n        break;\n\n      case \"ExpressionStatement\":\n        const expr = node.expression;\n        if (expr.type !== \"AssignmentExpression\") {\n          break;\n        }\n        const { right } = expr;\n        if (right.type !== \"ObjectExpression\") {\n          break;\n        }\n\n        let keys = getObjectKeys(right);\n        if (!keys) continue;\n\n        let initializerAstNodeName = \"right\";\n        let declars = (signatures[keys] = signatures[keys] || []);\n        declars.push({ declar: node.expression, initializerAstNodeName });\n        break;\n\n      default:\n        // Continue to next node.\n        break;\n    }\n  }\n\n  for (let signatureKey in signatures) {\n    let declars = signatures[signatureKey];\n    if (declars.length < 5) continue;\n\n    let keys = signatureKey.split(\"|\");\n\n    //\n    let rootFactoryParams: Array<BabelNodeLVal> = [];\n    let rootFactoryProps = [];\n    for (let keyIndex = 0; keyIndex < keys.length; keyIndex++) {\n      let key = keys[keyIndex];\n      let id = t.identifier(`__${keyIndex}`);\n      rootFactoryParams.push(id);\n      let keyNode = t.isValidIdentifier(key) ? t.identifier(key) : t.stringLiteral(key);\n      rootFactoryProps.push(t.objectProperty(keyNode, id));\n    }\n\n    let rootFactoryId = t.identifier(factoryNameGenerator.generate(\"root\"));\n    let rootFactoryBody = t.blockStatement([t.returnStatement(t.objectExpression(rootFactoryProps))]);\n    let rootFactory = t.functionDeclaration(rootFactoryId, rootFactoryParams, rootFactoryBody);\n    body.unshift(rootFactory);\n\n    //\n    for (let { declar, initializerAstNodeName } of declars) {\n      let args = [];\n      for (let prop of declar[initializerAstNodeName].properties) {\n        args.push(prop.value);\n      }\n\n      declar[initializerAstNodeName] = t.callExpression(rootFactoryId, args);\n    }\n\n    //\n    let seen = new Set();\n    for (let { declar, initializerAstNodeName } of declars) {\n      if (seen.has(declar)) continue;\n\n      // build up a map containing the arguments that are shared\n      let common = new Map();\n      let mostSharedArgsLength = 0;\n      for (let { declar: declar2, initializerAstNodeName: initializerAstNodeName2 } of declars) {\n        if (seen.has(declar2)) continue;\n        if (declar === declar2) continue;\n\n        let sharedArgs = [];\n        for (let i = 0; i < keys.length; i++) {\n          if (isSameNode(declar[initializerAstNodeName].arguments[i], declar2[initializerAstNodeName2].arguments[i])) {\n            sharedArgs.push(i);\n          }\n        }\n        if (!sharedArgs.length) continue;\n\n        mostSharedArgsLength = Math.max(mostSharedArgsLength, sharedArgs.length);\n        common.set(declar2, sharedArgs);\n      }\n\n      // build up a mapping of the argument positions that are shared so we can pick the top one\n      let sharedPairs = Object.create(null);\n      for (let [declar2, args] of common.entries()) {\n        if (args.length === mostSharedArgsLength) {\n          args = args.join(\",\");\n          let pair = (sharedPairs[args] = sharedPairs[args] || []);\n          pair.push(declar2);\n        }\n      }\n\n      // get the highest pair\n      let highestPairArgs;\n      let highestPairCount;\n      for (let pairArgs in sharedPairs) {\n        let pair = sharedPairs[pairArgs];\n        if (!highestPairArgs || pair.length > highestPairCount) {\n          highestPairCount = pair.length;\n          highestPairArgs = pairArgs;\n        }\n      }\n      if (!highestPairArgs) continue;\n\n      //\n      let declarsSub = sharedPairs[highestPairArgs].concat(declar);\n      let removeArgs = highestPairArgs.split(\",\");\n\n      let subFactoryArgs = [];\n      let subFactoryParams = [];\n      let sharedArgs = declarsSub[0][initializerAstNodeName].arguments;\n      for (let i = 0; i < sharedArgs.length; i++) {\n        let arg = sharedArgs[i];\n        if (removeArgs.indexOf(i + \"\") >= 0) {\n          subFactoryArgs.push(arg);\n        } else {\n          let id = t.identifier(`__${i}`);\n          subFactoryArgs.push(id);\n          subFactoryParams.push(id);\n        }\n      }\n\n      let subFactoryId = t.identifier(factoryNameGenerator.generate(\"sub\"));\n      let subFactoryBody = t.blockStatement([t.returnStatement(t.callExpression(rootFactoryId, subFactoryArgs))]);\n      let subFactory = t.functionDeclaration(subFactoryId, subFactoryParams, subFactoryBody);\n      body.unshift(subFactory);\n\n      for (let declarSub of declarsSub) {\n        seen.add(declarSub);\n\n        let call = declarSub[initializerAstNodeName];\n        call.callee = subFactoryId;\n        call.arguments = call.arguments.filter(function(val, i) {\n          return removeArgs.indexOf(i + \"\") < 0;\n        });\n      }\n    }\n  }\n}\n"]}