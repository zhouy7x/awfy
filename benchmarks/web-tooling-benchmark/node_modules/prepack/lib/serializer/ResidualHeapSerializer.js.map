{"version":3,"sources":["../../src/serializer/ResidualHeapSerializer.js"],"names":["t","commentStatement","text","s","emptyStatement","leadingComments","type","value","ResidualHeapSerializer","constructor","realm","logger","modules","residualHeapValueIdentifiers","residualHeapInspector","residualValues","residualFunctionInstances","residualClassMethodInstances","residualFunctionInfos","options","referencedDeclaredValues","additionalFunctionValuesAndEffects","additionalFunctionValueInfos","declarativeEnvironmentRecordsBindings","statistics","react","referentializer","generatorParents","realmGenerator","generator","realmPreludeGenerator","preludeGenerator","prelude","_descriptors","Map","needsEmptyVar","needsAuxiliaryConstructor","descriptorNameGenerator","createNameGenerator","factoryNameGenerator","intrinsicNameGenerator","functionNameGenerator","initializeConditionNameGenerator","requireReturns","serializedValues","Set","_serializedValueWithIdentifiers","additionalFunctionValueNestedFunctions","residualReactElementSerializer","residualFunctions","getLocation","getSerializeObjectIdentifier","createLocation","location","identifier","generate","push","variableDeclaration","variableDeclarator","emitter","mainBody","getBody","_options","activeGeneratorBodies","rewrittenAdditionalFunctions","getGeneratorParent","get","bind","additionalFunctionGenerators","additionalFunctionGeneratorsInverse","_emitObjectProperties","obj","properties","objectPrototypeAlreadyEstablished","cleanupDummyProperties","skipPrototype","symbol","propertyBinding","symbols","desc","descriptor","undefined","emitNowOrAfterWaitingForDependencies","_getDescriptorValues","concat","_emitProperty","key","pathNode","canIgnoreProperty","has","unknownProperty","val","_getNestedAbstractValues","_emitPropertiesWithComputedNames","_emitObjectPrototype","_emitConstructorPrototype","objects","objectProperties","size","kind","getKind","proto","$Prototype","serializedProto","serializeValue","uid","fetchedPrototype","isCompatibleWith","MOBILE_JSC_VERSION","memberExpression","callExpression","memoizeReference","condition","binaryExpression","throwblock","blockStatement","throwStatement","newExpression","stringLiteral","emit","ifStatement","intrinsics","expressionStatement","assignmentExpression","func","prototype","getPropertyValue","absVal","values","args","length","cond","P","V","W","consequent","alternate","earlier_props","serializedP","serializedV","serializedCond","oldBody","beginEmitting","parentBody","entries","done","consequentBody","endEmitting","consequentStatement","alternateBody","alternateStatement","getIdentifierAndIncrementReferenceCount","deleteIfMightHaveBeenDeleted","locationFunction","serializedKey","getAsPropertyNameExpression","computed","isIdentifier","_deleteProperty","emitDefinePropertyBody","joinCondition","trueBody","falseBody","descriptor1","descriptor2","unaryExpression","_canEmbedProperty","descValue","getReasonToWaitForDependencies","mightHaveBeenDeleted","_getPropertyAssignment","body","descProps","boolKeys","valKeys","set","descriptorsKey","boolKey","b","objectProperty","booleanLiteral","toString","join","descriptorId","declar","objectExpression","descKey","sequenceExpression","_serializeDeclarativeEnvironmentRecordBinding","residualFunctionBinding","name","instance","serializedValue","declarativeEnvironmentRecord","modified","referentializeBinding","mightBeObject","incrementReferenceCount","_getReferencingGenerators","initialGenerators","functionValues","referencingOnlyAdditionalFunction","result","activeFunctions","slice","visitedFunctions","f","pop","add","g","scopes","scope","Array","from","isReferencedOnlyByAdditionalFunction","additionalFunction","_getTarget","trace","console","log","generators","h","getName","fv","__originalName","JSON","stringify","expressionLocation","delayInitializations","simpleClosures","residualFunctionInitializers","registerValueOnlyReferencedByResidualFunctions","usedOnlyByResidualFunctions","description","filter","commonAncestor","reduce","x","y","notYetDoneBodies","dependenciesVisitor","onAbstractValueWithIdentifier","dependency","intrinsicName","declarationBody","getDeclarationBody","scopeBody","nestingLevel","_getValueDebugName","id","getIdentifier","serializeBinding","binding","record","environment","residualFunctionBindings","residualBinding","referentialized","referencedOnlyFromAdditionalFunctions","_declare","emittingToResidualFunction","bindingType","init","assignment","referenceOnly","refuseSerialization","_serializeAbstractValueHelper","classMethodInstance","methodType","error","$ECMAScriptCode","loc","handleError","isLeaf","res","_serializeValue","target","debugIdentifiers","includes","needsIdentifier","debugScopes","scopeList","map","comment","valueIds","delayedValues","deleteIdentifier","valuesInlined","_serializeValueIntrinsic","intrinsicNameGenerated","convertStringToMember","_assignProperty","locationFn","valueFn","empty","deletion","_serializeArrayIndexProperties","array","indexPropertyLength","remainingProperties","elems","i","elem","elemVal","delayReason","getReasonToWaitForActiveValue","delete","_serializeArrayLengthIfNeeded","numberOfIndexProperties","lenProperty","isHavocedObject","evaluateWithoutLeakLogic","ToLength","_serializeValueArray","initProperties","arrayExpression","_serializeValueMap","$MapData","$WeakMapData","len","mapConstructorDoesntTakeArguments","entry","$Key","$Value","emitAfterWaiting","_serializeValueSet","$SetData","$WeakSetData","setConstructorDoesntTakeArguments","_serializeValueTypedArrayOrDataView","buf","$ViewedArrayBuffer","outlinedArrayBuffer","_serializeValueArrayBuffer","$ArrayBufferByteLength","db","$ArrayBufferData","allzero","numericLiteral","arrayValue","consExpr","_serializeValueFunction","$BoundTargetFunction","$BoundThis","$BoundArguments","boundArg","residualBindings","inAdditionalFunction","containingAdditionalFunction","delayed","undelay","insertionPoint","getBodyReference","boundName","referencedValues","serializeBindingFunc","_serializeGlobalBinding","bindingValue","bindingAdditionalFunction","$FunctionKind","homeObject","$HomeObject","$IsClassPrototype","_serializeClass","classFunc","classPrototype","classProtoId","hasSerializedClassProtoId","propertiesToSerialize","classSuperNode","serializeClassPrototypeId","classId","serializeClassMethod","propertyNameOrSymbol","methodFunc","_serializeClassMethod","methodId","serializeClassProperty","propertyValue","prop","propertyName","method","classMethodKeyNode","classMethodComputed","targetDescriptor","getTargetIntegrityDescriptor","writable","configurable","enumerable","_findLastObjectPrototype","_serializeValueRegExpObject","source","$OriginalSource","flags","$OriginalFlags","RegExp","regExpLiteral","serializeValueRawObject","dummyProperties","props","propValue","_serializeValueObjectViaConstructor","classConstructor","serializeValueObject","originalConstructor","prototypeId","setFunctionPrototype","numberData","$NumberData","throwIfNotConcreteNumber","stringData","$StringData","throwIfNotConcreteString","booleanData","$BooleanData","throwIfNotConcreteBoolean","dateValue","$DateValue","serializedDateValue","serializeReactElement","$ParameterMap","createViaAuxiliaryConstructor","ObjectPrototype","_constructor","_serializeValueSymbol","$Description","serializedArg","globalReg","globalSymbolRegistry","find","e","$Symbol","_serializeValueProxy","$ProxyTarget","$ProxyHandler","serializedArgs","abstractArg","abstractIndex","findIndex","v","buildNode","derivedIds","cannotDeclare","hasBeenDeclared","emittingToAdditionalFunction","_serializeAbstractValue","hasIdentifier","isIntrinsic","valueToNode","serialize","targetCommand","getTargetIntegrityCommand","getGlobalLetBinding","rval","equals","globalReference","_withGeneratorScope","callback","newBody","isChild","statements","parent","unshift","_getContext","context","serializeGenerator","statement","canOmit","declare","_shouldBeWrapped","item","_serializeAdditionalFunctionGeneratorAndEffects","postGeneratorCallback","oldSerialiedValueWithIdentifiers","_serializeAdditionalFunctionEffects","additionalFunctionValue","effects","modifiedProperties","createdObjects","keys","object","additionalFunctionValueInfo","modifiedBinding","modifiedBindings","newVal","additionalValueSerialized","returnStatement","lazyHoistedReactNodes","serializeLazyHoistedNodes","apply","_serializeAdditionalFunction","transforms","shouldEmitLog","collectValToRefCountOnly","nestedFunctions","forEach","withEffectsAppliedInGlobalEnv","transform","resolveInitializedModules","moduleIds","initializedModules","prepareAdditionalFunctionValues","additionalFVEffects","processAdditionalFunctionValues","postGeneratorSerialization","declaredCount","moduleId","moduleValue","finalize","factorifyInitializers","unstrictFunctionBodies","strictFunctionBodies","requireStatistics","spliceFunctions","replaced","count","strictDirective","directive","directiveLiteral","globalDirectives","isStrict","funcLoop","node","isFunctionExpression","directives","functionExpression","ast_body","declaredGlobals","globalExpression","thisExpression","usesThis","cleanInstance","program_directives","file","program"],"mappings":"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","file":"ResidualHeapSerializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport type { Effects } from \"../realm\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\nimport { IsArray, Get } from \"../methods/index.js\";\nimport {\n  BoundFunctionValue,\n  ProxyValue,\n  SymbolValue,\n  NumberValue,\n  StringValue,\n  BooleanValue,\n  AbstractValue,\n  EmptyValue,\n  FunctionValue,\n  ECMAScriptSourceFunctionValue,\n  Value,\n  ObjectValue,\n  NativeFunctionValue,\n  UndefinedValue,\n} from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeMemberExpression,\n  BabelVariableKind,\n  BabelNodeFile,\n  BabelNodeFunctionExpression,\n} from \"babel-types\";\nimport { Generator, PreludeGenerator, NameGenerator } from \"../utils/generator.js\";\nimport type { SerializationContext } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type {\n  ResidualFunctionBinding,\n  FunctionInfo,\n  FunctionInstance,\n  AdditionalFunctionInfo,\n  ReactSerializerState,\n  SerializedBody,\n  ClassMethodInstance,\n  AdditionalFunctionEffects,\n} from \"./types.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport { TimingStatistics, SerializerStatistics, BodyReference } from \"./types.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { ResidualHeapInspector } from \"./ResidualHeapInspector.js\";\nimport { ResidualFunctions } from \"./ResidualFunctions.js\";\nimport type { Scope } from \"./ResidualHeapVisitor.js\";\nimport { factorifyObjects } from \"./factorify.js\";\nimport { voidExpression, emptyExpression, constructorExpression, protoExpression } from \"../utils/internalizer.js\";\nimport { Emitter } from \"./Emitter.js\";\nimport { ResidualHeapValueIdentifiers } from \"./ResidualHeapValueIdentifiers.js\";\nimport {\n  commonAncestorOf,\n  getSuggestedArrayLiteralLength,\n  withDescriptorValue,\n  ClassPropertiesToIgnore,\n  canIgnoreClassLengthProperty,\n  getObjectPrototypeMetadata,\n} from \"./utils.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { canHoistFunction } from \"../react/hoisting.js\";\nimport { To } from \"../singletons.js\";\nimport { ResidualReactElementSerializer } from \"./ResidualReactElementSerializer.js\";\nimport type { Binding } from \"../environment.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport type { Referentializer } from \"./Referentializer.js\";\n\nfunction commentStatement(text: string) {\n  let s = t.emptyStatement();\n  s.leadingComments = [({ type: \"BlockComment\", value: text }: any)];\n  return s;\n}\n\nexport class ResidualHeapSerializer {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    residualHeapValueIdentifiers: ResidualHeapValueIdentifiers,\n    residualHeapInspector: ResidualHeapInspector,\n    residualValues: Map<Value, Set<Scope>>,\n    residualFunctionInstances: Map<FunctionValue, FunctionInstance>,\n    residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>,\n    options: SerializerOptions,\n    referencedDeclaredValues: Map<AbstractValue, void | FunctionValue>,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects> | void,\n    additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>,\n    declarativeEnvironmentRecordsBindings: Map<DeclarativeEnvironmentRecord, Map<string, ResidualFunctionBinding>>,\n    statistics: SerializerStatistics,\n    react: ReactSerializerState,\n    referentializer: Referentializer,\n    generatorParents: Map<Generator, Generator>\n  ) {\n    this.realm = realm;\n    this.logger = logger;\n    this.modules = modules;\n    this.residualHeapValueIdentifiers = residualHeapValueIdentifiers;\n    this.statistics = statistics;\n    this.react = react;\n    this.referentializer = referentializer;\n\n    let realmGenerator = this.realm.generator;\n    invariant(realmGenerator);\n    this.generator = realmGenerator;\n    let realmPreludeGenerator = this.realm.preludeGenerator;\n    invariant(realmPreludeGenerator);\n    this.preludeGenerator = realmPreludeGenerator;\n\n    this.prelude = [];\n    this._descriptors = new Map();\n    this.needsEmptyVar = false;\n    this.needsAuxiliaryConstructor = false;\n    this.descriptorNameGenerator = this.preludeGenerator.createNameGenerator(\"$$\");\n    this.factoryNameGenerator = this.preludeGenerator.createNameGenerator(\"$_\");\n    this.intrinsicNameGenerator = this.preludeGenerator.createNameGenerator(\"$i_\");\n    this.functionNameGenerator = this.preludeGenerator.createNameGenerator(\"$f_\");\n    this.initializeConditionNameGenerator = this.preludeGenerator.createNameGenerator(\"_initialized\");\n    this.requireReturns = new Map();\n    this.serializedValues = new Set();\n    this._serializedValueWithIdentifiers = new Set();\n    this.additionalFunctionValueNestedFunctions = new Set();\n    this.residualReactElementSerializer = new ResidualReactElementSerializer(this.realm, this);\n    this.residualFunctions = new ResidualFunctions(\n      this.realm,\n      this.statistics,\n      options,\n      this.modules,\n      this.requireReturns,\n      {\n        getLocation: value => this.getSerializeObjectIdentifier(value),\n        createLocation: () => {\n          let location = t.identifier(this.initializeConditionNameGenerator.generate());\n          // TODO: This function may get to create locations to be used in additional functions; is the global prelude the right place?\n          this.prelude.push(t.variableDeclaration(\"var\", [t.variableDeclarator(location)]));\n          return location;\n        },\n      },\n      this.prelude,\n      this.preludeGenerator.createNameGenerator(\"__init_\"),\n      this.factoryNameGenerator,\n      residualFunctionInfos,\n      residualFunctionInstances,\n      residualClassMethodInstances,\n      additionalFunctionValueInfos,\n      this.additionalFunctionValueNestedFunctions,\n      referentializer\n    );\n    this.emitter = new Emitter(this.residualFunctions, referencedDeclaredValues);\n    this.mainBody = this.emitter.getBody();\n    this.residualHeapInspector = residualHeapInspector;\n    this.residualValues = residualValues;\n    this.residualFunctionInstances = residualFunctionInstances;\n    this.residualClassMethodInstances = residualClassMethodInstances;\n    this.residualFunctionInfos = residualFunctionInfos;\n    this._options = options;\n    this.referencedDeclaredValues = referencedDeclaredValues;\n    this.activeGeneratorBodies = new Map();\n    this.additionalFunctionValuesAndEffects = additionalFunctionValuesAndEffects;\n    this.additionalFunctionValueInfos = additionalFunctionValueInfos;\n    this.rewrittenAdditionalFunctions = new Map();\n    this.declarativeEnvironmentRecordsBindings = declarativeEnvironmentRecordsBindings;\n    this.getGeneratorParent = generatorParents.get.bind(generatorParents);\n    this.additionalFunctionGenerators = new Map();\n    this.additionalFunctionGeneratorsInverse = new Map();\n  }\n\n  emitter: Emitter;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  functionInstances: Array<FunctionInstance>;\n  prelude: Array<BabelNodeStatement>;\n  body: Array<BabelNodeStatement>;\n  mainBody: SerializedBody;\n  realm: Realm;\n  preludeGenerator: PreludeGenerator;\n  generator: Generator;\n  _descriptors: Map<string, BabelNodeIdentifier>;\n  needsEmptyVar: boolean;\n  needsAuxiliaryConstructor: boolean;\n  descriptorNameGenerator: NameGenerator;\n  factoryNameGenerator: NameGenerator;\n  intrinsicNameGenerator: NameGenerator;\n  functionNameGenerator: NameGenerator;\n  initializeConditionNameGenerator: NameGenerator;\n  logger: Logger;\n  modules: Modules;\n  residualHeapValueIdentifiers: ResidualHeapValueIdentifiers;\n  requireReturns: Map<number | string, BabelNodeExpression>;\n  statistics: SerializerStatistics;\n  timingStats: TimingStatistics;\n  residualHeapInspector: ResidualHeapInspector;\n  residualValues: Map<Value, Set<Scope>>;\n  residualFunctionInstances: Map<FunctionValue, FunctionInstance>;\n  residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  serializedValues: Set<Value>;\n  _serializedValueWithIdentifiers: Set<Value>;\n  residualFunctions: ResidualFunctions;\n  _options: SerializerOptions;\n  referencedDeclaredValues: Map<AbstractValue, void | FunctionValue>;\n  activeGeneratorBodies: Map<Generator, SerializedBody>;\n  additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects> | void;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>;\n  declarativeEnvironmentRecordsBindings: Map<DeclarativeEnvironmentRecord, Map<string, ResidualFunctionBinding>>;\n  react: ReactSerializerState;\n  residualReactElementSerializer: ResidualReactElementSerializer;\n  referentializer: Referentializer;\n  additionalFunctionGenerators: Map<FunctionValue, Generator>;\n  additionalFunctionGeneratorsInverse: Map<Generator, FunctionValue>;\n\n  // function values nested in additional functions can't delay initializations\n  // TODO: revisit this and fix additional functions to be capable of delaying initializations\n  additionalFunctionValueNestedFunctions: Set<FunctionValue>;\n\n  getGeneratorParent: Generator => void | Generator;\n\n  // Configures all mutable aspects of an object, in particular:\n  // symbols, properties, prototype.\n  // For every created object that corresponds to a value,\n  // this function should be invoked once.\n  // Thus, as a side effect, we gather statistics here on all emitted objects.\n  _emitObjectProperties(\n    obj: ObjectValue,\n    properties: Map<string, PropertyBinding> = obj.properties,\n    objectPrototypeAlreadyEstablished: boolean = false,\n    cleanupDummyProperties: ?Set<string>,\n    skipPrototype: boolean = false\n  ) {\n    //inject symbols\n    for (let [symbol, propertyBinding] of obj.symbols) {\n      invariant(propertyBinding);\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      this.emitter.emitNowOrAfterWaitingForDependencies(this._getDescriptorValues(desc).concat([symbol, obj]), () => {\n        invariant(desc !== undefined);\n        return this._emitProperty(obj, symbol, desc);\n      });\n    }\n\n    // inject properties\n    for (let [key, propertyBinding] of properties) {\n      invariant(propertyBinding);\n      if (propertyBinding.pathNode !== undefined) continue; // Property is assigned to inside loop\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      if (this.residualHeapInspector.canIgnoreProperty(obj, key)) continue;\n      invariant(desc !== undefined);\n      this.emitter.emitNowOrAfterWaitingForDependencies(this._getDescriptorValues(desc).concat(obj), () => {\n        invariant(desc !== undefined);\n        return this._emitProperty(obj, key, desc, cleanupDummyProperties != null && cleanupDummyProperties.has(key));\n      });\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        this.emitter.emitNowOrAfterWaitingForDependencies(this._getNestedAbstractValues(val, [obj]), () => {\n          invariant(val instanceof AbstractValue);\n          this._emitPropertiesWithComputedNames(obj, val);\n        });\n      }\n    }\n\n    // prototype\n    if (!skipPrototype) {\n      this._emitObjectPrototype(obj, objectPrototypeAlreadyEstablished);\n      if (obj instanceof FunctionValue) this._emitConstructorPrototype(obj);\n    }\n\n    this.statistics.objects++;\n    this.statistics.objectProperties += obj.properties.size;\n  }\n\n  _emitObjectPrototype(obj: ObjectValue, objectPrototypeAlreadyEstablished: boolean) {\n    let kind = obj.getKind();\n    let proto = obj.$Prototype;\n    if (objectPrototypeAlreadyEstablished) {\n      // Emitting an assertion. This can be removed in the future, or put under a DEBUG flag.\n      this.emitter.emitNowOrAfterWaitingForDependencies([proto, obj], () => {\n        invariant(proto);\n        let serializedProto = this.serializeValue(proto);\n        let uid = this.getSerializeObjectIdentifier(obj);\n        const fetchedPrototype =\n          this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) || this.realm.isCompatibleWith(\"mobile\")\n            ? t.memberExpression(uid, protoExpression)\n            : t.callExpression(this.preludeGenerator.memoizeReference(\"Object.getPrototypeOf\"), [uid]);\n        let condition = t.binaryExpression(\"!==\", fetchedPrototype, serializedProto);\n        let throwblock = t.blockStatement([\n          t.throwStatement(t.newExpression(t.identifier(\"Error\"), [t.stringLiteral(\"unexpected prototype\")])),\n        ]);\n        this.emitter.emit(t.ifStatement(condition, throwblock));\n      });\n      return;\n    }\n    if (proto === this.realm.intrinsics[kind + \"Prototype\"]) return;\n\n    this.emitter.emitNowOrAfterWaitingForDependencies([proto, obj], () => {\n      invariant(proto);\n      let serializedProto = this.serializeValue(proto);\n      let uid = this.getSerializeObjectIdentifier(obj);\n      if (!this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) && !this.realm.isCompatibleWith(\"mobile\"))\n        this.emitter.emit(\n          t.expressionStatement(\n            t.callExpression(this.preludeGenerator.memoizeReference(\"Object.setPrototypeOf\"), [uid, serializedProto])\n          )\n        );\n      else {\n        this.emitter.emit(\n          t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(uid, protoExpression), serializedProto))\n        );\n      }\n    });\n  }\n\n  _emitConstructorPrototype(func: FunctionValue) {\n    // If the original prototype object was mutated,\n    // request its serialization here as this might be observable by\n    // residual code.\n    let prototype = ResidualHeapInspector.getPropertyValue(func, \"prototype\");\n    if (prototype instanceof ObjectValue && this.residualValues.has(prototype)) {\n      this.emitter.emitNowOrAfterWaitingForDependencies([func], () => {\n        invariant(prototype instanceof Value);\n        this.serializeValue(prototype);\n      });\n    }\n  }\n\n  _getNestedAbstractValues(absVal: AbstractValue, values: Array<Value>): Array<Value> {\n    if (absVal.kind === \"widened property\") return values;\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      values.push(P);\n      let V = absVal.args[1];\n      values.push(V);\n      let W = absVal.args[2];\n      if (W instanceof AbstractValue) this._getNestedAbstractValues(W, values);\n      else values.push(W);\n    } else {\n      // conditional assignment\n      values.push(cond);\n      let consequent = absVal.args[1];\n      invariant(consequent instanceof AbstractValue);\n      let alternate = absVal.args[2];\n      invariant(alternate instanceof AbstractValue);\n      this._getNestedAbstractValues(consequent, values);\n      this._getNestedAbstractValues(alternate, values);\n    }\n    return values;\n  }\n\n  _emitPropertiesWithComputedNames(obj: ObjectValue, absVal: AbstractValue) {\n    if (absVal.kind === \"widened property\") return;\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      invariant(P instanceof AbstractValue);\n      let V = absVal.args[1];\n      let earlier_props = absVal.args[2];\n      if (earlier_props instanceof AbstractValue) this._emitPropertiesWithComputedNames(obj, earlier_props);\n      let uid = this.getSerializeObjectIdentifier(obj);\n      let serializedP = this.serializeValue(P);\n      let serializedV = this.serializeValue(V);\n      this.emitter.emit(\n        t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(uid, serializedP, true), serializedV))\n      );\n    } else {\n      // conditional assignment\n      let serializedCond = this.serializeValue(cond);\n      let consequent = absVal.args[1];\n      invariant(consequent instanceof AbstractValue);\n      let alternate = absVal.args[2];\n      invariant(alternate instanceof AbstractValue);\n      let oldBody = this.emitter.beginEmitting(\n        \"consequent\",\n        {\n          type: \"ConditionalAssignmentBranch\",\n          parentBody: undefined,\n          entries: [],\n          done: false,\n        },\n        /*isChild*/ true\n      );\n      this._emitPropertiesWithComputedNames(obj, consequent);\n      let consequentBody = this.emitter.endEmitting(\"consequent\", oldBody, /*isChild*/ true);\n      let consequentStatement = t.blockStatement(consequentBody.entries);\n      oldBody = this.emitter.beginEmitting(\n        \"alternate\",\n        {\n          type: \"ConditionalAssignmentBranch\",\n          parentBody: undefined,\n          entries: [],\n          done: false,\n        },\n        /*isChild*/ true\n      );\n      this._emitPropertiesWithComputedNames(obj, alternate);\n      let alternateBody = this.emitter.endEmitting(\"alternate\", oldBody, /*isChild*/ true);\n      let alternateStatement = t.blockStatement(alternateBody.entries);\n      this.emitter.emit(t.ifStatement(serializedCond, consequentStatement, alternateStatement));\n    }\n  }\n\n  // Overridable.\n  getSerializeObjectIdentifier(val: Value) {\n    return this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val);\n  }\n\n  _emitProperty(\n    val: ObjectValue,\n    key: string | SymbolValue,\n    desc: Descriptor | void,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ): void {\n    // Location for the property to be assigned to\n    let locationFunction = () => {\n      let serializedKey =\n        key instanceof SymbolValue ? this.serializeValue(key) : this.generator.getAsPropertyNameExpression(key);\n      let computed = key instanceof SymbolValue || !t.isIdentifier(serializedKey);\n      return t.memberExpression(this.getSerializeObjectIdentifier(val), serializedKey, computed);\n    };\n    if (desc === undefined) {\n      this._deleteProperty(locationFunction());\n    } else {\n      this.emitter.emit(this.emitDefinePropertyBody(deleteIfMightHaveBeenDeleted, locationFunction, val, key, desc));\n    }\n  }\n\n  emitDefinePropertyBody(\n    deleteIfMightHaveBeenDeleted: boolean,\n    locationFunction: void | (() => BabelNodeLVal),\n    val: ObjectValue,\n    key: string | SymbolValue,\n    desc: Descriptor\n  ): BabelNodeStatement {\n    if (desc.joinCondition) {\n      let cond = this.serializeValue(desc.joinCondition);\n      invariant(cond !== undefined);\n      let trueBody;\n      let falseBody;\n      if (desc.descriptor1)\n        trueBody = this.emitDefinePropertyBody(\n          deleteIfMightHaveBeenDeleted,\n          locationFunction,\n          val,\n          key,\n          desc.descriptor1\n        );\n      if (desc.descriptor2)\n        falseBody = this.emitDefinePropertyBody(\n          deleteIfMightHaveBeenDeleted,\n          locationFunction,\n          val,\n          key,\n          desc.descriptor2\n        );\n      if (trueBody && falseBody) return t.ifStatement(cond, trueBody, falseBody);\n      if (trueBody) return t.ifStatement(cond, trueBody);\n      if (falseBody) return t.ifStatement(t.unaryExpression(\"!\", cond), falseBody);\n      invariant(false);\n    }\n    if (locationFunction !== undefined && this._canEmbedProperty(val, key, desc)) {\n      let descValue = desc.value;\n      invariant(descValue instanceof Value);\n      invariant(!this.emitter.getReasonToWaitForDependencies([descValue, val]), \"precondition of _emitProperty\");\n      let mightHaveBeenDeleted = descValue.mightHaveBeenDeleted();\n      // The only case we do not need to remove the dummy property is array index property.\n      return this._getPropertyAssignment(\n        locationFunction,\n        () => {\n          invariant(descValue instanceof Value);\n          return this.serializeValue(descValue);\n        },\n        mightHaveBeenDeleted,\n        deleteIfMightHaveBeenDeleted\n      );\n    }\n    let body = [];\n    let descProps = [];\n    let boolKeys = [\"enumerable\", \"configurable\"];\n    let valKeys = [];\n\n    if (!desc.get && !desc.set) {\n      boolKeys.push(\"writable\");\n      valKeys.push(\"value\");\n    } else {\n      valKeys.push(\"set\", \"get\");\n    }\n\n    let descriptorsKey = [];\n    for (let boolKey of boolKeys) {\n      if (boolKey in desc) {\n        let b = desc[boolKey];\n        invariant(b !== undefined);\n        descProps.push(t.objectProperty(t.identifier(boolKey), t.booleanLiteral(b)));\n        descriptorsKey.push(`${boolKey}:${b.toString()}`);\n      }\n    }\n\n    descriptorsKey = descriptorsKey.join(\",\");\n    let descriptorId = this._descriptors.get(descriptorsKey);\n    if (descriptorId === undefined) {\n      descriptorId = t.identifier(this.descriptorNameGenerator.generate(descriptorsKey));\n      let declar = t.variableDeclaration(\"var\", [t.variableDeclarator(descriptorId, t.objectExpression(descProps))]);\n      // The descriptors are used across all scopes, and thus must be declared in the prelude.\n      this.prelude.push(declar);\n      this._descriptors.set(descriptorsKey, descriptorId);\n    }\n    invariant(descriptorId !== undefined);\n\n    for (let descKey of valKeys) {\n      if (descKey in desc) {\n        let descValue = desc[descKey];\n        invariant(descValue instanceof Value);\n        if (descValue instanceof UndefinedValue) {\n          this.serializeValue(descValue);\n          continue;\n        }\n        invariant(!this.emitter.getReasonToWaitForDependencies([descValue]), \"precondition of _emitProperty\");\n        body.push(\n          t.assignmentExpression(\n            \"=\",\n            t.memberExpression(descriptorId, t.identifier(descKey)),\n            this.serializeValue(descValue)\n          )\n        );\n      }\n    }\n    let serializedKey =\n      key instanceof SymbolValue\n        ? this.serializeValue(key)\n        : this.generator.getAsPropertyNameExpression(key, /*canBeIdentifier*/ false);\n    invariant(!this.emitter.getReasonToWaitForDependencies([val]), \"precondition of _emitProperty\");\n    body.push(\n      t.callExpression(this.preludeGenerator.memoizeReference(\"Object.defineProperty\"), [\n        this.getSerializeObjectIdentifier(val),\n        serializedKey,\n        descriptorId,\n      ])\n    );\n    return t.expressionStatement(t.sequenceExpression(body));\n  }\n\n  _serializeDeclarativeEnvironmentRecordBinding(\n    residualFunctionBinding: ResidualFunctionBinding,\n    name: string,\n    instance: FunctionInstance\n  ) {\n    if (!residualFunctionBinding.serializedValue) {\n      let value = residualFunctionBinding.value;\n      invariant(value);\n      invariant(residualFunctionBinding.declarativeEnvironmentRecord);\n\n      // Set up binding identity before starting to serialize value. This is needed in case of recursive dependencies.\n      residualFunctionBinding.serializedValue = this.serializeValue(value);\n      if (residualFunctionBinding.modified)\n        this.referentializer.referentializeBinding(residualFunctionBinding, name, instance);\n      if (value.mightBeObject()) {\n        // Increment ref count one more time to ensure that this object will be assigned a unique id.\n        // This ensures that only once instance is created across all possible residual function invocations.\n        this.residualHeapValueIdentifiers.incrementReferenceCount(value);\n      }\n    }\n  }\n\n  // Augments an initial set of generators with all generators from\n  // which any of a given set of function values is referenced.\n  _getReferencingGenerators(\n    initialGenerators: Array<Generator>,\n    functionValues: Array<FunctionValue>,\n    referencingOnlyAdditionalFunction: void | FunctionValue\n  ): Array<Generator> {\n    let result = new Set(initialGenerators);\n    let activeFunctions = functionValues.slice();\n    let visitedFunctions = new Set();\n    while (activeFunctions.length > 0) {\n      let f = activeFunctions.pop();\n      if (visitedFunctions.has(f)) continue;\n      visitedFunctions.add(f);\n      if (f === referencingOnlyAdditionalFunction) {\n        let g = this.additionalFunctionGenerators.get(f);\n        invariant(g !== undefined);\n        result.add(g);\n      } else {\n        let scopes = this.residualValues.get(f);\n        invariant(scopes);\n        for (let scope of scopes)\n          if (scope instanceof FunctionValue) {\n            activeFunctions.push(scope);\n          } else {\n            invariant(scope instanceof Generator);\n            result.add(scope);\n          }\n      }\n    }\n    return Array.from(result);\n  }\n\n  // Determine if a value is effectively referenced by a single additional function.\n  isReferencedOnlyByAdditionalFunction(val: Value): void | FunctionValue {\n    let scopes = this.residualValues.get(val);\n    invariant(scopes !== undefined);\n    let additionalFunction;\n    for (let scope of scopes)\n      if (scope instanceof Generator) {\n        let f;\n        for (let g = scope; g !== undefined && f === undefined; g = this.getGeneratorParent(g))\n          f = this.additionalFunctionGeneratorsInverse.get(g);\n        if (f === undefined) return undefined;\n        if (additionalFunction !== undefined && additionalFunction !== f) return undefined;\n        additionalFunction = f;\n      } else {\n        invariant(scope instanceof FunctionValue);\n        if (this.additionalFunctionGenerators.has(scope)) {\n          if (additionalFunction !== undefined && additionalFunction !== scope) return undefined;\n          additionalFunction = scope;\n        } else {\n          let f = this.isReferencedOnlyByAdditionalFunction(scope);\n          if (f === undefined) return undefined;\n          if (additionalFunction !== undefined && additionalFunction !== f) return undefined;\n          additionalFunction = f;\n        }\n      }\n    return additionalFunction;\n  }\n\n  // Determine whether initialization code for a value should go into the main body, or a more specific initialization body.\n  _getTarget(\n    val: Value,\n    trace?: true\n  ): {\n    body: SerializedBody,\n    usedOnlyByResidualFunctions?: true,\n    commonAncestor?: Scope,\n    description?: string,\n  } {\n    let scopes = this.residualValues.get(val);\n    invariant(scopes !== undefined);\n\n    // All relevant values were visited in at least one scope.\n    invariant(scopes.size >= 1);\n    if (trace) console.log(`  referenced by ${scopes.size} scopes`);\n\n    // First, let's figure out from which function and generator scopes this value is referenced.\n    let functionValues = [];\n    let generators = [];\n    for (let scope of scopes) {\n      if (scope instanceof FunctionValue) {\n        functionValues.push(scope);\n      } else {\n        invariant(scope instanceof Generator);\n        generators.push(scope);\n      }\n    }\n\n    if (trace) {\n      console.log(`    containing ${generators.length} generators:`);\n      for (let g of generators) {\n        let s = \"\";\n        for (let h = g; h !== undefined; h = this.getGeneratorParent(h)) s += \"=>\" + h.getName();\n        console.log(`      ${s}`);\n      }\n      console.log(`    containing ${functionValues.length} function values:`);\n      for (let fv of functionValues)\n        console.log(`      ${fv.__originalName || JSON.stringify(fv.expressionLocation) || fv.constructor.name}`);\n    }\n\n    let referencingOnlyAdditionalFunction = this.isReferencedOnlyByAdditionalFunction(val);\n    if (generators.length === 0) {\n      // This value is only referenced from residual functions.\n      if (\n        referencingOnlyAdditionalFunction === undefined &&\n        this._options.delayInitializations &&\n        !this._options.simpleClosures\n      ) {\n        // We can delay the initialization, and move it into a conditional code block in the residual functions!\n        let body = this.residualFunctions.residualFunctionInitializers.registerValueOnlyReferencedByResidualFunctions(\n          functionValues,\n          val\n        );\n\n        return { body, usedOnlyByResidualFunctions: true, description: \"delay_initializer\" };\n      }\n    }\n\n    if (trace)\n      console.log(\n        `  is referenced only by additional function? ${referencingOnlyAdditionalFunction !== undefined ? \"yes\" : \"no\"}`\n      );\n\n    let getBody = s => {\n      if (s === this.generator) {\n        return this.mainBody;\n      } else {\n        return this.activeGeneratorBodies.get(s);\n      }\n    };\n\n    // flatten all function values into the scopes that use them\n    generators = this._getReferencingGenerators(generators, functionValues, referencingOnlyAdditionalFunction);\n\n    if (referencingOnlyAdditionalFunction === undefined) {\n      // Remove all generators rooted in additional functions,\n      // since we know that there's at least one root that's not in an additional function\n      // which requires the value to be emitted outside of the additional function.\n      generators = generators.filter(generator => {\n        for (let g = generator; g !== undefined; g = this.getGeneratorParent(g))\n          if (this.additionalFunctionGeneratorsInverse.has(g)) return false;\n        return true;\n      });\n      if (generators.length === 0) {\n        // This means that the value was referenced by multiple additional functions, and thus it must have existed at the end of global code execution.\n        // TODO: Emit to the end, not somewhere in the middle of the mainBody.\n        // TODO: Revisit for nested additional functions\n        return { body: this.mainBody };\n      }\n    }\n\n    // This value is referenced from more than one generator.\n    // Let's find the body associated with their common ancestor.\n    let commonAncestor = Array.from(generators).reduce(\n      (x, y) => commonAncestorOf(x, y, this.getGeneratorParent),\n      generators[0]\n    );\n    invariant(commonAncestor);\n    if (trace) console.log(`  common ancestor: ${commonAncestor.getName()}`);\n\n    let body;\n    while (true) {\n      body = getBody(commonAncestor);\n      if (body !== undefined) break;\n      commonAncestor = this.getGeneratorParent(commonAncestor);\n      invariant(commonAncestor !== undefined);\n    }\n\n    // So we have a (common ancestor) body now.\n    invariant(body !== undefined);\n\n    // However, there's a potential problem: That body might belong to a generator\n    // which has nested generators that are currently being processed (they are not \"done\" yet).\n    // This becomes a problem when the value for which we are trying to determine the target body\n    // depends on other values which are only declared in such not-yet-done nested generator!\n    // So we find all such not-yet-done bodies here, and pick a most nested one\n    // which is related to one of the scopes this value is used by.\n    let notYetDoneBodies = new Set();\n    this.emitter.dependenciesVisitor(val, {\n      onAbstractValueWithIdentifier: dependency => {\n        if (trace) console.log(`  depending on abstract value with identifier ${dependency.intrinsicName || \"?\"}`);\n        let declarationBody = this.emitter.getDeclarationBody(dependency);\n        if (declarationBody !== undefined) {\n          if (trace) console.log(`    has declaration body`);\n          for (let b = declarationBody; b !== undefined; b = b.parentBody) {\n            if (notYetDoneBodies.has(b)) break;\n            notYetDoneBodies.add(b);\n          }\n        }\n      },\n    });\n    if (trace) console.log(`  got ${notYetDoneBodies.size} not yet done bodies`);\n    for (let s of generators)\n      for (let g = s; g !== undefined; g = this.getGeneratorParent(g)) {\n        let scopeBody = getBody(g);\n        if (\n          scopeBody !== undefined &&\n          (scopeBody.nestingLevel || 0) > (body.nestingLevel || 0) &&\n          notYetDoneBodies.has(scopeBody)\n        ) {\n          // TODO: If there are multiple such scopeBody's, why is it okay to pick an arbitrary one?\n          body = scopeBody;\n          break;\n        }\n      }\n\n    return { body, commonAncestor };\n  }\n\n  _getValueDebugName(val: Value) {\n    let name;\n    if (val instanceof FunctionValue) {\n      name = val.getName();\n    } else {\n      const id = this.residualHeapValueIdentifiers.getIdentifier(val);\n      invariant(id);\n      name = id.name;\n    }\n    return name;\n  }\n\n  serializeBinding(binding: Binding): BabelNodeIdentifier | BabelNodeMemberExpression {\n    let record = binding.environment;\n    invariant(record instanceof DeclarativeEnvironmentRecord, \"only declarative environments has bindings\");\n\n    let residualFunctionBindings = this.declarativeEnvironmentRecordsBindings.get(record);\n    invariant(\n      residualFunctionBindings,\n      \"all bindings that create abstract values must have at least one call emitted to the generator so the function environment should have been visited\"\n    );\n    let residualBinding = residualFunctionBindings.get(binding.name);\n    invariant(residualBinding, \"any referenced residual binding should have been visited\");\n\n    if (!residualBinding.referentialized) {\n      let additionalFunction = residualBinding.referencedOnlyFromAdditionalFunctions;\n      invariant(additionalFunction, \"residual bindings like this are only caused by leaked bindings in pure functions\");\n      let instance = this.residualFunctionInstances.get(additionalFunction);\n      invariant(instance, \"any serialized function must exist in the scope\");\n      this.residualFunctions.referentializer.referentializeBinding(residualBinding, binding.name, instance);\n    }\n\n    invariant(residualBinding.serializedValue);\n    return ((residualBinding.serializedValue: any): BabelNodeIdentifier | BabelNodeMemberExpression);\n  }\n\n  _declare(\n    emittingToResidualFunction: boolean,\n    bindingType: BabelVariableKind,\n    id: BabelNodeLVal,\n    init: BabelNodeExpression\n  ) {\n    if (emittingToResidualFunction) {\n      let declar = t.variableDeclaration(bindingType, [t.variableDeclarator(id)]);\n      this.mainBody.entries.push(declar);\n      let assignment = t.expressionStatement(t.assignmentExpression(\"=\", id, init));\n      this.emitter.emit(assignment);\n    } else {\n      let declar = t.variableDeclaration(bindingType, [t.variableDeclarator(id, init)]);\n      this.emitter.emit(declar);\n    }\n  }\n\n  serializeValue(val: Value, referenceOnly?: boolean, bindingType?: BabelVariableKind): BabelNodeExpression {\n    invariant(!val.refuseSerialization);\n    if (val instanceof AbstractValue) {\n      if (val.kind === \"widened\") {\n        this.serializedValues.add(val);\n        let name = val.intrinsicName;\n        invariant(name !== undefined);\n        return t.identifier(name);\n      } else if (val.kind === \"widened property\") {\n        this.serializedValues.add(val);\n        return this._serializeAbstractValueHelper(val);\n      }\n    }\n\n    // make sure we're not serializing a class method here\n    if (val instanceof ECMAScriptSourceFunctionValue && this.residualClassMethodInstances.has(val)) {\n      let classMethodInstance = this.residualClassMethodInstances.get(val);\n      invariant(classMethodInstance);\n      // anything other than a class constructor should never go through serializeValue()\n      // so we need to log a nice error message to the user\n      if (classMethodInstance.methodType !== \"constructor\") {\n        let error = new CompilerDiagnostic(\n          \"a class method incorrectly went through the serializeValue() code path\",\n          val.$ECMAScriptCode.loc,\n          \"PP0022\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n    }\n\n    if (this._serializedValueWithIdentifiers.has(val)) {\n      return this.getSerializeObjectIdentifier(val);\n    }\n\n    this.serializedValues.add(val);\n    if (!referenceOnly && ResidualHeapInspector.isLeaf(val)) {\n      let res = this._serializeValue(val);\n      invariant(res !== undefined);\n      return res;\n    }\n    this._serializedValueWithIdentifiers.add(val);\n\n    let target = this._getTarget(val);\n    let oldBody = this.emitter.beginEmitting(val, target.body);\n    let init = this._serializeValue(val);\n\n    let id = this.residualHeapValueIdentifiers.getIdentifier(val);\n    if (this._options.debugIdentifiers !== undefined && this._options.debugIdentifiers.includes(id.name)) {\n      console.log(`Tracing value with identifier ${id.name} (${val.constructor.name}) targetting ${target.body.type}`);\n      this._getTarget(val, true);\n    }\n    let result = id;\n    this.residualHeapValueIdentifiers.incrementReferenceCount(val);\n\n    if (this.residualHeapValueIdentifiers.needsIdentifier(val)) {\n      if (init) {\n        if (this._options.debugScopes) {\n          let scopes = this.residualValues.get(val);\n          invariant(scopes !== undefined);\n          const scopeList = Array.from(scopes).map(s => `\"${s.getName()}\"`).join(\",\");\n          let comment = `${this._getValueDebugName(val)} referenced from scopes [${scopeList}]`;\n          if (target.commonAncestor !== undefined)\n            comment = `${comment} with common ancestor: ${target.commonAncestor.getName()}`;\n          if (target.description !== undefined) comment = `${comment} => ${target.description} `;\n          this.emitter.emit(commentStatement(comment));\n        }\n        if (init !== id) {\n          this._declare(!!target.usedOnlyByResidualFunctions, bindingType || \"var\", id, init);\n        }\n        this.statistics.valueIds++;\n        if (target.usedOnlyByResidualFunctions) this.statistics.delayedValues++;\n      }\n    } else {\n      if (init) {\n        this.residualHeapValueIdentifiers.deleteIdentifier(val);\n        result = init;\n        this.statistics.valuesInlined++;\n      }\n    }\n\n    this.emitter.endEmitting(val, oldBody);\n    return result;\n  }\n\n  _serializeValueIntrinsic(val: Value): BabelNodeExpression {\n    let intrinsicName = val.intrinsicName;\n    invariant(intrinsicName);\n    if (val instanceof ObjectValue && val.intrinsicNameGenerated) {\n      // The intrinsic was generated at a particular point in time.\n      return this.preludeGenerator.convertStringToMember(intrinsicName);\n    } else {\n      // The intrinsic conceptually exists ahead of time.\n      invariant(\n        this.emitter.getBody().type === \"MainGenerator\" ||\n          this.emitter.getBody().type === \"AdditionalFunction\" ||\n          this.emitter.getBody().type === \"DelayInitializations\"\n      );\n      return this.preludeGenerator.memoizeReference(intrinsicName);\n    }\n  }\n\n  _getDescriptorValues(desc: Descriptor): Array<Value> {\n    if (desc.joinCondition !== undefined) return [desc.joinCondition];\n    invariant(desc.value === undefined || desc.value instanceof Value);\n    if (desc.value !== undefined) return [desc.value];\n    invariant(desc.get !== undefined);\n    invariant(desc.set !== undefined);\n    return [desc.get, desc.set];\n  }\n\n  _deleteProperty(location: BabelNodeLVal) {\n    invariant(location.type === \"MemberExpression\");\n    this.emitter.emit(\n      t.expressionStatement(t.unaryExpression(\"delete\", ((location: any): BabelNodeMemberExpression), true))\n    );\n  }\n\n  _assignProperty(\n    locationFn: () => BabelNodeLVal,\n    valueFn: () => BabelNodeExpression,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ) {\n    this.emitter.emit(\n      this._getPropertyAssignment(locationFn, valueFn, mightHaveBeenDeleted, deleteIfMightHaveBeenDeleted)\n    );\n  }\n\n  _getPropertyAssignment(\n    locationFn: () => BabelNodeLVal,\n    valueFn: () => BabelNodeExpression,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ) {\n    let location = locationFn();\n    let value = valueFn();\n    let assignment = t.expressionStatement(t.assignmentExpression(\"=\", location, value));\n    if (mightHaveBeenDeleted) {\n      let condition = t.binaryExpression(\"!==\", value, this.serializeValue(this.realm.intrinsics.empty));\n      let deletion = null;\n      if (deleteIfMightHaveBeenDeleted) {\n        invariant(location.type === \"MemberExpression\");\n        deletion = t.expressionStatement(\n          t.unaryExpression(\"delete\", ((location: any): BabelNodeMemberExpression), true)\n        );\n      }\n      return t.ifStatement(condition, assignment, deletion);\n    } else {\n      return assignment;\n    }\n  }\n\n  _serializeArrayIndexProperties(\n    array: ObjectValue,\n    indexPropertyLength: number,\n    remainingProperties: Map<string, PropertyBinding>\n  ) {\n    let elems = [];\n    for (let i = 0; i < indexPropertyLength; i++) {\n      let key = i + \"\";\n      let propertyBinding = remainingProperties.get(key);\n      let elem = null;\n      // \"propertyBinding === undefined\" means array has a hole in the middle.\n      if (propertyBinding !== undefined) {\n        let descriptor = propertyBinding.descriptor;\n        // \"descriptor === undefined\" means this array item has been deleted.\n        if (\n          descriptor !== undefined &&\n          descriptor.value !== undefined &&\n          this._canEmbedProperty(array, key, descriptor)\n        ) {\n          let elemVal = descriptor.value;\n          invariant(elemVal instanceof Value);\n          let mightHaveBeenDeleted = elemVal.mightHaveBeenDeleted();\n          let delayReason =\n            this.emitter.getReasonToWaitForDependencies(elemVal) ||\n            this.emitter.getReasonToWaitForActiveValue(array, mightHaveBeenDeleted);\n          if (!delayReason) {\n            elem = this.serializeValue(elemVal);\n            remainingProperties.delete(key);\n          }\n        }\n      }\n      elems.push(elem);\n    }\n    return elems;\n  }\n\n  _serializeArrayLengthIfNeeded(\n    val: ObjectValue,\n    numberOfIndexProperties: number,\n    remainingProperties: Map<string, PropertyBinding>\n  ): void {\n    const realm = this.realm;\n    let lenProperty;\n    if (val.isHavocedObject()) {\n      lenProperty = this.realm.evaluateWithoutLeakLogic(() => Get(realm, val, \"length\"));\n    } else {\n      lenProperty = Get(realm, val, \"length\");\n    }\n    // Need to serialize length property if:\n    // 1. array length is abstract.\n    // 2. array length is concrete, but different from number of index properties\n    //  we put into initialization list.\n    if (lenProperty instanceof AbstractValue || To.ToLength(realm, lenProperty) !== numberOfIndexProperties) {\n      if (!(lenProperty instanceof AbstractValue) || lenProperty.kind !== \"widened property\") {\n        this.emitter.emitNowOrAfterWaitingForDependencies([val], () => {\n          this._assignProperty(\n            () => t.memberExpression(this.getSerializeObjectIdentifier(val), t.identifier(\"length\")),\n            () => {\n              return this.serializeValue(lenProperty);\n            },\n            false /*mightHaveBeenDeleted*/\n          );\n        });\n      }\n      remainingProperties.delete(\"length\");\n    }\n  }\n\n  _serializeValueArray(val: ObjectValue): BabelNodeExpression {\n    let remainingProperties = new Map(val.properties);\n\n    const indexPropertyLength = getSuggestedArrayLiteralLength(this.realm, val);\n    // Use the serialized index properties as array initialization list.\n    const initProperties = this._serializeArrayIndexProperties(val, indexPropertyLength, remainingProperties);\n    this._serializeArrayLengthIfNeeded(val, indexPropertyLength, remainingProperties);\n    this._emitObjectProperties(val, remainingProperties);\n    return t.arrayExpression(initProperties);\n  }\n\n  _serializeValueMap(val: ObjectValue): BabelNodeExpression {\n    let kind = val.getKind();\n    let elems = [];\n\n    let entries;\n    if (kind === \"Map\") {\n      entries = val.$MapData;\n    } else {\n      invariant(kind === \"WeakMap\");\n      entries = val.$WeakMapData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n    let mapConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined) continue;\n      let mightHaveBeenDeleted = key.mightHaveBeenDeleted();\n      let delayReason =\n        this.emitter.getReasonToWaitForDependencies(key) ||\n        this.emitter.getReasonToWaitForDependencies(value) ||\n        this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || mapConstructorDoesntTakeArguments);\n      if (delayReason) {\n        this.emitter.emitAfterWaiting(delayReason, [key, value, val], () => {\n          invariant(key !== undefined);\n          invariant(value !== undefined);\n          this.emitter.emit(\n            t.expressionStatement(\n              t.callExpression(\n                t.memberExpression(\n                  this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val),\n                  t.identifier(\"set\")\n                ),\n                [this.serializeValue(key), this.serializeValue(value)]\n              )\n            )\n          );\n        });\n      } else {\n        let serializedKey = this.serializeValue(key);\n        let serializedValue = this.serializeValue(value);\n        let elem = t.arrayExpression([serializedKey, serializedValue]);\n        elems.push(elem);\n      }\n    }\n\n    this._emitObjectProperties(val);\n    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];\n    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);\n  }\n\n  _serializeValueSet(val: ObjectValue): BabelNodeExpression {\n    let kind = val.getKind();\n    let elems = [];\n\n    let entries;\n    if (kind === \"Set\") {\n      entries = val.$SetData;\n    } else {\n      invariant(kind === \"WeakSet\");\n      entries = val.$WeakSetData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n    let setConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined) continue;\n      let mightHaveBeenDeleted = entry.mightHaveBeenDeleted();\n      let delayReason =\n        this.emitter.getReasonToWaitForDependencies(entry) ||\n        this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || setConstructorDoesntTakeArguments);\n      if (delayReason) {\n        this.emitter.emitAfterWaiting(delayReason, [entry, val], () => {\n          invariant(entry !== undefined);\n          this.emitter.emit(\n            t.expressionStatement(\n              t.callExpression(\n                t.memberExpression(\n                  this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val),\n                  t.identifier(\"add\")\n                ),\n                [this.serializeValue(entry)]\n              )\n            )\n          );\n        });\n      } else {\n        let elem = this.serializeValue(entry);\n        elems.push(elem);\n      }\n    }\n\n    this._emitObjectProperties(val);\n    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];\n    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);\n  }\n\n  _serializeValueTypedArrayOrDataView(val: ObjectValue): BabelNodeExpression {\n    let buf = val.$ViewedArrayBuffer;\n    invariant(buf !== undefined);\n    let outlinedArrayBuffer = this.serializeValue(buf, true);\n    this._emitObjectProperties(val);\n    return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [outlinedArrayBuffer]);\n  }\n\n  _serializeValueArrayBuffer(val: ObjectValue): BabelNodeExpression {\n    let elems = [];\n\n    let len = val.$ArrayBufferByteLength;\n    let db = val.$ArrayBufferData;\n    invariant(len !== undefined);\n    invariant(db);\n    let allzero = true;\n    for (let i = 0; i < len; i++) {\n      if (db[i] !== 0) {\n        allzero = false;\n      }\n      let elem = t.numericLiteral(db[i]);\n      elems.push(elem);\n    }\n\n    this._emitObjectProperties(val);\n    if (allzero) {\n      // if they're all zero, just emit the array buffer constructor\n      return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [t.numericLiteral(len)]);\n    } else {\n      // initialize from a byte array otherwise\n      let arrayValue = t.arrayExpression(elems);\n      let consExpr = t.newExpression(this.preludeGenerator.memoizeReference(\"Uint8Array\"), [arrayValue]);\n      // access the Uint8Array.buffer property to extract the created buffer\n      return t.memberExpression(consExpr, t.identifier(\"buffer\"));\n    }\n  }\n\n  _serializeValueFunction(val: FunctionValue): void | BabelNodeExpression {\n    if (val instanceof BoundFunctionValue) {\n      this._emitObjectProperties(val);\n      return t.callExpression(\n        t.memberExpression(this.serializeValue(val.$BoundTargetFunction), t.identifier(\"bind\")),\n        [].concat(\n          this.serializeValue(val.$BoundThis),\n          val.$BoundArguments.map((boundArg, i) => this.serializeValue(boundArg))\n        )\n      );\n    }\n\n    invariant(!(val instanceof NativeFunctionValue), \"all native function values should be intrinsics\");\n    invariant(val instanceof ECMAScriptSourceFunctionValue);\n\n    let instance = this.residualFunctionInstances.get(val);\n    invariant(instance !== undefined);\n    let residualBindings = instance.residualFunctionBindings;\n\n    let inAdditionalFunction = this.isReferencedOnlyByAdditionalFunction(val);\n    if (inAdditionalFunction !== undefined) instance.containingAdditionalFunction = inAdditionalFunction;\n    let delayed = 1;\n    let undelay = () => {\n      if (--delayed === 0) {\n        invariant(instance);\n        // hoist if we are in an additionalFunction\n        if (inAdditionalFunction !== undefined && canHoistFunction(this.realm, val, undefined, new Set())) {\n          instance.insertionPoint = new BodyReference(this.mainBody, this.mainBody.entries.length);\n          instance.containingAdditionalFunction = undefined;\n        } else {\n          instance.insertionPoint = this.emitter.getBodyReference();\n        }\n      }\n    };\n    for (let [boundName, residualBinding] of residualBindings) {\n      let referencedValues = [];\n      let serializeBindingFunc;\n      if (!residualBinding.declarativeEnvironmentRecord) {\n        serializeBindingFunc = () => this._serializeGlobalBinding(boundName, residualBinding);\n      } else {\n        serializeBindingFunc = () => {\n          invariant(instance !== undefined);\n          return this._serializeDeclarativeEnvironmentRecordBinding(residualBinding, boundName, instance);\n        };\n        let bindingValue = residualBinding.value;\n        invariant(bindingValue !== undefined);\n        referencedValues.push(bindingValue);\n        if (inAdditionalFunction !== undefined) {\n          let bindingAdditionalFunction = this.isReferencedOnlyByAdditionalFunction(bindingValue);\n          if (bindingAdditionalFunction !== undefined)\n            residualBinding.referencedOnlyFromAdditionalFunctions = bindingAdditionalFunction;\n        }\n      }\n      delayed++;\n      this.emitter.emitNowOrAfterWaitingForDependencies(referencedValues, () => {\n        serializeBindingFunc();\n        undelay();\n      });\n    }\n    if (val.$FunctionKind === \"classConstructor\") {\n      let homeObject = val.$HomeObject;\n      if (homeObject instanceof ObjectValue && homeObject.$IsClassPrototype) {\n        this._serializeClass(val, homeObject, undelay);\n        return;\n      }\n    }\n    undelay();\n    this._emitObjectProperties(val);\n  }\n\n  _serializeClass(classFunc: ECMAScriptSourceFunctionValue, classPrototype: ObjectValue, undelay: Function): void {\n    let classMethodInstance = this.residualClassMethodInstances.get(classFunc);\n\n    invariant(classMethodInstance !== undefined);\n\n    let classProtoId;\n    let hasSerializedClassProtoId = false;\n    let propertiesToSerialize = new Map();\n\n    // handle class inheritance\n    if (!(classFunc.$Prototype instanceof NativeFunctionValue)) {\n      classMethodInstance.classSuperNode = this.serializeValue(classFunc.$Prototype);\n    }\n\n    let serializeClassPrototypeId = () => {\n      if (!hasSerializedClassProtoId) {\n        let classId = this.getSerializeObjectIdentifier(classFunc);\n        classProtoId = t.identifier(this.intrinsicNameGenerator.generate());\n        hasSerializedClassProtoId = true;\n        this.emitter.emit(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(classProtoId, t.memberExpression(classId, t.identifier(\"prototype\"))),\n          ])\n        );\n      }\n    };\n\n    let serializeClassMethod = (propertyNameOrSymbol, methodFunc) => {\n      invariant(methodFunc instanceof ECMAScriptSourceFunctionValue);\n      if (methodFunc !== classFunc) {\n        // if the method does not have a $HomeObject, it's not a class method\n        if (methodFunc.$HomeObject !== undefined) {\n          this.serializedValues.add(methodFunc);\n          this._serializeClassMethod(propertyNameOrSymbol, methodFunc);\n        } else {\n          // if the method is not part of the class, we have to assign it to the prototype\n          // we can't serialize via emitting the properties as that will emit all\n          // the prototype and we only want to mutate the prototype here\n          serializeClassPrototypeId();\n          let methodId = this.serializeValue(methodFunc);\n          let name;\n\n          if (typeof propertyNameOrSymbol === \"string\") {\n            name = t.identifier(propertyNameOrSymbol);\n          } else {\n            name = this.serializeValue(propertyNameOrSymbol);\n          }\n          invariant(classProtoId !== undefined);\n          this.emitter.emit(\n            t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(classProtoId, name), methodId))\n          );\n        }\n      }\n    };\n\n    let serializeClassProperty = (propertyNameOrSymbol, propertyValue) => {\n      // we handle the prototype via class syntax\n      if (propertyNameOrSymbol === \"prototype\") {\n        this.serializedValues.add(propertyValue);\n      } else if (propertyValue instanceof ECMAScriptSourceFunctionValue && propertyValue.$HomeObject === classFunc) {\n        serializeClassMethod(propertyNameOrSymbol, propertyValue);\n      } else {\n        let prop = classFunc.properties.get(propertyNameOrSymbol);\n        invariant(prop);\n        propertiesToSerialize.set(propertyNameOrSymbol, prop);\n      }\n    };\n\n    // find the all the properties on the class that we need to serialize\n    for (let [propertyName, method] of classFunc.properties) {\n      if (\n        !this.residualHeapInspector.canIgnoreProperty(classFunc, propertyName) &&\n        !ClassPropertiesToIgnore.has(propertyName) &&\n        method.descriptor !== undefined &&\n        !(propertyName === \"length\" && canIgnoreClassLengthProperty(classFunc, method.descriptor, this.logger))\n      ) {\n        withDescriptorValue(propertyName, method.descriptor, serializeClassProperty);\n      }\n    }\n    // pass in the properties and set it so we don't serialize the prototype\n    undelay();\n    this._emitObjectProperties(classFunc, propertiesToSerialize, undefined, undefined, true);\n\n    // handle non-symbol properties\n    for (let [propertyName, method] of classPrototype.properties) {\n      withDescriptorValue(propertyName, method.descriptor, serializeClassMethod);\n    }\n    // handle symbol properties\n    for (let [symbol, method] of classPrototype.symbols) {\n      withDescriptorValue(symbol, method.descriptor, serializeClassMethod);\n    }\n    // assign the AST method key node for the \"constructor\"\n    classMethodInstance.classMethodKeyNode = t.identifier(\"constructor\");\n  }\n\n  _serializeClassMethod(key: string | SymbolValue, methodFunc: ECMAScriptSourceFunctionValue): void {\n    let classMethodInstance = this.residualClassMethodInstances.get(methodFunc);\n\n    invariant(classMethodInstance !== undefined);\n    if (typeof key === \"string\") {\n      classMethodInstance.classMethodKeyNode = t.identifier(key);\n      // as we know the method name is a string again, we can remove the computed status\n      classMethodInstance.classMethodComputed = false;\n    } else if (key instanceof SymbolValue) {\n      classMethodInstance.classMethodKeyNode = this.serializeValue(key);\n    } else {\n      invariant(false, \"Unknown method key type\");\n    }\n    this._serializeValueFunction(methodFunc);\n  }\n\n  // Checks whether a property can be defined via simple assignment, or using object literal syntax.\n  _canEmbedProperty(obj: ObjectValue, key: string | SymbolValue, prop: Descriptor): boolean {\n    if (prop.joinCondition !== undefined) return false;\n\n    let targetDescriptor = this.residualHeapInspector.getTargetIntegrityDescriptor(obj);\n\n    if ((obj instanceof FunctionValue && key === \"prototype\") || (obj.getKind() === \"RegExp\" && key === \"lastIndex\"))\n      return (\n        prop.writable === targetDescriptor.writable && !prop.configurable && !prop.enumerable && !prop.set && !prop.get\n      );\n    else if (\n      prop.writable === targetDescriptor.writable &&\n      prop.configurable === targetDescriptor.configurable &&\n      !!prop.enumerable &&\n      !prop.set &&\n      !prop.get\n    ) {\n      return !(prop.value instanceof AbstractValue && prop.value.kind === \"widened property\");\n    } else {\n      return false;\n    }\n  }\n\n  _findLastObjectPrototype(obj: ObjectValue): ObjectValue {\n    while (obj.$Prototype instanceof ObjectValue) obj = obj.$Prototype;\n    return obj;\n  }\n\n  _serializeValueRegExpObject(val: ObjectValue): BabelNodeExpression {\n    let source = val.$OriginalSource;\n    let flags = val.$OriginalFlags;\n    invariant(typeof source === \"string\");\n    invariant(typeof flags === \"string\");\n    this._emitObjectProperties(val);\n    source = new RegExp(source).source; // add escapes as per 21.2.3.2.4\n    return t.regExpLiteral(source, flags);\n  }\n\n  // Overridable.\n  serializeValueRawObject(val: ObjectValue, skipPrototype: boolean): BabelNodeExpression {\n    let remainingProperties = new Map(val.properties);\n    const dummyProperties = new Set();\n    let props = [];\n    for (let [key, propertyBinding] of val.properties) {\n      if (propertyBinding.pathNode !== undefined) continue; // written to inside loop\n      let descriptor = propertyBinding.descriptor;\n      if (descriptor === undefined || descriptor.value === undefined) continue; // deleted\n      if (this._canEmbedProperty(val, key, descriptor)) {\n        let propValue = descriptor.value;\n        invariant(propValue instanceof Value);\n        if (this.residualHeapInspector.canIgnoreProperty(val, key)) continue;\n        let mightHaveBeenDeleted = propValue.mightHaveBeenDeleted();\n        let serializedKey = this.generator.getAsPropertyNameExpression(key);\n        let delayReason =\n          this.emitter.getReasonToWaitForDependencies(propValue) ||\n          this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted);\n        // Although the property needs to be delayed, we still want to emit dummy \"undefined\"\n        // value as part of the object literal to ensure a consistent property ordering.\n        let serializedValue = voidExpression;\n        if (delayReason) {\n          // May need to be cleaned up later.\n          dummyProperties.add(key);\n        } else {\n          remainingProperties.delete(key);\n          serializedValue = this.serializeValue(propValue);\n        }\n        props.push(t.objectProperty(serializedKey, serializedValue));\n      } else if (descriptor.value instanceof Value && descriptor.value.mightHaveBeenDeleted()) {\n        dummyProperties.add(key);\n        let serializedKey = this.generator.getAsPropertyNameExpression(key);\n        props.push(t.objectProperty(serializedKey, voidExpression));\n      }\n    }\n    this._emitObjectProperties(\n      val,\n      remainingProperties,\n      /*objectPrototypeAlreadyEstablished*/ false,\n      dummyProperties,\n      skipPrototype\n    );\n    return t.objectExpression(props);\n  }\n\n  _serializeValueObjectViaConstructor(val: ObjectValue, skipPrototype: boolean, classConstructor?: Value) {\n    let proto = val.$Prototype;\n    this._emitObjectProperties(\n      val,\n      val.properties,\n      /*objectPrototypeAlreadyEstablished*/ true,\n      undefined,\n      skipPrototype\n    );\n    this.needsAuxiliaryConstructor = true;\n    let serializedProto = this.serializeValue(classConstructor ? classConstructor : proto);\n    return t.sequenceExpression([\n      t.assignmentExpression(\n        \"=\",\n        t.memberExpression(constructorExpression, t.identifier(\"prototype\")),\n        classConstructor ? t.memberExpression(serializedProto, t.identifier(\"prototype\")) : serializedProto\n      ),\n      t.newExpression(constructorExpression, []),\n    ]);\n  }\n\n  serializeValueObject(val: ObjectValue): BabelNodeExpression | void {\n    // If this object is a prototype object that was implicitly created by the runtime\n    // for a constructor, then we can obtain a reference to this object\n    // in a special way that's handled alongside function serialization.\n    let constructor = val.originalConstructor;\n    if (constructor !== undefined) {\n      let prototypeId = this.residualHeapValueIdentifiers.getIdentifier(val);\n      this.emitter.emitNowOrAfterWaitingForDependencies([constructor], () => {\n        invariant(constructor !== undefined);\n        invariant(prototypeId !== undefined);\n        this.serializeValue(constructor);\n        this._emitObjectProperties(val);\n        invariant(prototypeId.type === \"Identifier\");\n        this.residualFunctions.setFunctionPrototype(constructor, prototypeId);\n      });\n      return prototypeId;\n    }\n\n    let kind = val.getKind();\n    switch (kind) {\n      case \"RegExp\":\n        return this._serializeValueRegExpObject(val);\n      case \"Number\":\n        let numberData = val.$NumberData;\n        invariant(numberData !== undefined);\n        numberData.throwIfNotConcreteNumber();\n        invariant(numberData instanceof NumberValue, \"expected number data internal slot to be a number value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Number\"), [t.numericLiteral(numberData.value)]);\n      case \"String\":\n        let stringData = val.$StringData;\n        invariant(stringData !== undefined);\n        stringData.throwIfNotConcreteString();\n        invariant(stringData instanceof StringValue, \"expected string data internal slot to be a string value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"String\"), [t.stringLiteral(stringData.value)]);\n      case \"Boolean\":\n        let booleanData = val.$BooleanData;\n        invariant(booleanData !== undefined);\n        booleanData.throwIfNotConcreteBoolean();\n        invariant(booleanData instanceof BooleanValue, \"expected boolean data internal slot to be a boolean value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Boolean\"), [\n          t.booleanLiteral(booleanData.value),\n        ]);\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        let serializedDateValue = this.serializeValue(dateValue);\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Date\"), [serializedDateValue]);\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        return this._serializeValueTypedArrayOrDataView(val);\n      case \"ArrayBuffer\":\n        return this._serializeValueArrayBuffer(val);\n      case \"ReactElement\":\n        this.residualReactElementSerializer.serializeReactElement(val);\n        return;\n      case \"Map\":\n      case \"WeakMap\":\n        return this._serializeValueMap(val);\n      case \"Set\":\n      case \"WeakSet\":\n        return this._serializeValueSet(val);\n      default:\n        invariant(kind === \"Object\", \"invariant established by visitor\");\n        invariant(this.$ParameterMap === undefined, \"invariant established by visitor\");\n\n        let proto = val.$Prototype;\n        let createViaAuxiliaryConstructor =\n          proto !== this.realm.intrinsics.ObjectPrototype &&\n          this._findLastObjectPrototype(val) === this.realm.intrinsics.ObjectPrototype &&\n          proto instanceof ObjectValue;\n        let { skipPrototype, constructor: _constructor } = getObjectPrototypeMetadata(this.realm, val);\n\n        return createViaAuxiliaryConstructor\n          ? this._serializeValueObjectViaConstructor(val, skipPrototype, _constructor)\n          : this.serializeValueRawObject(val, skipPrototype);\n    }\n  }\n\n  _serializeValueSymbol(val: SymbolValue): BabelNodeExpression {\n    let args = [];\n    if (val.$Description instanceof Value) {\n      let serializedArg = this.serializeValue(val.$Description);\n      invariant(serializedArg);\n      args.push(serializedArg);\n    }\n    // check if symbol value exists in the global symbol map, in that case we emit an invocation of System.for\n    // to look it up\n    let globalReg = this.realm.globalSymbolRegistry.find(e => e.$Symbol === val) !== undefined;\n    if (globalReg) {\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Symbol.for\"), args);\n    } else {\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Symbol\"), args);\n    }\n  }\n\n  _serializeValueProxy(val: ProxyValue): BabelNodeExpression {\n    return t.newExpression(this.preludeGenerator.memoizeReference(\"Proxy\"), [\n      this.serializeValue(val.$ProxyTarget),\n      this.serializeValue(val.$ProxyHandler),\n    ]);\n  }\n\n  _serializeAbstractValueHelper(val: AbstractValue): BabelNodeExpression {\n    let serializedArgs = val.args.map((abstractArg, i) => this.serializeValue(abstractArg));\n    if (val.kind === \"abstractConcreteUnion\") {\n      let abstractIndex = val.args.findIndex(v => v instanceof AbstractValue);\n      invariant(abstractIndex >= 0 && abstractIndex < val.args.length);\n      return serializedArgs[abstractIndex];\n    }\n    let serializedValue = val.buildNode(serializedArgs);\n    if (serializedValue.type === \"Identifier\") {\n      let id = ((serializedValue: any): BabelNodeIdentifier);\n      invariant(\n        !this.preludeGenerator.derivedIds.has(id.name) ||\n          this.emitter.cannotDeclare() ||\n          this.emitter.hasBeenDeclared(val) ||\n          (this.emitter.emittingToAdditionalFunction() && this.referencedDeclaredValues.get(val) === undefined)\n      );\n    }\n    return serializedValue;\n  }\n\n  _serializeAbstractValue(val: AbstractValue): void | BabelNodeExpression {\n    invariant(\n      val.kind !== \"sentinel member expression\" && val.kind !== \"sentinel ToObject\",\n      \"invariant established by visitor\"\n    );\n    if (val.hasIdentifier()) {\n      return this._serializeAbstractValueHelper(val);\n    } else {\n      // This abstract value's dependencies should all be declared\n      // but still need to check them again in case their serialized bodies are in different generator scope.\n      this.emitter.emitNowOrAfterWaitingForDependencies(val.args, () => {\n        const serializedValue = this._serializeAbstractValueHelper(val);\n        let uid = this.getSerializeObjectIdentifier(val);\n        this._declare(this.emitter.cannotDeclare(), \"var\", uid, serializedValue);\n      });\n    }\n  }\n\n  _serializeValue(val: Value): void | BabelNodeExpression {\n    if (val instanceof AbstractValue) {\n      return this._serializeAbstractValue(val);\n    } else if (val.isIntrinsic()) {\n      return this._serializeValueIntrinsic(val);\n    } else if (val instanceof EmptyValue) {\n      this.needsEmptyVar = true;\n      return emptyExpression;\n    } else if (val instanceof UndefinedValue) {\n      return voidExpression;\n    } else if (ResidualHeapInspector.isLeaf(val)) {\n      return t.valueToNode(val.serialize());\n    } else if (val instanceof ObjectValue) {\n      let res;\n      if (val instanceof ProxyValue) {\n        return this._serializeValueProxy(val);\n      } else if (IsArray(this.realm, val)) {\n        res = this._serializeValueArray(val);\n      } else if (val instanceof FunctionValue) {\n        res = this._serializeValueFunction(val);\n      } else {\n        res = this.serializeValueObject(val);\n      }\n      let targetCommand = this.residualHeapInspector.getTargetIntegrityCommand(val);\n      if (targetCommand) {\n        this.emitter.emitNowOrAfterWaitingForDependencies([val], () => {\n          let uid = this.getSerializeObjectIdentifier(val);\n          this.emitter.emit(\n            t.expressionStatement(\n              t.callExpression(this.preludeGenerator.memoizeReference(\"Object.\" + targetCommand), [uid])\n            )\n          );\n        });\n      }\n      return res;\n    } else {\n      invariant(val instanceof SymbolValue);\n      return this._serializeValueSymbol(val);\n    }\n  }\n\n  _serializeGlobalBinding(boundName: string, residualFunctionBinding: ResidualFunctionBinding) {\n    invariant(!residualFunctionBinding.declarativeEnvironmentRecord);\n    if (!residualFunctionBinding.serializedValue) {\n      residualFunctionBinding.referentialized = true;\n      if (boundName === \"undefined\") {\n        residualFunctionBinding.serializedValue = voidExpression;\n      } else {\n        let value = this.realm.getGlobalLetBinding(boundName);\n        // Check for let binding vs global property\n        if (value) {\n          let rval = residualFunctionBinding.value;\n          invariant(rval !== undefined && value.equals(rval));\n          let id = this.serializeValue(rval, true, \"let\");\n          // increment ref count one more time as the value has been\n          // referentialized (stored in a variable) by serializeValue\n          this.residualHeapValueIdentifiers.incrementReferenceCount(rval);\n          residualFunctionBinding.serializedValue = id;\n        } else {\n          residualFunctionBinding.serializedValue = this.preludeGenerator.globalReference(boundName);\n        }\n      }\n    }\n  }\n\n  _withGeneratorScope(\n    type: \"Generator\" | \"AdditionalFunction\",\n    generator: Generator,\n    callback: SerializedBody => void\n  ): Array<BabelNodeStatement> {\n    let newBody = { type, parentBody: undefined, entries: [], done: false };\n    let isChild = type === \"Generator\";\n    let oldBody = this.emitter.beginEmitting(generator, newBody, /*isChild*/ isChild);\n    this.activeGeneratorBodies.set(generator, newBody);\n    callback(newBody);\n    this.activeGeneratorBodies.delete(generator);\n    const statements = this.emitter.endEmitting(generator, oldBody, /*isChild*/ isChild).entries;\n    if (this._options.debugScopes) {\n      let comment = `generator \"${generator.getName()}\"`;\n      let parent = this.getGeneratorParent(generator);\n      if (parent !== undefined) {\n        comment = `${comment} with parent \"${parent.getName()}\"`;\n      }\n      statements.unshift(commentStatement(\"begin \" + comment));\n      statements.push(commentStatement(\"end \" + comment));\n    }\n    return statements;\n  }\n\n  _getContext(): SerializationContext {\n    // TODO #482: Values serialized by nested generators would currently only get defined\n    // along the code of the nested generator; their definitions need to get hoisted\n    // or repeated so that they are accessible and defined from all using scopes\n    let context = {\n      serializeValue: this.serializeValue.bind(this),\n      serializeBinding: this.serializeBinding.bind(this),\n      serializeGenerator: (generator: Generator): Array<BabelNodeStatement> =>\n        this._withGeneratorScope(\"Generator\", generator, () => generator.serialize(context)),\n      emit: (statement: BabelNodeStatement) => {\n        this.emitter.emit(statement);\n      },\n      emitDefinePropertyBody: this.emitDefinePropertyBody.bind(this, false, undefined),\n      canOmit: (value: AbstractValue) => {\n        return !this.referencedDeclaredValues.has(value);\n      },\n      declare: (value: AbstractValue) => {\n        this.emitter.declare(value);\n      },\n    };\n    return context;\n  }\n\n  _shouldBeWrapped(body: Array<any>) {\n    for (let i = 0; i < body.length; i++) {\n      let item = body[i];\n      if (item.type === \"ExpressionStatement\") {\n        continue;\n      } else if (item.type === \"VariableDeclaration\" || item.type === \"FunctionDeclaration\") {\n        return true;\n      } else if (item.type === \"BlockStatement\") {\n        if (this._shouldBeWrapped(item.body)) {\n          return true;\n        }\n      } else if (item.type === \"IfStatement\") {\n        if (item.alternate) {\n          if (this._shouldBeWrapped(item.alternate.body)) {\n            return true;\n          }\n        }\n        if (item.consequent) {\n          if (this._shouldBeWrapped(item.consequent.body)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  _serializeAdditionalFunctionGeneratorAndEffects(generator: Generator, postGeneratorCallback: () => void) {\n    let context = this._getContext();\n    return this._withGeneratorScope(\"AdditionalFunction\", generator, newBody => {\n      let oldSerialiedValueWithIdentifiers = this._serializedValueWithIdentifiers;\n      this._serializedValueWithIdentifiers = new Set(Array.from(this._serializedValueWithIdentifiers));\n      try {\n        generator.serialize(context);\n        if (postGeneratorCallback) postGeneratorCallback();\n      } finally {\n        this._serializedValueWithIdentifiers = oldSerialiedValueWithIdentifiers;\n      }\n    });\n  }\n\n  // result -- serialize it, a return statement will be generated later, must be a Value\n  // Generator -- visit all entries\n  // Bindings -- only need to serialize bindings if they're captured by some nested function?\n  //          -- need to apply them and maybe need to revisit functions in ancestors to make sure\n  //          -- we don't overwrite anything they capture\n  // PropertyBindings -- visit any property bindings that aren't to createdobjects\n  // CreatedObjects -- should take care of itself\n  _serializeAdditionalFunctionEffects(additionalFunctionValue: FunctionValue, effects: Effects) {\n    let [result, , , modifiedProperties, createdObjects] = effects;\n    for (let propertyBinding of modifiedProperties.keys()) {\n      let object = propertyBinding.object;\n      if (object instanceof ObjectValue && createdObjects.has(object)) continue;\n      if (object.refuseSerialization) continue;\n      if (object.isIntrinsic()) continue;\n      invariant(object instanceof ObjectValue);\n      this._emitProperty(object, propertyBinding.key, propertyBinding.descriptor, true);\n    }\n    invariant(result instanceof Value, \"TODO: support PossiblyNormalCompletion return from additional function\");\n    // Handle ModifiedBindings\n    let additionalFunctionValueInfo = this.additionalFunctionValueInfos.get(additionalFunctionValue);\n    invariant(additionalFunctionValueInfo);\n    for (let [modifiedBinding, residualBinding] of additionalFunctionValueInfo.modifiedBindings) {\n      let newVal = modifiedBinding.value;\n      invariant(newVal);\n      residualBinding.additionalValueSerialized = this.serializeValue(newVal);\n    }\n    if (!(result instanceof UndefinedValue)) this.emitter.emit(t.returnStatement(this.serializeValue(result)));\n\n    const lazyHoistedReactNodes = this.residualReactElementSerializer.serializeLazyHoistedNodes();\n    Array.prototype.push.apply(this.mainBody.entries, lazyHoistedReactNodes);\n  }\n\n  _serializeAdditionalFunction(\n    additionalFunctionValue: FunctionValue,\n    { effects, transforms }: AdditionalFunctionEffects\n  ) {\n    let shouldEmitLog = !this.residualHeapValueIdentifiers.collectValToRefCountOnly;\n    let [, generator, , , createdObjects] = effects;\n    let nestedFunctions = new Set([...createdObjects].filter(object => object instanceof FunctionValue));\n    // Allows us to emit function declarations etc. inside of this additional\n    // function instead of adding them at global scope\n    // TODO: make sure this generator isn't getting mutated oddly\n    ((nestedFunctions: any): Set<FunctionValue>).forEach(val => this.additionalFunctionValueNestedFunctions.add(val));\n    let body = this.realm.withEffectsAppliedInGlobalEnv(\n      this._serializeAdditionalFunctionGeneratorAndEffects.bind(\n        this,\n        generator,\n        this._serializeAdditionalFunctionEffects.bind(this, additionalFunctionValue, effects)\n      ),\n      effects\n    );\n    invariant(additionalFunctionValue instanceof ECMAScriptSourceFunctionValue);\n    for (let transform of transforms) {\n      transform(body);\n    }\n    this.rewrittenAdditionalFunctions.set(additionalFunctionValue, body);\n    // re-resolve initialized modules to include things from additional functions\n    this.modules.resolveInitializedModules();\n    if (shouldEmitLog && this.modules.moduleIds.size > 0)\n      console.log(\n        `=== ${this.modules.initializedModules.size} of ${this.modules.moduleIds\n          .size} modules initialized after additional function ${additionalFunctionValue.intrinsicName\n          ? additionalFunctionValue.intrinsicName\n          : \"\"}`\n      );\n  }\n\n  prepareAdditionalFunctionValues() {\n    let additionalFVEffects = this.additionalFunctionValuesAndEffects;\n    if (additionalFVEffects)\n      for (let [additionalFunctionValue, { effects }] of additionalFVEffects.entries()) {\n        let generator = effects[1];\n        invariant(!this.additionalFunctionGenerators.has(additionalFunctionValue));\n        this.additionalFunctionGenerators.set(additionalFunctionValue, generator);\n        invariant(!this.additionalFunctionGeneratorsInverse.has(generator));\n        this.additionalFunctionGeneratorsInverse.set(generator, additionalFunctionValue);\n      }\n  }\n\n  processAdditionalFunctionValues(): Map<FunctionValue, Array<BabelNodeStatement>> {\n    let additionalFVEffects = this.additionalFunctionValuesAndEffects;\n    if (!additionalFVEffects) return this.rewrittenAdditionalFunctions;\n    for (let [additionalFunctionValue, effects] of additionalFVEffects.entries()) {\n      this._serializeAdditionalFunction(additionalFunctionValue, effects);\n    }\n    return this.rewrittenAdditionalFunctions;\n  }\n\n  // Hook point for any serialization needs to be done after generator serialization is complete.\n  postGeneratorSerialization(): void {\n    // For overriding only.\n  }\n\n  serialize(): BabelNodeFile {\n    this.prepareAdditionalFunctionValues();\n\n    this.generator.serialize(this._getContext());\n    invariant(this.emitter.declaredCount() <= this.preludeGenerator.derivedIds.size);\n\n    this.postGeneratorSerialization();\n\n    // TODO #20: add timers\n\n    // TODO #21: add event listeners\n\n    for (let [moduleId, moduleValue] of this.modules.initializedModules)\n      this.requireReturns.set(moduleId, this.serializeValue(moduleValue));\n\n    // Make sure additional functions get serialized.\n    let rewrittenAdditionalFunctions = this.processAdditionalFunctionValues();\n\n    Array.prototype.push.apply(this.prelude, this.preludeGenerator.prelude);\n\n    this.modules.resolveInitializedModules();\n\n    this.emitter.finalize();\n\n    this.residualFunctions.residualFunctionInitializers.factorifyInitializers(this.factoryNameGenerator);\n    let { unstrictFunctionBodies, strictFunctionBodies, requireStatistics } = this.residualFunctions.spliceFunctions(\n      rewrittenAdditionalFunctions\n    );\n    if (this.modules.moduleIds.size > 0 && !this.residualHeapValueIdentifiers.collectValToRefCountOnly) {\n      console.log(\n        `=== ${this.modules.initializedModules.size} of ${this.modules.moduleIds\n          .size} modules initialized, ${requireStatistics.replaced} of ${requireStatistics.count} require calls inlined.`\n      );\n    }\n\n    // add strict modes\n    let strictDirective = t.directive(t.directiveLiteral(\"use strict\"));\n    let globalDirectives = [];\n    if (!this.realm.isStrict && !unstrictFunctionBodies.length && strictFunctionBodies.length) {\n      // no unstrict functions, only strict ones\n      globalDirectives.push(strictDirective);\n    } else if (unstrictFunctionBodies.length && strictFunctionBodies.length) {\n      // strict and unstrict functions\n      funcLoop: for (let node of strictFunctionBodies) {\n        if (t.isFunctionExpression(node)) {\n          let func = ((node: any): BabelNodeFunctionExpression);\n          if (func.body.directives) {\n            for (let directive of func.body.directives) {\n              if (directive.value.value === \"use strict\") {\n                // already have a use strict directive\n                continue funcLoop;\n              }\n            }\n          } else func.body.directives = [];\n\n          func.body.directives.unshift(strictDirective);\n        }\n      }\n    }\n\n    // build ast\n    if (this.needsEmptyVar) {\n      this.prelude.push(t.variableDeclaration(\"var\", [t.variableDeclarator(emptyExpression, t.objectExpression([]))]));\n    }\n    if (this.needsAuxiliaryConstructor) {\n      this.prelude.push(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(constructorExpression, t.functionExpression(null, [], t.blockStatement([]))),\n        ])\n      );\n    }\n\n    let body = this.prelude.concat(this.emitter.getBody().entries);\n    factorifyObjects(body, this.factoryNameGenerator);\n\n    let ast_body = [];\n    if (this.preludeGenerator.declaredGlobals.size > 0)\n      ast_body.push(\n        t.variableDeclaration(\n          \"var\",\n          Array.from(this.preludeGenerator.declaredGlobals).map(key => t.variableDeclarator(t.identifier(key)))\n        )\n      );\n    if (body.length) {\n      if (this.realm.isCompatibleWith(\"node-source-maps\")) {\n        ast_body.push(\n          t.expressionStatement(\n            t.callExpression(\n              t.memberExpression(\n                t.callExpression(t.identifier(\"require\"), [t.stringLiteral(\"source-map-support\")]),\n                t.identifier(\"install\")\n              ),\n              []\n            )\n          )\n        );\n      }\n\n      if (this._shouldBeWrapped(body)) {\n        let globalExpression = this.realm.isCompatibleWith(\"node-cli\") ? t.identifier(\"global\") : t.thisExpression();\n\n        let functionExpression = t.functionExpression(null, [], t.blockStatement(body, globalDirectives));\n        let callExpression = this.preludeGenerator.usesThis\n          ? t.callExpression(t.memberExpression(functionExpression, t.identifier(\"call\")), [globalExpression])\n          : t.callExpression(functionExpression, []);\n        ast_body.push(t.expressionStatement(callExpression));\n      } else {\n        Array.prototype.push.apply(ast_body, body);\n      }\n    }\n\n    // Make sure that the visitor visited as many values as the serializer\n    invariant(\n      this.serializedValues.size === this.residualValues.size,\n      \"serialized \" + this.serializedValues.size + \" of \" + this.residualValues.size\n    );\n\n    // TODO: find better way to do this?\n    // revert changes to functionInstances in case we do multiple serialization passes\n    for (let instance of this.residualFunctionInstances.values()) {\n      this.referentializer.cleanInstance(instance);\n    }\n\n    let program_directives = [];\n    if (this.realm.isStrict) program_directives.push(strictDirective);\n    return t.file(t.program(ast_body, program_directives));\n  }\n}\n"]}