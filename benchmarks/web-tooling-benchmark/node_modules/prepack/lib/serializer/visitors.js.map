{"version":3,"sources":["../../src/serializer/visitors.js"],"names":["t","markVisited","node","data","_renamedOnce","shouldVisit","replaceName","path","residualFunctionBinding","name","scope","hasBinding","declarativeEnvironmentRecord","value","undefined","serializedValue","type","replaceWith","getLiteralTruthiness","isBooleanLiteral","isNumericLiteral","isStringLiteral","known","isFunctionExpression","isArrowFunctionExpression","isRegExpLiteral","isClassExpression","superClass","body","length","isObjectExpression","properties","isArrayExpression","elements","isNullLiteral","canShareFunctionBody","duplicateFunctionInfo","unbound","modified","usesThis","functionInfo","size","ClosureRefReplacer","ReferencedIdentifier","state","ignorePath","residualFunctionBindings","get","CallExpression","requireReturns","getModuleIdIfNodeIsRequireFunction","moduleId","requireStatistics","count","has","callee","new_node","replaced","ids","getBindingIdentifierPaths","nestedPath","FunctionExpression","isProgram","parentPath","functionExpression","functionTag","uniqueOrderedTag","factoryFunctionInfos","factoryId","callExpression","memberExpression","identifier","IfStatement","exit","testTruthiness","test","consequent","alternate","remove","ConditionalExpression","LogicalExpression","leftTruthiness","left","operator","right","WhileStatement","visitName","add","parent","isLabeledStatement","isBreakStatement","isContinueStatement","ClosureRefVisitor","innerName","usesArguments","ThisExpression","getBindingIdentifiers"],"mappings":"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","file":"visitors.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport { FunctionValue } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport { convertExpressionToJSXIdentifier } from \"../react/jsx\";\nimport type { BabelNodeExpression, BabelNodeCallExpression, BabelNodeFunctionExpression } from \"babel-types\";\nimport type { BabelTraversePath, BabelTraverseScope } from \"babel-traverse\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport type { TryQuery, FunctionInfo, FactoryFunctionInfo, ResidualFunctionBinding } from \"./types.js\";\nimport { nullExpression } from \"../utils/internalizer.js\";\n\nexport type ClosureRefVisitorState = {\n  tryQuery: TryQuery<*>,\n  val: FunctionValue,\n  functionInfo: FunctionInfo,\n  realm: Realm,\n};\n\nexport type ClosureRefReplacerState = {\n  residualFunctionBindings: Map<string, ResidualFunctionBinding>,\n  modified: Set<string>,\n  requireReturns: Map<number | string, BabelNodeExpression>,\n  requireStatistics: { replaced: 0, count: 0 },\n  getModuleIdIfNodeIsRequireFunction:\n    | void\n    | ((scope: BabelTraverseScope, node: BabelNodeCallExpression) => void | number | string),\n  factoryFunctionInfos: Map<number, FactoryFunctionInfo>,\n};\n\nfunction markVisited(node, data) {\n  (node: any)._renamedOnce = data;\n}\n\nfunction shouldVisit(node, data) {\n  return (node: any)._renamedOnce !== data;\n}\n\n// replaceWith causes the node to be re-analyzed, so to prevent double replacement\n// we add this property on the node to mark it such that it does not get replaced\n// again on this pass\n// TODO: Make this work when replacing with arbitrary BabelNodeExpressions. Currently\n//       if the node that we're substituting contains identifiers as children,\n//       they will be visited again and possibly transformed.\n//       If necessary we could implement this by following node.parentPath and checking\n//       if any parent nodes are marked visited, but that seem unnecessary right now.let closureRefReplacer = {\nfunction replaceName(path, residualFunctionBinding, name, data) {\n  // Let's skip names that are bound\n  if (path.scope.hasBinding(name, /*noGlobals*/ true)) return;\n\n  // Let's skip bindings that are referring to\n  // 1) something global (without an environment record), and\n  // 2) have not been assigned a value (which would mean that they have a var/let binding and Prepack will take the liberty to rename them).\n  if (residualFunctionBinding.declarativeEnvironmentRecord === null && residualFunctionBinding.value === undefined)\n    return;\n\n  if (shouldVisit(path.node, data)) {\n    markVisited(residualFunctionBinding.serializedValue, data);\n    let serializedValue = residualFunctionBinding.serializedValue;\n\n    if (path.node.type === \"JSXIdentifier\" || path.node.type === \"JSXMemberIdentifier\") {\n      path.replaceWith(convertExpressionToJSXIdentifier((serializedValue: any), true));\n    } else {\n      path.replaceWith(serializedValue);\n    }\n  }\n}\n\nfunction getLiteralTruthiness(node): { known: boolean, value?: boolean } {\n  // In the return value, 'known' is true only if this is a literal of known truthiness and with no side effects; if 'known' is true, 'value' is its truthiness.\n  if (t.isBooleanLiteral(node) || t.isNumericLiteral(node) || t.isStringLiteral(node)) {\n    return { known: true, value: !!node.value };\n  }\n  if (\n    t.isFunctionExpression(node) ||\n    t.isArrowFunctionExpression(node) ||\n    t.isRegExpLiteral(node) ||\n    (t.isClassExpression(node) && node.superClass === null && node.body.body.length === 0) ||\n    (t.isObjectExpression(node) && node.properties.length === 0) ||\n    (t.isArrayExpression(node) && node.elements.length === 0)\n  ) {\n    return { known: true, value: true };\n  }\n  if (t.isNullLiteral(node)) {\n    return { known: true, value: false };\n  }\n  return { known: false };\n}\n\nfunction canShareFunctionBody(duplicateFunctionInfo: FactoryFunctionInfo): boolean {\n  // Only share function when:\n  // 1. it does not access any free variables.\n  // 2. it does not use \"this\".\n  const { unbound, modified, usesThis } = duplicateFunctionInfo.functionInfo;\n  return unbound.size === 0 && modified.size === 0 && !usesThis;\n}\n\nexport let ClosureRefReplacer = {\n  ReferencedIdentifier(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    if (ignorePath(path)) return;\n\n    let residualFunctionBindings = state.residualFunctionBindings;\n    let name = path.node.name;\n    let residualFunctionBinding = residualFunctionBindings.get(name);\n    if (residualFunctionBinding) replaceName(path, residualFunctionBinding, name, residualFunctionBindings);\n  },\n\n  CallExpression(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    // Here we apply the require optimization by replacing require calls with their\n    // corresponding initialized modules.\n    let requireReturns = state.requireReturns;\n    if (state.getModuleIdIfNodeIsRequireFunction === undefined) return;\n    let moduleId = state.getModuleIdIfNodeIsRequireFunction(path.scope, path.node);\n    if (moduleId === undefined) return;\n\n    state.requireStatistics.count++;\n    if (state.modified.has(path.node.callee.name)) return;\n\n    let new_node = requireReturns.get(\"\" + moduleId);\n    if (new_node !== undefined) {\n      markVisited(new_node, state.residualFunctionBindings);\n      path.replaceWith(new_node);\n      state.requireStatistics.replaced++;\n    }\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    let residualFunctionBindings = state.residualFunctionBindings;\n    let ids = path.getBindingIdentifierPaths();\n    for (let name in ids) {\n      let residualFunctionBinding = residualFunctionBindings.get(name);\n      if (residualFunctionBinding) {\n        let nestedPath = ids[name];\n        replaceName(nestedPath, residualFunctionBinding, name, residualFunctionBindings);\n      }\n    }\n  },\n\n  // TODO: handle FunctionDeclaration.\n  // Replace \"function () {}\" ==> \"factory_id.bind(null)\".\n  FunctionExpression(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    if (t.isProgram(path.parentPath.parentPath.node)) {\n      // Our goal is replacing duplicate nested function so skip root residual function itself.\n      // This assumes the root function is wrapped with: t.file(t.program([t.expressionStatement(rootFunction).\n      return;\n    }\n\n    const functionExpression: BabelNodeFunctionExpression = path.node;\n    const functionTag = ((functionExpression.body: any): FunctionBodyAstNode).uniqueOrderedTag;\n    if (!functionTag) {\n      // Un-interpreted nested function.\n      return;\n    }\n    const duplicateFunctionInfo = state.factoryFunctionInfos.get(functionTag);\n    if (duplicateFunctionInfo && canShareFunctionBody(duplicateFunctionInfo)) {\n      const { factoryId } = duplicateFunctionInfo;\n      path.replaceWith(t.callExpression(t.memberExpression(factoryId, t.identifier(\"bind\")), [nullExpression]));\n    }\n  },\n\n  // A few very simple dead code elimination helpers. Eventually these should be subsumed by the partial evaluators.\n  IfStatement: {\n    exit: function(path: BabelTraversePath, state: ClosureRefReplacerState) {\n      let node = path.node;\n      let testTruthiness = getLiteralTruthiness(node.test);\n      if (testTruthiness.known) {\n        if (testTruthiness.value) {\n          // Strictly speaking this is not safe: Annex B.3.4 allows FunctionDeclarations as the body of IfStatements in sloppy mode,\n          // which have weird hoisting behavior: `console.log(typeof f); if (true) function f(){} console.log(typeof f)` will print 'undefined', 'function', but\n          // `console.log(typeof f); function f(){} console.log(typeof f)` will print 'function', 'function'.\n          // However, Babylon can't parse these, so it doesn't come up.\n          path.replaceWith(node.consequent);\n        } else {\n          if (node.alternate !== null) {\n            path.replaceWith(node.alternate);\n          } else {\n            path.remove();\n          }\n        }\n      }\n    },\n  },\n\n  ConditionalExpression: {\n    exit: function(path: BabelTraversePath, state: ClosureRefReplacerState) {\n      let node = path.node;\n      let testTruthiness = getLiteralTruthiness(node.test);\n      if (testTruthiness.known) {\n        path.replaceWith(testTruthiness.value ? node.consequent : node.alternate);\n      }\n    },\n  },\n\n  LogicalExpression: {\n    exit: function(path: BabelTraversePath, state: ClosureRefReplacerState) {\n      let node = path.node;\n      let leftTruthiness = getLiteralTruthiness(node.left);\n      if (node.operator === \"&&\" && leftTruthiness.known) {\n        path.replaceWith(leftTruthiness.value ? node.right : node.left);\n      } else if (node.operator === \"||\" && leftTruthiness.known) {\n        path.replaceWith(leftTruthiness.value ? node.left : node.right);\n      }\n    },\n  },\n\n  WhileStatement: {\n    exit: function(path: BabelTraversePath, state: ClosureRefReplacerState) {\n      let node = path.node;\n      let testTruthiness = getLiteralTruthiness(node.test);\n      if (testTruthiness.known && !testTruthiness.value) {\n        path.remove();\n      }\n    },\n  },\n};\n\nfunction visitName(path, state, name, modified) {\n  // Is the name bound to some local identifier? If so, we don't need to do anything\n  if (path.scope.hasBinding(name, /*noGlobals*/ true)) return;\n\n  // Otherwise, let's record that there's an unbound identifier\n  state.functionInfo.unbound.add(name);\n  if (modified) state.functionInfo.modified.add(name);\n}\n\nfunction ignorePath(path: BabelTraversePath) {\n  let parent = path.parent;\n  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);\n}\n\n// TODO #886: doesn't check that `arguments` and `this` is in top function\nexport let ClosureRefVisitor = {\n  ReferencedIdentifier(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    if (ignorePath(path)) return;\n\n    let innerName = path.node.name;\n    if (innerName === \"arguments\") {\n      state.functionInfo.usesArguments = true;\n      return;\n    }\n    visitName(path, state, innerName, false);\n  },\n\n  ThisExpression(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    state.functionInfo.usesThis = true;\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    for (let name in path.getBindingIdentifiers()) {\n      visitName(path, state, name, true);\n    }\n  },\n};\n"]}