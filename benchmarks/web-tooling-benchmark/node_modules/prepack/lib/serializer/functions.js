"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Functions = undefined;

var _completions = require("../completions.js");

var _errors = require("../errors.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _realm = require("../realm.js");

var _errors2 = require("../utils/errors.js");

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _modules = require("../utils/modules.js");

var _babelTemplate = require("babel-template");

var _babelTemplate2 = _interopRequireDefault(_babelTemplate);

var _types = require("./types");

var _reconcilation = require("../react/reconcilation.js");

var _utils = require("../react/utils.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _utils2 = require("../intrinsics/prepack/utils.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Functions {
  constructor(realm, functions, moduleTracer) {
    this.realm = realm;
    this.functions = functions;
    this.moduleTracer = moduleTracer;
    this.writeEffects = new Map();
    this.functionExpressions = new Map();
  }
  // maps back from FunctionValue to the expression string


  _generateAdditionalFunctionCallsFromInput() {
    // lookup functions
    let additionalFunctions = [];
    for (let fname of this.functions || []) {
      let fun;
      let fnameAst = (0, _babelTemplate2.default)(fname)({}).expression;
      if (fnameAst) {
        try {
          let e = (0, _errors2.ignoreErrorsIn)(this.realm, () => this.realm.evaluateNodeForEffectsInGlobalEnv(fnameAst));
          fun = e ? e[0] : undefined;
        } catch (ex) {
          if (!(ex instanceof _completions.ThrowCompletion)) throw ex;
        }
      }
      if (!(fun instanceof _index.FunctionValue)) {
        let error = new _errors.CompilerDiagnostic(`Additional function ${fname} not defined in the global environment`, null, "PP1001", "FatalError");
        this.realm.handleError(error);
        throw new _errors.FatalError();
      }
      this.functionExpressions.set(fun, fname);
      additionalFunctions.push(fun);
    }
    return additionalFunctions;
  }

  __generateAdditionalFunctionsMap(globalKey) {
    let recordedAdditionalFunctions = new Map();
    let realm = this.realm;
    let globalRecordedAdditionalFunctionsMap = this.moduleTracer.modules.logger.tryQuery(() => (0, _index2.Get)(realm, realm.$GlobalObject, globalKey), realm.intrinsics.undefined);
    (0, _invariant2.default)(globalRecordedAdditionalFunctionsMap instanceof _index.ObjectValue);
    for (let funcId of globalRecordedAdditionalFunctionsMap.getOwnPropertyKeysArray()) {
      let property = globalRecordedAdditionalFunctionsMap.properties.get(funcId);
      if (property) {
        let value = property.descriptor && property.descriptor.value;

        if (value instanceof _index.ECMAScriptSourceFunctionValue) {
          // additional function logic
          recordedAdditionalFunctions.set(value, { funcId });
          continue;
        } else if (value instanceof _index.ObjectValue) {
          // React component tree logic
          let config = (0, _index2.Get)(realm, value, "config");
          let rootComponent = (0, _index2.Get)(realm, value, "rootComponent");
          let validConfig = config instanceof _index.ObjectValue || config === realm.intrinsics.undefined;
          let validRootComponent = rootComponent instanceof _index.ECMAScriptSourceFunctionValue || rootComponent instanceof _index.AbstractValue && (0, _utils.valueIsKnownReactAbstraction)(this.realm, rootComponent);

          if (validConfig && validRootComponent) {
            recordedAdditionalFunctions.set(rootComponent, {
              funcId,
              config: (0, _utils.convertConfigObjectToReactComponentTreeConfig)(realm, config)
            });
          }
          continue;
        }
        realm.handleError(new _errors.CompilerDiagnostic(`Additional Function Value ${funcId} is an invalid value`, undefined, "PP0001", "FatalError"));
        throw new _errors.FatalError("invalidf Additional Function value");
      }
    }
    return recordedAdditionalFunctions;
  }

  _createAdditionalEffects(effects) {
    return {
      effects,
      transforms: []
    };
  }

  _generateWriteEffectsForReactComponentTree(componentType, effects, componentTreeState, evaluatedNode) {
    let additionalFunctionEffects = this._createAdditionalEffects(effects);
    let value = effects[0];

    if (value === this.realm.intrinsics.undefined) {
      // if we get undefined, then this component tree failed and a message was already logged
      // in the reconciler
      return;
    }
    if (value instanceof _completions.Completion) {
      // TODO we don't support this yet, but will do very soon
      // to unblock work, we'll just return at this point right now
      evaluatedNode.status = "UNSUPPORTED_COMPLETION";
      return;
    }
    (0, _invariant2.default)(value instanceof _index.Value);
    if ((0, _utils.valueIsClassComponent)(this.realm, componentType)) {
      if (componentTreeState.status === "SIMPLE") {
        // if the root component was a class and is now simple, we can convert it from a class
        // component to a functional component
        (0, _utils.convertSimpleClassComponentToFunctionalComponent)(this.realm, componentType, additionalFunctionEffects);
        (0, _utils.normalizeFunctionalComponentParamaters)(componentType);
        this.writeEffects.set(componentType, additionalFunctionEffects);
      } else {
        let prototype = (0, _index2.Get)(this.realm, componentType, "prototype");
        (0, _invariant2.default)(prototype instanceof _index.ObjectValue);
        let renderMethod = (0, _index2.Get)(this.realm, prototype, "render");
        (0, _invariant2.default)(renderMethod instanceof _index.ECMAScriptSourceFunctionValue);
        this.writeEffects.set(renderMethod, additionalFunctionEffects);
      }
    } else {
      if (componentTreeState.status === "COMPLEX") {
        (0, _utils.convertFunctionalComponentToComplexClassComponent)(this.realm, componentType, componentTreeState.componentType, additionalFunctionEffects);
        let prototype = (0, _index2.Get)(this.realm, componentType, "prototype");
        (0, _invariant2.default)(prototype instanceof _index.ObjectValue);
        let renderMethod = (0, _index2.Get)(this.realm, prototype, "render");
        (0, _invariant2.default)(renderMethod instanceof _index.ECMAScriptSourceFunctionValue);
        this.writeEffects.set(renderMethod, additionalFunctionEffects);
      } else {
        (0, _utils.normalizeFunctionalComponentParamaters)(componentType);
        this.writeEffects.set(componentType, additionalFunctionEffects);
      }
    }
  }

  checkRootReactComponentTrees(statistics, react) {
    let recordedReactRootValues = this.__generateAdditionalFunctionsMap("__reactComponentTrees");
    // Get write effects of the components
    for (let [componentRoot, { config }] of recordedReactRootValues) {
      (0, _invariant2.default)(config);
      let reconciler = new _reconcilation.Reconciler(this.realm, this.moduleTracer, statistics, react, config);
      let componentType = (0, _utils.getComponentTypeFromRootValue)(this.realm, componentRoot);
      if (componentType === null) {
        continue;
      }
      let evaluatedRootNode = (0, _utils.createReactEvaluatedNode)("ROOT", (0, _utils.getComponentName)(this.realm, componentType));
      statistics.evaluatedRootNodes.push(evaluatedRootNode);
      if (reconciler.hasEvaluatedRootNode(componentType, evaluatedRootNode)) {
        continue;
      }
      let effects = reconciler.render(componentType, null, null, true, evaluatedRootNode);
      let componentTreeState = reconciler.componentTreeState;
      this._generateWriteEffectsForReactComponentTree(componentType, effects, componentTreeState, evaluatedRootNode);

      // for now we just use abstract props/context, in the future we'll create a new branch with a new component
      // that used the props/context. It will extend the original component and only have a render method
      for (let _ref of componentTreeState.branchedComponentTrees) {
        let { rootValue: branchRootValue, nested, evaluatedNode } = _ref;

        (0, _utils.evaluateComponentTreeBranch)(this.realm, effects, nested, () => {
          let branchComponentType = (0, _utils.getComponentTypeFromRootValue)(this.realm, branchRootValue);
          if (branchComponentType === null) {
            evaluatedNode.status = "UNKNOWN_TYPE";
            return;
          }
          // so we don't process the same component multiple times (we might change this logic later)
          if (reconciler.hasEvaluatedRootNode(branchComponentType, evaluatedNode)) {
            return;
          }
          reconciler.clearComponentTreeState();
          let branchEffects = reconciler.render(branchComponentType, null, null, false, evaluatedNode);
          let branchComponentTreeState = reconciler.componentTreeState;
          this._generateWriteEffectsForReactComponentTree(branchComponentType, branchEffects, branchComponentTreeState, evaluatedNode);
        });
      }
      if (this.realm.react.output === "bytecode") {
        throw new _errors.FatalError("TODO: implement React bytecode output format");
      }
    }
  }

  _generateAdditionalFunctionCallsFromDirective() {
    let recordedAdditionalFunctions = this.__generateAdditionalFunctionsMap("__additionalFunctions");

    // The additional functions we registered at runtime are recorded at:
    // global.__additionalFunctions.id
    let calls = [];
    for (let [funcValue, { funcId }] of recordedAdditionalFunctions) {
      // TODO #987: Make Additional Functions work with arguments
      (0, _invariant2.default)(funcValue instanceof _index.FunctionValue);
      calls.push([funcValue, t.callExpression(t.memberExpression(t.memberExpression(t.identifier("global"), t.identifier("__additionalFunctions")), t.identifier(funcId)), [])]);
    }
    return calls;
  }

  _callOfFunction(funcValue) {
    const globalThis = this.realm.$GlobalEnv.environmentRecord.WithBaseObject();
    let call = funcValue.$Call;
    (0, _invariant2.default)(call);
    let numArgs = funcValue.getLength();
    let args = [];
    (0, _invariant2.default)(funcValue instanceof _index.ECMAScriptSourceFunctionValue);
    let params = funcValue.$FormalParameters;
    if (numArgs && numArgs > 0 && params) {
      for (let parameterId of params) {
        if (t.isIdentifier(parameterId)) {
          // Create an AbstractValue similar to __abstract being called
          args.push((0, _utils2.createAbstractArgument)(this.realm, parameterId.name, funcValue.expressionLocation));
        } else {
          this.realm.handleError(new _errors.CompilerDiagnostic("Non-identifier args to additional functions unsupported", funcValue.expressionLocation, "PP1005", "FatalError"));
          throw new _errors.FatalError("Non-identifier args to additional functions unsupported");
        }
      }
    }
    return call.bind(this, globalThis, args);
  }

  checkThatFunctionsAreIndependent() {
    let inputFunctions = this._generateAdditionalFunctionCallsFromInput();
    let recordedAdditionalFunctions = this.__generateAdditionalFunctionsMap("__additionalFunctions");
    let additionalFunctions = inputFunctions.concat([...recordedAdditionalFunctions.keys()]);

    for (let funcValue of additionalFunctions) {
      (0, _invariant2.default)(funcValue instanceof _index.FunctionValue);
      let call = this._callOfFunction(funcValue);
      let effects = this.realm.evaluatePure(() => this.realm.evaluateForEffectsInGlobalEnv(call, undefined, "additional function"));
      (0, _invariant2.default)(effects);
      let additionalFunctionEffects = this._createAdditionalEffects(effects);
      this.writeEffects.set(funcValue, additionalFunctionEffects);
    }

    // check that functions are independent
    let conflicts = new Map();
    for (let fun1 of additionalFunctions) {
      (0, _invariant2.default)(fun1 instanceof _index.FunctionValue);
      let fun1Name = this.functionExpressions.get(fun1) || fun1.intrinsicName || "(unknown function)";
      // Also do argument validation here
      let additionalFunctionEffects = this.writeEffects.get(fun1);
      (0, _invariant2.default)(additionalFunctionEffects !== undefined);
      let e1 = additionalFunctionEffects.effects;
      (0, _invariant2.default)(e1 !== undefined);
      if (e1[0] instanceof _completions.Completion) {
        let error = new _errors.CompilerDiagnostic(`Additional function ${fun1Name} may terminate abruptly`, e1[0].location, "PP1002", "FatalError");
        this.realm.handleError(error);
        throw new _errors.FatalError();
      }
      for (let fun2 of additionalFunctions) {
        if (fun1 === fun2) continue;
        (0, _invariant2.default)(fun2 instanceof _index.FunctionValue);
        this.reportWriteConflicts(fun1Name, conflicts, e1[3], this._callOfFunction(fun2));
      }
    }
    if (conflicts.size > 0) {
      for (let diagnostic of conflicts.values()) this.realm.handleError(diagnostic);
      throw new _errors.FatalError();
    }
  }

  getAdditionalFunctionValuesToEffects() {
    return this.writeEffects;
  }

  reportWriteConflicts(fname, conflicts, pbs, call2) {
    let reportConflict = location => {
      let error = new _errors.CompilerDiagnostic(`Property access conflicts with write in additional function ${fname}`, location, "PP1003", "FatalError");
      conflicts.set(location, error);
    };
    let writtenObjects = new Set();
    pbs.forEach((val, key, m) => {
      writtenObjects.add(key.object);
    });
    let oldReportObjectGetOwnProperties = this.realm.reportObjectGetOwnProperties;
    this.realm.reportObjectGetOwnProperties = ob => {
      let location = this.realm.currentLocation;
      (0, _invariant2.default)(location);
      if (writtenObjects.has(ob) && !conflicts.has(location)) reportConflict(location);
    };
    let oldReportPropertyAccess = this.realm.reportPropertyAccess;
    this.realm.reportPropertyAccess = pb => {
      let location = this.realm.currentLocation;
      if (!location) return; // happens only when accessing an additional function property
      if (pbs.has(pb) && !conflicts.has(location)) reportConflict(location);
    };
    try {
      (0, _errors2.ignoreErrorsIn)(this.realm, () => this.realm.evaluateForEffectsInGlobalEnv(call2));
    } finally {
      this.realm.reportPropertyAccess = oldReportPropertyAccess;
      this.realm.reportObjectGetOwnProperties = oldReportObjectGetOwnProperties;
    }
  }
}
exports.Functions = Functions; /**
                                * Copyright (c) 2017-present, Facebook, Inc.
                                * All rights reserved.
                                *
                                * This source code is licensed under the BSD-style license found in the
                                * LICENSE file in the root directory of this source tree. An additional grant
                                * of patent rights can be found in the PATENTS file in the same directory.
                                */
//# sourceMappingURL=functions.js.map