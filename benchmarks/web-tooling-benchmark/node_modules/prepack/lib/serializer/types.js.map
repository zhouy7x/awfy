{"version":3,"sources":["../../src/serializer/types.js"],"names":["AreSameResidualBinding","realm","x","y","serializedValue","value","BodyReference","constructor","body","index","isNotEarlierThan","other","TimingStatistics","totalTime","globalCodeTime","initializeMoreModulesTime","deepTraversalTime","referenceCountsTime","serializePassTime","ReactStatistics","optimizedTrees","inlinedComponents","evaluatedRootNodes","componentsEvaluated","SerializerStatistics","objects","objectProperties","functions","functionClones","referentialized","valueIds","valuesInlined","delayedValues","acceleratedModules","delayedModules","log","console"],"mappings":";;;;;;QAkHgBA,sB,GAAAA,sB;;AAvGhB;;AACA;;AAGA;;AACA;;AACA;;;;;;AAIA;AA6FO,SAASA,sBAAT,CAAgCC,KAAhC,EAA8CC,CAA9C,EAA0EC,CAA1E,EAAsG;AAC3G,MAAID,EAAEE,eAAF,KAAsBD,EAAEC,eAA5B,EAA6C,OAAO,IAAP;AAC7C,MAAIF,EAAEG,KAAF,IAAWH,EAAEG,KAAF,KAAYF,EAAEE,KAA7B,EAAoC,OAAO,IAAP;AACpC,MAAIH,EAAEG,KAAF,oCAAoCF,EAAEE,KAAF,gCAAxC,EAA0E;AACxE,WAAO,yBAAUJ,KAAV,EAAiBC,EAAEG,KAAnB,EAA0BF,EAAEE,KAA5B,CAAP;AACD;AACD,SAAO,KAAP;AACD,C,CAzHD;;;;;;;;;AA2HO,MAAMC,aAAN,CAAoB;AACzBC,cAAYC,IAAZ,EAAkCC,KAAlC,EAAiD;AAC/C,6BAAUA,SAAS,CAAnB;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AACD;AACDC,mBAAiBC,KAAjB,EAAgD;AAC9C,WAAO,KAAKH,IAAL,KAAcG,MAAMH,IAApB,IAA4B,KAAKC,KAAL,IAAcE,MAAMF,KAAvD;AACD;AARwB;;QAAdH,a,GAAAA,a;AAaN,MAAMM,gBAAN,CAAuB;AAC5BL,gBAAc;AACZ,SAAKM,SAAL,GAAiB,CAAjB;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACA,SAAKC,yBAAL,GAAiC,CAAjC;AACA,SAAKC,iBAAL,GAAyB,CAAzB;AACA,SAAKC,mBAAL,GAA2B,CAA3B;AACA,SAAKC,iBAAL,GAAyB,CAAzB;AACD;AAR2B;;QAAjBN,gB,GAAAA,gB;AAgCN,MAAMO,eAAN,CAAsB;AAC3BZ,gBAAc;AACZ,SAAKa,cAAL,GAAsB,CAAtB;AACA,SAAKC,iBAAL,GAAyB,CAAzB;AACA,SAAKC,kBAAL,GAA0B,EAA1B;AACA,SAAKC,mBAAL,GAA2B,CAA3B;AACD;AAN0B;;QAAhBJ,e,GAAAA,e;AAaN,MAAMK,oBAAN,CAA2B;AAChCjB,gBAAc;AACZ,SAAKkB,OAAL,GAAe,CAAf;AACA,SAAKC,gBAAL,GAAwB,CAAxB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACA,SAAKC,eAAL,GAAuB,CAAvB;AACA,SAAKC,QAAL,GAAgB,CAAhB;AACA,SAAKC,aAAL,GAAqB,CAArB;AACA,SAAKC,aAAL,GAAqB,CAArB;AACA,SAAKC,kBAAL,GAA0B,CAA1B;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACD;;;AAYDC,QAAM;AACJC,YAAQD,GAAR,CAAa,8BAAb;AACAC,YAAQD,GAAR,CAAa,GAAE,KAAKV,OAAQ,iBAAgB,KAAKC,gBAAiB,aAAlE;AACAU,YAAQD,GAAR,CACG,GAAE,KAAKR,SAAU,mBAAkB,KAAKC,cAAe,sCAAqC,KAC1FC,eAAgB,6BAFrB;AAIAO,YAAQD,GAAR,CACG,GAAE,KAAKL,QAAS,cAAa,KAAKE,aAAc,qCAAoC,KAClFD,aAAc,iBAFnB;AAIAK,YAAQD,GAAR,CAAa,GAAE,KAAKF,kBAAmB,oBAAmB,KAAKC,cAAe,mBAA9E;AACD;AApC+B;;QAArBV,oB,GAAAA,oB","file":"types.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { DeclarativeEnvironmentRecord, type Binding } from \"../environment.js\";\nimport { ConcreteValue, Value, ObjectValue, AbstractValue } from \"../values/index.js\";\nimport type { ECMAScriptSourceFunctionValue, FunctionValue } from \"../values/index.js\";\nimport type { BabelNodeExpression, BabelNodeStatement } from \"babel-types\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Realm, type Effects } from \"../realm.js\";\nimport invariant from \"../invariant.js\";\n\nexport type TryQuery<T> = (f: () => T, defaultValue: T) => T;\n\n// TODO: add type for additional functions.\nexport type SerializedBodyType =\n  | \"MainGenerator\"\n  | \"Generator\"\n  | \"AdditionalFunction\"\n  | \"DelayInitializations\"\n  | \"ConditionalAssignmentBranch\"\n  | \"LazyObjectInitializer\";\n\nexport type SerializedBody = {\n  type: SerializedBodyType,\n  entries: Array<BabelNodeStatement>,\n  done: boolean,\n  declaredAbstractValues?: Map<AbstractValue, SerializedBody>,\n  parentBody?: SerializedBody,\n  nestingLevel?: number,\n};\n\nexport type AdditionalFunctionEffects = {\n  effects: Effects,\n  transforms: Array<Function>,\n};\n\nexport type AdditionalFunctionInfo = {\n  functionValue: FunctionValue,\n  captures: Set<string>,\n  // TODO: use for storing modified residual function bindings (captured by other functions)\n  modifiedBindings: Map<Binding, ResidualFunctionBinding>,\n  instance: FunctionInstance,\n};\n\nexport type ClassMethodInstance = {|\n  classPrototype: ObjectValue,\n  methodType: \"constructor\" | \"method\" | \"get\" | \"set\",\n  classSuperNode: void | BabelNodeIdentifier,\n  classMethodIsStatic: boolean,\n  classMethodKeyNode: void | BabelNodeExpression,\n  classMethodComputed: boolean,\n|};\n\nexport type FunctionInstance = {\n  residualFunctionBindings: Map<string, ResidualFunctionBinding>,\n  functionValue: ECMAScriptSourceFunctionValue,\n  insertionPoint?: BodyReference,\n  // Additional function that the function instance was declared inside of (if any)\n  containingAdditionalFunction?: FunctionValue,\n  scopeInstances: Map<string, ScopeBinding>,\n  initializationStatements: Array<BabelNodeStatement>,\n};\n\nexport type FunctionInfo = {\n  unbound: Set<string>,\n  modified: Set<string>,\n  usesArguments: boolean,\n  usesThis: boolean,\n};\n\nexport type LazilyHoistedNodes = {|\n  id: BabelNodeIdentifier,\n  createElementIdentifier: null | BabelNodeIdentifier,\n  nodes: Array<{ id: BabelNodeIdentifier, astNode: BabelNode }>,\n|};\n\nexport type FactoryFunctionInfo = { factoryId: BabelNodeIdentifier, functionInfo: FunctionInfo };\n\nexport type ResidualFunctionBinding = {\n  value: void | Value,\n  modified: boolean,\n  // null means a global binding\n  declarativeEnvironmentRecord: null | DeclarativeEnvironmentRecord,\n  // The serializedValue is only not yet present during the initialization of a binding that involves recursive dependencies.\n  serializedValue?: void | BabelNodeExpression,\n  referentialized?: boolean,\n  scope?: ScopeBinding,\n  // If the binding is only accessed by an additional function or nested values\n  // this field contains that additional function. (Determines what initializer\n  // to put the binding in -- global or additional function)\n  referencedOnlyFromAdditionalFunctions?: FunctionValue,\n  // If the binding is overwritten by an additional function, these contain the\n  // new values\n  // TODO #1087: make this a map and support arbitrary binding modifications\n  additionalFunctionOverridesValue?: true,\n  additionalValueSerialized?: BabelNodeExpression,\n};\n\nexport type ScopeBinding = {\n  name: string,\n  id: number,\n  initializationValues: Array<BabelNodeExpression>,\n  capturedScope?: string,\n  containingAdditionalFunction: void | FunctionValue,\n};\n\nexport function AreSameResidualBinding(realm: Realm, x: ResidualFunctionBinding, y: ResidualFunctionBinding) {\n  if (x.serializedValue === y.serializedValue) return true;\n  if (x.value && x.value === y.value) return true;\n  if (x.value instanceof ConcreteValue && y.value instanceof ConcreteValue) {\n    return SameValue(realm, x.value, y.value);\n  }\n  return false;\n}\n\nexport class BodyReference {\n  constructor(body: SerializedBody, index: number) {\n    invariant(index >= 0);\n    this.body = body;\n    this.index = index;\n  }\n  isNotEarlierThan(other: BodyReference): boolean {\n    return this.body === other.body && this.index >= other.index;\n  }\n  body: SerializedBody;\n  index: number;\n}\n\nexport class TimingStatistics {\n  constructor() {\n    this.totalTime = 0;\n    this.globalCodeTime = 0;\n    this.initializeMoreModulesTime = 0;\n    this.deepTraversalTime = 0;\n    this.referenceCountsTime = 0;\n    this.serializePassTime = 0;\n  }\n  totalTime: number;\n  globalCodeTime: number;\n  initializeMoreModulesTime: number;\n  deepTraversalTime: number;\n  referenceCountsTime: number;\n  serializePassTime: number;\n}\n\nexport type ReactEvaluatedNode = {\n  children: Array<ReactEvaluatedNode>,\n  message: string,\n  name: string,\n  status:\n    | \"ROOT\"\n    | \"NEW_TREE\"\n    | \"INLINED\"\n    | \"BAIL-OUT\"\n    | \"UNKNOWN_TYPE\"\n    | \"RENDER_PROPS\"\n    | \"UNSUPPORTED_COMPLETION\"\n    | \"ABRUPT_COMPLETION\",\n};\n\nexport class ReactStatistics {\n  constructor() {\n    this.optimizedTrees = 0;\n    this.inlinedComponents = 0;\n    this.evaluatedRootNodes = [];\n    this.componentsEvaluated = 0;\n  }\n  optimizedTrees: number;\n  inlinedComponents: number;\n  evaluatedRootNodes: Array<ReactEvaluatedNode>;\n  componentsEvaluated: number;\n}\n\nexport class SerializerStatistics {\n  constructor() {\n    this.objects = 0;\n    this.objectProperties = 0;\n    this.functions = 0;\n    this.functionClones = 0;\n    this.referentialized = 0;\n    this.valueIds = 0;\n    this.valuesInlined = 0;\n    this.delayedValues = 0;\n    this.acceleratedModules = 0;\n    this.delayedModules = 0;\n  }\n  objects: number;\n  objectProperties: number;\n  functions: number;\n  functionClones: number;\n  referentialized: number;\n  valueIds: number;\n  valuesInlined: number;\n  delayedValues: number;\n  acceleratedModules: number;\n  delayedModules: number;\n\n  log() {\n    console.log(`=== serialization statistics`);\n    console.log(`${this.objects} objects with ${this.objectProperties} properties`);\n    console.log(\n      `${this.functions} functions plus ${this.functionClones} clones due to captured variables; ${this\n        .referentialized} captured mutable variables`\n    );\n    console.log(\n      `${this.valueIds} eager and ${this.delayedValues} delayed value ids generated, and ${this\n        .valuesInlined} values inlined`\n    );\n    console.log(`${this.acceleratedModules} accelerated and ${this.delayedModules} delayed modules.`);\n  }\n}\n\nexport type LocationService = {\n  getLocation: Value => BabelNodeIdentifier,\n  createLocation: () => BabelNodeIdentifier,\n};\n\nexport type ReactSerializerState = {\n  usedReactElementKeys: Set<string>,\n};\n\nexport type ObjectRefCount = {\n  inComing: number, // The number of objects that references this object.\n  outGoing: number, // The number of objects that are referenced by this object.\n};\n\nexport type SerializedResult = {\n  code: string,\n  map: void | SourceMap,\n  statistics?: SerializerStatistics,\n  timingStats?: TimingStatistics,\n  heapGraph?: string,\n};\n"]}