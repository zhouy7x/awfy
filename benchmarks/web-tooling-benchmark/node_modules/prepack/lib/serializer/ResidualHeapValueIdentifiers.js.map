{"version":3,"sources":["../../src/serializer/ResidualHeapValueIdentifiers.js"],"names":["t","ResidualHeapValueIdentifiers","constructor","values","preludeGenerator","collectValToRefCountOnly","_valueNameGenerator","createNameGenerator","_populateIdentifierMap","initPass1","valToRefCount","Map","initPass2","refs","val","_setIdentifier","_createNewIdentifier","name","generate","__originalName","identifier","id","has","set","getIdentifier","get","undefined","deleteIdentifier","delete","getIdentifierAndIncrementReferenceCount","incrementReferenceCount","refCount","needsIdentifier"],"mappings":";;;;;;;AAWA;;AAEA;;;;AAEA;;IAAYA,C;;;;;;AAEZ;AACA;AACA;AACA;AACA;AACO,MAAMC,4BAAN,CAAmC;AACxCC,cAAYC,MAAZ,EAAqCC,gBAArC,EAAyE;AACvE,SAAKC,wBAAL,GAAgC,KAAhC;AACA,SAAKC,mBAAL,GAA2BF,iBAAiBG,mBAAjB,CAAqC,GAArC,CAA3B;AACA,SAAKC,sBAAL,CAA4BL,MAA5B;AACD;;AAEDM,cAAY;AACV,SAAKJ,wBAAL,GAAgC,IAAhC;AACA,SAAKK,aAAL,GAAqB,IAAIC,GAAJ,EAArB;AACD;;AAEDC,cAAY;AACV,SAAKP,wBAAL,GAAgC,KAAhC;AACD;;AAODG,yBAAuBL,MAAvB,EAAgD;AAC9C,SAAKU,IAAL,GAAY,IAAIF,GAAJ,EAAZ;AACA,SAAK,MAAMG,GAAX,IAAkBX,MAAlB,EAA0B;AACxB,WAAKY,cAAL,CAAoBD,GAApB,EAAyB,KAAKE,oBAAL,CAA0BF,GAA1B,CAAzB;AACD;AACF;;AAEDE,uBAAqBF,GAArB,EAAsD;AACpD,UAAMG,OAAO,KAAKX,mBAAL,CAAyBY,QAAzB,CAAkCJ,IAAIK,cAAJ,IAAsB,EAAxD,CAAb;AACA,WAAOnB,EAAEoB,UAAF,CAAaH,IAAb,CAAP;AACD;;AAEDF,iBAAeD,GAAf,EAA2BO,EAA3B,EAAoD;AAClD,6BAAU,CAAC,KAAKR,IAAL,CAAUS,GAAV,CAAcR,GAAd,CAAX;AACA,SAAKD,IAAL,CAAUU,GAAV,CAAcT,GAAd,EAAmBO,EAAnB;AACD;;AAEDG,gBAAcV,GAAd,EAA+C;AAC7C,QAAIO,KAAK,KAAKR,IAAL,CAAUY,GAAV,CAAcX,GAAd,CAAT;AACA,6BAAUO,OAAOK,SAAjB;AACA,WAAOL,EAAP;AACD;;AAEDM,mBAAiBb,GAAjB,EAA6B;AAC3B,6BAAU,KAAKD,IAAL,CAAUS,GAAV,CAAcR,GAAd,CAAV;AACA,SAAKD,IAAL,CAAUe,MAAV,CAAiBd,GAAjB;AACD;;AAEDe,0CAAwCf,GAAxC,EAAyE;AACvE,SAAKgB,uBAAL,CAA6BhB,GAA7B;AACA,QAAIO,KAAK,KAAKR,IAAL,CAAUY,GAAV,CAAcX,GAAd,CAAT;AACA,6BAAUO,OAAOK,SAAjB,EAA4B,sCAA5B;AACA,WAAOL,EAAP;AACD;;AAEDS,0BAAwBhB,GAAxB,EAAoC;AAClC,QAAI,KAAKT,wBAAT,EAAmC;AACjC,UAAIK,gBAAgB,KAAKA,aAAzB;AACA,+BAAUA,kBAAkBgB,SAA5B;AACA,UAAIK,WAAWrB,cAAce,GAAd,CAAkBX,GAAlB,CAAf;AACA,UAAIiB,QAAJ,EAAc;AACZA;AACD,OAFD,MAEO;AACLA,mBAAW,CAAX;AACD;AACDrB,oBAAca,GAAd,CAAkBT,GAAlB,EAAuBiB,QAAvB;AACD;AACF;;AAEDC,kBAAgBlB,GAAhB,EAA4B;AAC1B,QAAI,KAAKT,wBAAL,IAAiC,KAAKK,aAAL,KAAuBgB,SAA5D,EAAuE,OAAO,IAAP;AACvE,QAAIK,WAAW,KAAKrB,aAAL,CAAmBe,GAAnB,CAAuBX,GAAvB,CAAf;AACA,6BAAUiB,aAAaL,SAAb,IAA0BK,WAAW,CAA/C;AACA,WAAOA,aAAa,CAApB;AACD;AA3EuC;QAA7B9B,4B,GAAAA,4B,EAtBb","file":"ResidualHeapValueIdentifiers.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Value } from \"../values/index.js\";\nimport type { BabelNodeIdentifier } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport type { NameGenerator, PreludeGenerator } from \"../utils/generator\";\nimport * as t from \"babel-types\";\n\n// This class maintains a map of values to babel identifiers.\n// This class can optionally track how often such value identifiers are referenced\n// when pass 1 is activated, which is usually followed by pass 2 in which\n// unneeded identifiers (those which were only ever referenced once) are\n// eliminated as the defining expression can be inlined.\nexport class ResidualHeapValueIdentifiers {\n  constructor(values: Iterator<Value>, preludeGenerator: PreludeGenerator) {\n    this.collectValToRefCountOnly = false;\n    this._valueNameGenerator = preludeGenerator.createNameGenerator(\"_\");\n    this._populateIdentifierMap(values);\n  }\n\n  initPass1() {\n    this.collectValToRefCountOnly = true;\n    this.valToRefCount = new Map();\n  }\n\n  initPass2() {\n    this.collectValToRefCountOnly = false;\n  }\n\n  collectValToRefCountOnly: boolean;\n  valToRefCount: void | Map<Value, number>;\n  refs: Map<Value, BabelNodeIdentifier>;\n  _valueNameGenerator: NameGenerator;\n\n  _populateIdentifierMap(values: Iterator<Value>) {\n    this.refs = new Map();\n    for (const val of values) {\n      this._setIdentifier(val, this._createNewIdentifier(val));\n    }\n  }\n\n  _createNewIdentifier(val: Value): BabelNodeIdentifier {\n    const name = this._valueNameGenerator.generate(val.__originalName || \"\");\n    return t.identifier(name);\n  }\n\n  _setIdentifier(val: Value, id: BabelNodeIdentifier) {\n    invariant(!this.refs.has(val));\n    this.refs.set(val, id);\n  }\n\n  getIdentifier(val: Value): BabelNodeIdentifier {\n    let id = this.refs.get(val);\n    invariant(id !== undefined);\n    return id;\n  }\n\n  deleteIdentifier(val: Value) {\n    invariant(this.refs.has(val));\n    this.refs.delete(val);\n  }\n\n  getIdentifierAndIncrementReferenceCount(val: Value): BabelNodeIdentifier {\n    this.incrementReferenceCount(val);\n    let id = this.refs.get(val);\n    invariant(id !== undefined, \"Value Id cannot be null or undefined\");\n    return id;\n  }\n\n  incrementReferenceCount(val: Value) {\n    if (this.collectValToRefCountOnly) {\n      let valToRefCount = this.valToRefCount;\n      invariant(valToRefCount !== undefined);\n      let refCount = valToRefCount.get(val);\n      if (refCount) {\n        refCount++;\n      } else {\n        refCount = 1;\n      }\n      valToRefCount.set(val, refCount);\n    }\n  }\n\n  needsIdentifier(val: Value) {\n    if (this.collectValToRefCountOnly || this.valToRefCount === undefined) return true;\n    let refCount = this.valToRefCount.get(val);\n    invariant(refCount !== undefined && refCount > 0);\n    return refCount !== 1;\n  }\n}\n"]}