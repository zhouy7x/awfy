{"version":3,"sources":["../../src/serializer/Referentializer.js"],"names":["t","Referentializer","constructor","realm","options","scopeNameGenerator","referentializedNameGenerator","statistics","_options","referentializationState","Map","_referentializedNameGenerator","_createReferentializationState","capturedScopeInstanceIdx","capturedScopesArray","identifier","generate","capturedScopeAccessFunctionId","serializedScopes","_getReferentializationState","referentializationScope","bind","createCaptureScopeAccessFunction","body","selectorParam","captured","selectorExpression","memberExpression","cases","scopeBinding","values","scopeObjectExpression","arrayExpression","initializationValues","push","switchCase","numericLiteral","id","expressionStatement","assignmentExpression","breakStatement","throwStatement","newExpression","stringLiteral","variableDeclaration","variableDeclarator","switchStatement","returnStatement","factoryFunction","functionExpression","blockStatement","accessFunctionId","_getSerializedBindingScopeInstance","residualBinding","declarativeEnvironmentRecord","referencedOnlyFromAdditionalFunctions","scope","get","refState","name","containingAdditionalFunction","set","getReferentializedScopeInitialization","capturedScope","state","funcName","scopeArray","scopeName","init","logicalExpression","callExpression","referentializeBinding","instance","simpleClosures","serializedBindingId","serializedValue","declar","initializationStatements","variableIndexInScope","length","referentialized","cleanInstance","b","residualFunctionBindings","binding","referentialize","unbound","instances","shouldReferentializeInstanceFn","residualBindings","undefined","modified","handleError","functionValue","loc","scopeInstances","createCapturedScopesArrayInitialization"],"mappings":"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","file":"Referentializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { FatalError, CompilerDiagnostic } from \"../errors.js\";\nimport { FunctionValue } from \"../values/index.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeStatement, BabelNodeIdentifier } from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type { ResidualFunctionBinding, ScopeBinding, FunctionInstance } from \"./types.js\";\nimport { SerializerStatistics } from \"./types.js\";\nimport { getOrDefault } from \"./utils.js\";\nimport { Realm } from \"../realm.js\";\n\n// Each of these will correspond to a different preludeGenerator and thus will\n// have different values available for initialization. FunctionValues should\n// only be additional functions.\nexport type ReferentializationScope = FunctionValue | \"GLOBAL\";\n\ntype ReferentializationState = {|\n  capturedScopeInstanceIdx: number,\n  capturedScopesArray: BabelNodeIdentifier,\n  capturedScopeAccessFunctionId: BabelNodeIdentifier,\n  serializedScopes: Map<DeclarativeEnvironmentRecord, ScopeBinding>,\n|};\n\n/*\n * This class helps fixup names in residual functions for variables that these\n * functions capture from parent scopes.\n * For each ReferentializationScope it creates a _get_scope_binding function\n * that contains the initialization for all of that scope's FunctionInstances\n * which will contain a switch statement with all the initializations.\n */\nexport class Referentializer {\n  constructor(\n    realm: Realm,\n    options: SerializerOptions,\n    scopeNameGenerator: NameGenerator,\n    referentializedNameGenerator: NameGenerator,\n    statistics: SerializerStatistics\n  ) {\n    this._options = options;\n    this.scopeNameGenerator = scopeNameGenerator;\n    this.statistics = statistics;\n\n    this.referentializationState = new Map();\n    this._referentializedNameGenerator = referentializedNameGenerator;\n    this.realm = realm;\n  }\n\n  _options: SerializerOptions;\n  scopeNameGenerator: NameGenerator;\n  statistics: SerializerStatistics;\n  realm: Realm;\n\n  _newCapturedScopeInstanceIdx: number;\n  referentializationState: Map<ReferentializationScope, ReferentializationState>;\n  _referentializedNameGenerator: NameGenerator;\n\n  _createReferentializationState(): ReferentializationState {\n    return {\n      capturedScopeInstanceIdx: 0,\n      capturedScopesArray: t.identifier(this.scopeNameGenerator.generate(\"main\")),\n      capturedScopeAccessFunctionId: t.identifier(this.scopeNameGenerator.generate(\"get_scope_binding\")),\n      serializedScopes: new Map(),\n    };\n  }\n\n  _getReferentializationState(referentializationScope: ReferentializationScope): ReferentializationState {\n    return getOrDefault(\n      this.referentializationState,\n      referentializationScope,\n      this._createReferentializationState.bind(this)\n    );\n  }\n\n  // Generate a shared function for accessing captured scope bindings.\n  // TODO: skip generating this function if the captured scope is not shared by multiple residual functions.\n  createCaptureScopeAccessFunction(referentializationScope: ReferentializationScope): BabelNodeStatement {\n    const body = [];\n    const selectorParam = t.identifier(\"__selector\");\n    const captured = t.identifier(\"__captured\");\n    const capturedScopesArray = this._getReferentializationState(referentializationScope).capturedScopesArray;\n    const selectorExpression = t.memberExpression(capturedScopesArray, selectorParam, /*Indexer syntax*/ true);\n\n    // One switch case for one scope.\n    const cases = [];\n    const serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;\n    for (const scopeBinding of serializedScopes.values()) {\n      const scopeObjectExpression = t.arrayExpression((scopeBinding.initializationValues: any));\n      cases.push(\n        t.switchCase(t.numericLiteral(scopeBinding.id), [\n          t.expressionStatement(t.assignmentExpression(\"=\", captured, scopeObjectExpression)),\n          t.breakStatement(),\n        ])\n      );\n    }\n    // Default case.\n    cases.push(\n      t.switchCase(null, [\n        t.throwStatement(t.newExpression(t.identifier(\"Error\"), [t.stringLiteral(\"Unknown scope selector\")])),\n      ])\n    );\n\n    body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(captured)]));\n    body.push(t.switchStatement(selectorParam, cases));\n    body.push(t.expressionStatement(t.assignmentExpression(\"=\", selectorExpression, captured)));\n    body.push(t.returnStatement(captured));\n    const factoryFunction = t.functionExpression(null, [selectorParam], t.blockStatement(body));\n    const accessFunctionId = this._getReferentializationState(referentializationScope).capturedScopeAccessFunctionId;\n    return t.variableDeclaration(\"var\", [t.variableDeclarator(accessFunctionId, factoryFunction)]);\n  }\n\n  _getSerializedBindingScopeInstance(residualBinding: ResidualFunctionBinding): ScopeBinding {\n    let declarativeEnvironmentRecord = residualBinding.declarativeEnvironmentRecord;\n    let referentializationScope = residualBinding.referencedOnlyFromAdditionalFunctions || \"GLOBAL\";\n    invariant(declarativeEnvironmentRecord);\n\n    // figure out if this is accessed only from additional functions\n    let serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;\n    let scope = serializedScopes.get(declarativeEnvironmentRecord);\n    if (!scope) {\n      let refState: ReferentializationState = this._getReferentializationState(referentializationScope);\n      scope = {\n        name: this.scopeNameGenerator.generate(),\n        id: refState.capturedScopeInstanceIdx++,\n        initializationValues: [],\n        containingAdditionalFunction: residualBinding.referencedOnlyFromAdditionalFunctions,\n      };\n      serializedScopes.set(declarativeEnvironmentRecord, scope);\n    }\n\n    invariant(!residualBinding.scope || residualBinding.scope === scope);\n    residualBinding.scope = scope;\n    return scope;\n  }\n\n  getReferentializedScopeInitialization(scope: ScopeBinding) {\n    const capturedScope = scope.capturedScope;\n    invariant(capturedScope);\n    const state = this._getReferentializationState(scope.containingAdditionalFunction || \"GLOBAL\");\n    const funcName = state.capturedScopeAccessFunctionId;\n    const scopeArray = state.capturedScopesArray;\n    const scopeName = t.identifier(scope.name);\n    // First get scope array entry and check if it's already initialized.\n    // Only if not yet, then call the initialization function.\n    const init = t.logicalExpression(\n      \"||\",\n      t.memberExpression(scopeArray, scopeName, true),\n      t.callExpression(funcName, [scopeName])\n    );\n    return [t.variableDeclaration(\"var\", [t.variableDeclarator(t.identifier(capturedScope), init)])];\n  }\n\n  referentializeBinding(residualBinding: ResidualFunctionBinding, name: string, instance: FunctionInstance): void {\n    if (this._options.simpleClosures) {\n      // When simpleClosures is enabled, then space for captured mutable bindings is allocated upfront.\n      let serializedBindingId = t.identifier(this._referentializedNameGenerator.generate(name));\n      let serializedValue = residualBinding.serializedValue;\n      invariant(serializedValue);\n      let declar = t.variableDeclaration(\"var\", [t.variableDeclarator(serializedBindingId, serializedValue)]);\n      instance.initializationStatements.push(declar);\n      residualBinding.serializedValue = serializedBindingId;\n    } else {\n      // When simpleClosures is not enabled, then space for captured mutable bindings is allocated lazily.\n      let scope = this._getSerializedBindingScopeInstance(residualBinding);\n      let capturedScope = \"__captured\" + scope.name;\n      // Save the serialized value for initialization at the top of\n      // the factory.\n      // This can serialize more variables than are necessary to execute\n      // the function because every function serializes every\n      // modified variable of its parent scope. In some cases it could be\n      // an improvement to split these variables into multiple\n      // scopes.\n      const variableIndexInScope = scope.initializationValues.length;\n      invariant(residualBinding.serializedValue);\n      scope.initializationValues.push(residualBinding.serializedValue);\n      scope.capturedScope = capturedScope;\n\n      // Replace binding usage with scope references\n      residualBinding.serializedValue = t.memberExpression(\n        t.identifier(capturedScope),\n        t.numericLiteral(variableIndexInScope),\n        true // Array style access.\n      );\n    }\n\n    this.statistics.referentialized++;\n  }\n\n  // Cleans all scopes between passes of the serializer\n  cleanInstance(instance: FunctionInstance) {\n    instance.initializationStatements = [];\n    for (let b of ((instance: any): FunctionInstance).residualFunctionBindings.values()) {\n      let binding = ((b: any): ResidualFunctionBinding);\n      if (binding.referentialized && binding.declarativeEnvironmentRecord) {\n        let declarativeEnvironmentRecord = binding.declarativeEnvironmentRecord;\n        let referentializationScope = binding.referencedOnlyFromAdditionalFunctions || \"GLOBAL\";\n\n        let refState = this.referentializationState.get(referentializationScope);\n        if (refState) {\n          let scope = refState.serializedScopes.get(declarativeEnvironmentRecord);\n          if (scope) {\n            scope.initializationValues = [];\n          }\n        }\n      }\n      delete binding.serializedValue;\n      delete binding.referentialized;\n    }\n  }\n\n  referentialize(\n    unbound: Set<string>,\n    instances: Array<FunctionInstance>,\n    shouldReferentializeInstanceFn: FunctionInstance => boolean\n  ): void {\n    for (let instance of instances) {\n      let residualBindings = instance.residualFunctionBindings;\n\n      for (let name of unbound) {\n        let residualBinding = residualBindings.get(name);\n        invariant(residualBinding !== undefined);\n        if (residualBinding.modified) {\n          // Initialize captured scope at function call instead of globally\n          if (!residualBinding.declarativeEnvironmentRecord) residualBinding.referentialized = true;\n          if (!residualBinding.referentialized) {\n            if (!shouldReferentializeInstanceFn(instance)) {\n              // TODO #989: Fix additional functions and referentialization\n              this.realm.handleError(\n                new CompilerDiagnostic(\n                  \"Referentialization for prepacked functions unimplemented\",\n                  instance.functionValue.loc,\n                  \"PP1005\",\n                  \"FatalError\"\n                )\n              );\n              throw new FatalError(\"TODO: implement referentialization for prepacked functions\");\n            }\n            if (!this._options.simpleClosures) this._getSerializedBindingScopeInstance(residualBinding);\n            residualBinding.referentialized = true;\n          }\n\n          invariant(residualBinding.referentialized);\n          if (residualBinding.declarativeEnvironmentRecord && residualBinding.scope) {\n            instance.scopeInstances.set(residualBinding.scope.name, residualBinding.scope);\n          }\n        }\n      }\n    }\n  }\n\n  createCapturedScopesArrayInitialization(referentializationScope: ReferentializationScope): BabelNodeStatement {\n    return t.variableDeclaration(\"var\", [\n      t.variableDeclarator(\n        this._getReferentializationState(referentializationScope).capturedScopesArray,\n        t.callExpression(t.identifier(\"Array\"), [\n          t.numericLiteral(this._getReferentializationState(referentializationScope).capturedScopeInstanceIdx),\n        ])\n      ),\n    ]);\n  }\n}\n"]}