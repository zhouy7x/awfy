{"version":3,"sources":["../../src/serializer/Emitter.js"],"names":["Emitter","constructor","residualFunctions","referencedDeclaredValues","_mainBody","type","parentBody","undefined","entries","done","_waitingForValues","Map","_waitingForBodies","_body","_residualFunctions","_activeStack","_activeValues","Set","_activeGeneratorStack","_finalized","_getReasonToWaitForDependenciesCallbacks","onActive","val","onFunction","addFunctionUsage","getBodyReference","onAbstractValueWithIdentifier","cannotDeclare","hasBeenDeclared","emittingToAdditionalFunction","get","beginEmitting","dependency","targetBody","isChild","push","has","add","includes","nestingLevel","oldBody","emit","statement","_processCurrentBody","endEmitting","lastDependency","pop","delete","_processValue","_isEmittingActiveGenerator","lastBody","declaredAbstractValues","anyPropagated","b","parentDeclaredAbstractValues","key","value","set","finalize","length","size","_isGeneratorBody","body","a","dependencies","func","shift","emitNowOrAfterWaitingForDependencies","currentBody","_emitAfterWaitingForGeneratorBody","_getFirstAncestorGeneratorWithActiveBody","bodyStack","activeBody","slice","reverse","find","getReasonToWaitForDependencies","dependenciesVisitor","callbacks","result","recurse","Array","isArray","values","$BoundTargetFunction","$BoundThis","$BoundArguments","hasIdentifier","args","$ProxyTarget","$ProxyHandler","$Description","kind","getKind","proto","$Prototype","$DateValue","getReasonToWaitForActiveValue","condition","_shouldEmitWithoutWaiting","delayReason","emitAfterWaiting","_emitAfterWaitingForValue","reason","declare","getDeclarationBody","declaredCount","getBody","isCurrentBodyOffspringOf"],"mappings":"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","file":"Emitter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  BoundFunctionValue,\n  ProxyValue,\n  AbstractValue,\n  FunctionValue,\n  Value,\n  ObjectValue,\n  SymbolValue,\n} from \"../values/index.js\";\nimport type { BabelNodeStatement } from \"babel-types\";\nimport type { SerializedBody } from \"./types.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport { BodyReference } from \"./types.js\";\nimport { ResidualFunctions } from \"./ResidualFunctions.js\";\n\n// Type used to configure callbacks from the dependenciesVisitor of the Emitter.\ntype EmitterDependenciesVisitorCallbacks<T> = {\n  // Callback invoked whenever an \"active\" dependency is visited, i.e. a dependency which is in the process of being emitted.\n  // A return value that is not undefined indicates that the visitor should stop, and return the value as the overall result.\n  onActive?: Value => void | T,\n  // Callback invoked whenever a dependency is visited that is a FunctionValue.\n  // A return value that is not undefined indicates that the visitor should stop, and return the value as the overall result.\n  onFunction?: FunctionValue => void | T,\n  // Callback invoked whenever a dependency is visited that is an abstract value with an identifier.\n  // A return value that is not undefined indicates that the visitor should stop, and return the value as the overall result.\n  onAbstractValueWithIdentifier?: AbstractValue => void | T,\n};\n\n// The emitter keeps track of a stack of what's currently being emitted.\n// There are two kinds of interesting dependencies the emitter is dealing with:\n// 1. Value dependencies:\n//    If an emission task depends on the result of another emission task which\n//    is still currently being emitted, then the emission task must be performed later,\n//    once the dependency is available.\n//    To this end, the emitter maintains the `_activeValues` and `_waitingForValues` datastructures.\n// 2. Generator dependencies:\n//    For each generator, there's a corresponding \"body\", i.e. a stream of babel statements\n//    that the emitter is appending to.\n//    There's always a \"current\" body that is currently being emitted to.\n//    There's also a distinguished `mainBody` to which all statements get directly or indirectly appended.\n//    If there are multiple generators/bodies involved, then they form a stack.\n//    Nested bodies are usually composed into an instruction emitted to the outer body.\n//    For example, two nested generators may yield the then and else-branch of an `if` statement.\n//    When an emission is supposed to target a body that is the current body, i.e. when it sits\n//    lower on the stack, then the emission task gets delayed until the next emission task on\n//    the lower body entry is finished.\n//    To this end, the emitter maintains the `_activeGeneratorStack` and `_waitingForBodies` datastructures.\nexport class Emitter {\n  constructor(\n    residualFunctions: ResidualFunctions,\n    referencedDeclaredValues: Map<AbstractValue, void | FunctionValue>\n  ) {\n    this._mainBody = { type: \"MainGenerator\", parentBody: undefined, entries: [], done: false };\n    this._waitingForValues = new Map();\n    this._waitingForBodies = new Map();\n    this._body = this._mainBody;\n    this._residualFunctions = residualFunctions;\n    this._activeStack = [];\n    this._activeValues = new Set();\n    this._activeGeneratorStack = [this._mainBody];\n    this._finalized = false;\n    this._getReasonToWaitForDependenciesCallbacks = {\n      onActive: val => val, // cyclic dependency; we need to wait until this value has finished emitting\n      onFunction: val => {\n        // Functions are currently handled in a special way --- they are all defined ahead of time. Thus, we never have to wait for functions.\n        this._residualFunctions.addFunctionUsage(val, this.getBodyReference());\n        return undefined;\n      },\n      onAbstractValueWithIdentifier: val => {\n        // If the value hasn't been declared yet, then we should wait for it.\n        if (\n          !this.cannotDeclare() &&\n          !this.hasBeenDeclared(val) &&\n          (!this.emittingToAdditionalFunction() || referencedDeclaredValues.get(val) !== undefined)\n        )\n          return val;\n        else return undefined;\n      },\n    };\n  }\n\n  _finalized: boolean;\n  _activeStack: Array<string | Generator | Value>;\n  _activeValues: Set<Value>;\n  _activeGeneratorStack: Array<SerializedBody>; // Contains all the active generator bodies in stack order.\n  _residualFunctions: ResidualFunctions;\n  _waitingForValues: Map<Value, Array<{ body: SerializedBody, dependencies: Array<Value>, func: () => void }>>;\n  _waitingForBodies: Map<SerializedBody, Array<{ dependencies: Array<Value>, func: () => void }>>;\n  _body: SerializedBody;\n  _mainBody: SerializedBody;\n  _getReasonToWaitForDependenciesCallbacks: EmitterDependenciesVisitorCallbacks<Value>;\n\n  // Begin to emit something. Such sessions can be nested.\n  // The dependency indicates what is being emitted; until this emission ends, other parties might have to wait for the dependency.\n  // The targetBody is a wrapper that holds the sequence of statements that are going to be emitted.\n  // If isChild, then we are starting a new emitting session as a branch off the previously active emitting session.\n  beginEmitting(dependency: string | Generator | Value, targetBody: SerializedBody, isChild: boolean = false) {\n    invariant(!this._finalized);\n    this._activeStack.push(dependency);\n    if (dependency instanceof Value) {\n      invariant(!this._activeValues.has(dependency));\n      this._activeValues.add(dependency);\n    } else if (dependency instanceof Generator) {\n      invariant(!this._activeGeneratorStack.includes(targetBody));\n      this._activeGeneratorStack.push(targetBody);\n    }\n    if (isChild) {\n      invariant(targetBody.type === \"Generator\" || targetBody.type === \"ConditionalAssignmentBranch\");\n      targetBody.parentBody = this._body;\n      targetBody.nestingLevel = (this._body.nestingLevel || 0) + 1;\n    }\n    let oldBody = this._body;\n    this._body = targetBody;\n    return oldBody;\n  }\n  emit(statement: BabelNodeStatement) {\n    invariant(!this._finalized);\n    this._body.entries.push(statement);\n    this._processCurrentBody();\n  }\n  // End to emit something. The parameters dependency and isChild must match a previous call to beginEmitting.\n  // oldBody should be the value returned by the previous matching beginEmitting call.\n  endEmitting(dependency: string | Generator | Value, oldBody: SerializedBody, isChild: boolean = false) {\n    invariant(!this._finalized);\n    let lastDependency = this._activeStack.pop();\n    invariant(dependency === lastDependency);\n    if (dependency instanceof Value) {\n      invariant(this._activeValues.has(dependency));\n      this._activeValues.delete(dependency);\n      this._processValue(dependency);\n    } else if (dependency instanceof Generator) {\n      invariant(this._isEmittingActiveGenerator());\n      this._activeGeneratorStack.pop();\n    }\n    let lastBody = this._body;\n    this._body = oldBody;\n    if (isChild) {\n      invariant(lastBody.parentBody === oldBody);\n      invariant((lastBody.nestingLevel || 0) > 0);\n      invariant(!lastBody.done);\n      lastBody.done = true;\n      // When we are done processing a body, we can propogate all declared abstract values\n      // to its parent, possibly unlocking further processing...\n      if (lastBody.declaredAbstractValues) {\n        let anyPropagated = true;\n        for (let b = lastBody; b.done && b.parentBody !== undefined && anyPropagated; b = b.parentBody) {\n          anyPropagated = false;\n          let parentDeclaredAbstractValues = b.parentBody.declaredAbstractValues;\n          if (parentDeclaredAbstractValues === undefined)\n            b.parentBody.declaredAbstractValues = parentDeclaredAbstractValues = new Map();\n          invariant(b.declaredAbstractValues);\n          for (let [key, value] of b.declaredAbstractValues) {\n            if (!parentDeclaredAbstractValues.has(key)) {\n              parentDeclaredAbstractValues.set(key, value);\n              this._processValue(key);\n              anyPropagated = true;\n            }\n          }\n        }\n      }\n    }\n\n    return lastBody;\n  }\n  finalize() {\n    invariant(!this._finalized);\n    invariant(this._activeGeneratorStack.length === 1);\n    invariant(this._activeGeneratorStack[0] === this._body);\n    invariant(this._body === this._mainBody);\n    this._processCurrentBody();\n    this._activeGeneratorStack.pop();\n    this._finalized = true;\n    invariant(this._waitingForBodies.size === 0);\n    invariant(this._waitingForValues.size === 0);\n    invariant(this._activeStack.length === 0);\n    invariant(this._activeValues.size === 0);\n    invariant(this._activeGeneratorStack.length === 0);\n  }\n  /**\n   * Emitter is emitting in two modes:\n   * 1. Emitting to entries in current active generator\n   * 2. Emitting to body of another scope(generator or residual function)\n   * This function checks the first condition above.\n   */\n  _isEmittingActiveGenerator(): boolean {\n    invariant(this._activeGeneratorStack.length > 0);\n    return this._activeGeneratorStack[this._activeGeneratorStack.length - 1] === this._body;\n  }\n  _isGeneratorBody(body: SerializedBody): boolean {\n    return body.type === \"MainGenerator\" || body.type === \"Generator\" || body.type === \"AdditionalFunction\";\n  }\n  _processCurrentBody() {\n    if (!this._isEmittingActiveGenerator()) {\n      return;\n    }\n    let a = this._waitingForBodies.get(this._body);\n    if (a === undefined) return;\n    while (a.length > 0) {\n      let { dependencies, func } = a.shift();\n      this.emitNowOrAfterWaitingForDependencies(dependencies, func);\n    }\n    this._waitingForBodies.delete(this._body);\n  }\n  _processValue(value: Value) {\n    let a = this._waitingForValues.get(value);\n    if (a === undefined) return;\n    let currentBody = this._body;\n    while (a.length > 0) {\n      let { body, dependencies, func } = a.shift();\n      // If body is not generator body no need to wait for it.\n      if (this._isGeneratorBody(body) && body !== currentBody) {\n        this._emitAfterWaitingForGeneratorBody(body, dependencies, func);\n      } else {\n        this.emitNowOrAfterWaitingForDependencies(dependencies, func, body);\n      }\n    }\n    this._waitingForValues.delete(value);\n  }\n\n  // Find the first ancestor in input generator body stack that is in current active stack.\n  // It can always find one because the bottom one in the stack is the main generator.\n  _getFirstAncestorGeneratorWithActiveBody(bodyStack: Array<SerializedBody>): SerializedBody {\n    const activeBody = bodyStack.slice().reverse().find(body => this._activeGeneratorStack.includes(body));\n    invariant(activeBody);\n    return activeBody;\n  }\n\n  // Serialization of a statement related to a value MUST be delayed if\n  // the creation of the value's identity requires the availability of either:\n  // 1. a value that is also currently being serialized\n  //    (tracked by `_activeValues`).\n  // 2. a time-dependent value that is declared by some generator entry\n  //    that has not yet been processed\n  //    (tracked by `declaredAbstractValues` in bodies)\n  getReasonToWaitForDependencies(dependencies: Value | Array<Value>): void | Value {\n    return this.dependenciesVisitor(dependencies, this._getReasonToWaitForDependenciesCallbacks);\n  }\n\n  // Visitor of dependencies that require delaying serialization\n  dependenciesVisitor<T>(\n    dependencies: Value | Array<Value>,\n    callbacks: EmitterDependenciesVisitorCallbacks<T>\n  ): void | T {\n    invariant(!this._finalized);\n\n    let result;\n    let recurse = value => this.dependenciesVisitor(value, callbacks);\n\n    if (Array.isArray(dependencies)) {\n      let values = ((dependencies: any): Array<Value>);\n      for (let value of values) {\n        result = recurse(value);\n        if (result !== undefined) return result;\n      }\n      return undefined;\n    }\n\n    let val = ((dependencies: any): Value);\n    if (this._activeValues.has(val)) {\n      // We ran into a cyclic dependency, where the value we are dependending on is still in the process of being emitted.\n      result = callbacks.onActive ? callbacks.onActive(val) : undefined;\n      if (result !== undefined) return result;\n    }\n\n    if (val instanceof BoundFunctionValue) {\n      result = recurse(val.$BoundTargetFunction);\n      if (result !== undefined) return result;\n      result = recurse(val.$BoundThis);\n      if (result !== undefined) return result;\n      result = recurse(val.$BoundArguments);\n      if (result !== undefined) return result;\n    } else if (val instanceof FunctionValue) {\n      // We ran into a function value.\n      result = callbacks.onFunction ? callbacks.onFunction(val) : undefined;\n      if (result !== undefined) return result;\n    } else if (val instanceof AbstractValue) {\n      if (val.hasIdentifier()) {\n        // We ran into an abstract value that might have to be declared.\n        result = callbacks.onAbstractValueWithIdentifier ? callbacks.onAbstractValueWithIdentifier(val) : undefined;\n        if (result !== undefined) return result;\n      }\n      result = recurse(val.args);\n      if (result !== undefined) return result;\n    } else if (val instanceof ProxyValue) {\n      result = recurse(val.$ProxyTarget);\n      if (result !== undefined) return result;\n      result = recurse(val.$ProxyHandler);\n      if (result !== undefined) return result;\n    } else if (val instanceof SymbolValue) {\n      if (val.$Description instanceof Value) {\n        result = recurse(val.$Description);\n        if (result !== undefined) return result;\n      }\n    } else if (val instanceof ObjectValue) {\n      let kind = val.getKind();\n      switch (kind) {\n        case \"Object\":\n          let proto = val.$Prototype;\n          if (proto instanceof ObjectValue) {\n            result = recurse(val.$Prototype);\n            if (result !== undefined) return result;\n          }\n          break;\n        case \"Date\":\n          invariant(val.$DateValue !== undefined);\n          result = recurse(val.$DateValue);\n          if (result !== undefined) return result;\n          break;\n        default:\n          break;\n      }\n    }\n\n    return undefined;\n  }\n\n  // Wait for a known-to-be active value if a condition is met.\n  getReasonToWaitForActiveValue(value: Value, condition: boolean): void | Value {\n    invariant(!this._finalized);\n    invariant(this._activeValues.has(value));\n    return condition ? value : undefined;\n  }\n  _shouldEmitWithoutWaiting(delayReason: void | Value | SerializedBody, targetBody?: SerializedBody): boolean {\n    /**\n     * We can directly emit without waiting if:\n     * 1. No delayReason\n     * 2. delayReason is a generator body while the target body we are not emitting into is not a generator body.\n     */\n    return (\n      !delayReason ||\n      (!(delayReason instanceof Value) &&\n        this._isGeneratorBody(delayReason) &&\n        targetBody !== undefined &&\n        !this._isGeneratorBody(targetBody))\n    );\n  }\n  emitAfterWaiting(\n    delayReason: void | Value | SerializedBody,\n    dependencies: Array<Value>,\n    func: () => void,\n    targetBody?: SerializedBody\n  ) {\n    if (this._shouldEmitWithoutWaiting(delayReason, targetBody)) {\n      if (targetBody === undefined || targetBody === this._body) {\n        // Emit into current body.\n        func();\n      } else {\n        invariant(!this._isGeneratorBody(targetBody));\n        const oldBody = this.beginEmitting(targetBody.type, targetBody);\n        func();\n        this.endEmitting(targetBody.type, oldBody);\n      }\n    } else {\n      invariant(delayReason !== undefined);\n      if (delayReason instanceof Value) {\n        this._emitAfterWaitingForValue(\n          delayReason,\n          dependencies,\n          targetBody === undefined ? this._body : targetBody,\n          func\n        );\n      } else if (this._isGeneratorBody(delayReason)) {\n        // delayReason is a generator body.\n        this._emitAfterWaitingForGeneratorBody(delayReason, dependencies, func);\n      } else {\n        // Unknown delay reason.\n        invariant(false);\n      }\n    }\n  }\n  _emitAfterWaitingForValue(reason: Value, dependencies: Array<Value>, targetBody: SerializedBody, func: () => void) {\n    invariant(!this._finalized);\n    invariant(!(reason instanceof AbstractValue && this.hasBeenDeclared(reason)) || this._activeValues.has(reason));\n    let a = this._waitingForValues.get(reason);\n    if (a === undefined) this._waitingForValues.set(reason, (a = []));\n    a.push({ body: targetBody, dependencies, func });\n  }\n  _emitAfterWaitingForGeneratorBody(reason: SerializedBody, dependencies: Array<Value>, func: () => void) {\n    invariant(this._isGeneratorBody(reason));\n    invariant(!this._finalized);\n    invariant(this._activeGeneratorStack.includes(reason));\n    let b = this._waitingForBodies.get(reason);\n    if (b === undefined) this._waitingForBodies.set(reason, (b = []));\n    b.push({ dependencies, func });\n  }\n  emitNowOrAfterWaitingForDependencies(dependencies: Array<Value>, func: () => void, targetBody?: SerializedBody) {\n    invariant(!this._finalized);\n    this.emitAfterWaiting(this.getReasonToWaitForDependencies(dependencies), dependencies, func, targetBody);\n  }\n  declare(value: AbstractValue) {\n    invariant(!this._finalized);\n    invariant(!this._activeValues.has(value));\n    invariant(value.hasIdentifier());\n    invariant(this._isEmittingActiveGenerator());\n    invariant(!this.cannotDeclare());\n    invariant(!this._body.done);\n    if (this._body.declaredAbstractValues === undefined) this._body.declaredAbstractValues = new Map();\n    this._body.declaredAbstractValues.set(value, this._body);\n    this._processValue(value);\n  }\n  emittingToAdditionalFunction() {\n    // Whether we are directly or indirectly emitting to an additional function\n    for (let b = this._body; b !== undefined; b = b.parentBody) if (b.type === \"AdditionalFunction\") return true;\n    return false;\n  }\n  cannotDeclare(): boolean {\n    // Bodies of the following types will never contain any (temporal) abstract value declarations.\n    return this._body.type === \"DelayInitializations\" || this._body.type === \"LazyObjectInitializer\";\n  }\n  hasBeenDeclared(value: AbstractValue): boolean {\n    return this.getDeclarationBody(value) !== undefined;\n  }\n  getDeclarationBody(value: AbstractValue): void | SerializedBody {\n    for (let b = this._body; b !== undefined; b = b.parentBody)\n      if (b.declaredAbstractValues !== undefined && b.declaredAbstractValues.has(value)) {\n        return b;\n      }\n    return undefined;\n  }\n  declaredCount() {\n    let declaredAbstractValues = this._body.declaredAbstractValues;\n    return declaredAbstractValues === undefined ? 0 : declaredAbstractValues.size;\n  }\n  getBody(): SerializedBody {\n    return this._body;\n  }\n  isCurrentBodyOffspringOf(targetBody: SerializedBody): boolean {\n    let currentBody = this._body;\n    while (currentBody !== undefined) {\n      if (currentBody === targetBody) {\n        return true;\n      }\n      currentBody = currentBody.parentBody;\n    }\n    return false;\n  }\n  getBodyReference() {\n    invariant(!this._finalized);\n    return new BodyReference(this._body, this._body.entries.length);\n  }\n}\n"]}