{"version":3,"sources":["../../src/utils/paths.js"],"names":["PathImplementation","implies","condition","mightNotBeTrue","path","$Realm","pathConditions","i","length","pathCondition","impliesNot","mightNotBeFalse","withCondition","evaluate","realm","savedPath","pushPathCondition","pushRefinedConditions","withInverseCondition","pushInversePathCondition","pushAndRefine","pushInverseAndRefine","kind","left","args","right","op","leftNeNull","createFromBinaryOp","intrinsics","null","leftNeUndefined","undefined","push","leftEqNull","leftEqUndefined","inverseCondition","createFromUnaryOp","simplifiedInverseCondition","simplifyAndRefineAbstractCondition","equals","unrefinedConditions","unrefinedCond"],"mappings":"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","file":"paths.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { AbstractValue, ConcreteValue, NullValue, UndefinedValue, Value } from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\n\nexport class PathImplementation {\n  implies(condition: AbstractValue): boolean {\n    if (!condition.mightNotBeTrue()) return true; // any path implies true\n    let path = condition.$Realm.pathConditions;\n    for (let i = path.length - 1; i >= 0; i--) {\n      let pathCondition = path[i];\n      if (pathCondition.implies(condition)) return true;\n    }\n    return false;\n  }\n\n  impliesNot(condition: AbstractValue): boolean {\n    if (!condition.mightNotBeFalse()) return true; // any path implies !false\n    let path = condition.$Realm.pathConditions;\n    for (let i = path.length - 1; i >= 0; i--) {\n      let pathCondition = path[i];\n      if (pathCondition.impliesNot(condition)) return true;\n    }\n    return false;\n  }\n\n  withCondition<T>(condition: AbstractValue, evaluate: () => T): T {\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = [];\n    try {\n      pushPathCondition(condition);\n      pushRefinedConditions(savedPath);\n      return evaluate();\n    } finally {\n      realm.pathConditions = savedPath;\n    }\n  }\n\n  withInverseCondition<T>(condition: AbstractValue, evaluate: () => T): T {\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = [];\n    try {\n      pushInversePathCondition(condition);\n      pushRefinedConditions(savedPath);\n      return evaluate();\n    } finally {\n      realm.pathConditions = savedPath;\n    }\n  }\n\n  pushAndRefine(condition: AbstractValue) {\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = [];\n\n    pushPathCondition(condition);\n    pushRefinedConditions(savedPath);\n  }\n\n  pushInverseAndRefine(condition: AbstractValue) {\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = [];\n\n    pushInversePathCondition(condition);\n    pushRefinedConditions(savedPath);\n  }\n}\n\n// A path condition is an abstract value that is known to be true in a particular code path\nfunction pushPathCondition(condition: Value) {\n  invariant(condition.mightNotBeFalse(), \"pushing false\"); // it is mistake to assert that false is true\n  if (condition instanceof ConcreteValue) return;\n  if (!condition.mightNotBeTrue()) return;\n  invariant(condition instanceof AbstractValue);\n  let realm = condition.$Realm;\n  if (condition.kind === \"&&\") {\n    let left = condition.args[0];\n    let right = condition.args[1];\n    invariant(left instanceof AbstractValue); // it is a mistake to create an abstract value when concrete value will do\n    pushPathCondition(left);\n    pushPathCondition(right);\n  } else {\n    if (condition.kind === \"!=\" || condition.kind === \"==\") {\n      let left = condition.args[0];\n      let right = condition.args[1];\n      if (left instanceof ConcreteValue && right instanceof AbstractValue) [left, right] = [right, left];\n      if (left instanceof AbstractValue && (right instanceof UndefinedValue || right instanceof NullValue)) {\n        let op = condition.kind === \"!=\" ? \"!==\" : \"===\";\n        if (op === \"!==\") pushPathCondition(left);\n        else pushInversePathCondition(left);\n        let leftNeNull = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.null);\n        if (leftNeNull.mightNotBeFalse()) pushPathCondition(leftNeNull);\n        let leftNeUndefined = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.undefined);\n        if (leftNeUndefined.mightNotBeFalse()) pushPathCondition(leftNeUndefined);\n        return;\n      }\n    }\n    realm.pathConditions.push(condition);\n  }\n}\n\n// An inverse path condition is an abstract value that is known to be false in a particular code path\nfunction pushInversePathCondition(condition: Value) {\n  // it is mistake to assert that true is false.\n  invariant(condition.mightNotBeTrue());\n  if (condition instanceof ConcreteValue) return;\n  invariant(condition instanceof AbstractValue);\n  if (condition.kind === \"||\") {\n    let left = condition.args[0];\n    let right = condition.args[1];\n    invariant(left instanceof AbstractValue); // it is a mistake to create an abstract value when concrete value will do\n    pushInversePathCondition(left);\n    if (right.mightNotBeTrue()) pushInversePathCondition(right);\n  } else {\n    let realm = condition.$Realm;\n    if (condition.kind === \"!=\" || condition.kind === \"==\") {\n      let left = condition.args[0];\n      let right = condition.args[1];\n      if (left instanceof ConcreteValue && right instanceof AbstractValue) [left, right] = [right, left];\n      if (left instanceof AbstractValue && (right instanceof UndefinedValue || right instanceof NullValue)) {\n        let op = condition.kind === \"!=\" ? \"===\" : \"!==\";\n        if (op === \"!==\") pushInversePathCondition(left);\n        else pushPathCondition(left);\n        let leftEqNull = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.null);\n        if (leftEqNull.mightNotBeFalse()) pushPathCondition(leftEqNull);\n        let leftEqUndefined = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.undefined);\n        if (leftEqUndefined.mightNotBeFalse()) pushPathCondition(leftEqUndefined);\n        return;\n      }\n    }\n    let inverseCondition = AbstractValue.createFromUnaryOp(realm, \"!\", condition);\n    pushPathCondition(inverseCondition);\n    if (inverseCondition instanceof AbstractValue) {\n      let simplifiedInverseCondition = realm.simplifyAndRefineAbstractCondition(inverseCondition);\n      if (!simplifiedInverseCondition.equals(inverseCondition)) pushPathCondition(simplifiedInverseCondition);\n    }\n  }\n}\n\nfunction pushRefinedConditions(unrefinedConditions: Array<AbstractValue>) {\n  for (let unrefinedCond of unrefinedConditions) {\n    pushPathCondition(unrefinedCond.$Realm.simplifyAndRefineAbstractCondition(unrefinedCond));\n  }\n}\n"]}