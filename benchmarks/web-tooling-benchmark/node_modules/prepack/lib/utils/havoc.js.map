{"version":3,"sources":["../../src/utils/havoc.js"],"names":["t","visitName","path","state","name","read","write","scope","hasBinding","unboundReads","add","unboundWrites","ignorePath","parent","isLabeledStatement","isBreakStatement","isContinueStatement","HavocedClosureRefVisitor","ReferencedIdentifier","innerName","node","doesRead","operator","getBindingIdentifiers","getHavocedFunctionInfo","value","constructor","functionInfo","Set","formalParameters","$FormalParameters","code","$ECMAScriptCode","file","program","expressionStatement","functionExpression","ObjectValueHavocingVisitor","objectsTrackedForHavoc","visitedValues","mustVisit","val","has","visitObjectProperty","binding","desc","descriptor","undefined","visitDescriptor","visitObjectProperties","obj","kind","propertyBindingValue","symbols","properties","unknownProperty","visitObjectPropertiesWithComputedNames","visitObjectPrototype","$Realm","isHavocedObject","havoc","proto","$Prototype","visitValue","absVal","args","length","cond","P","V","earlier_props","consequent","alternate","get","set","visitDeclarativeEnvironmentRecordBinding","record","remainingHavocedBindings","bindings","bindingName","Object","keys","isRead","delete","isWritten","visitValueMap","getKind","entries","$MapData","$WeakMapData","len","i","entry","key","$Key","$Value","visitValueSet","$SetData","$WeakSetData","visitValueFunction","$BoundTargetFunction","$BoundThis","boundArg","$BoundArguments","environment","$Environment","environmentRecord","object","fn","$FunctionObject","visitValueObject","dateValue","$DateValue","buf","$ViewedArrayBuffer","$ParameterMap","visitValueProxy","$ProxyTarget","$ProxyHandler","visitAbstractValue","n","isIntrinsic","originalConstructor","ensureFrozenValue","realm","loc","diag","currentLocation","handleError","HavocImplementation","createdObjectsTrackedForLeaks","visitor"],"mappings":"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","file":"havoc.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding, ObjectKind } from \"../types.js\";\nimport {\n  havocBinding,\n  DeclarativeEnvironmentRecord,\n  FunctionEnvironmentRecord,\n  ObjectEnvironmentRecord,\n  GlobalEnvironmentRecord,\n} from \"../environment.js\";\nimport {\n  BoundFunctionValue,\n  ProxyValue,\n  AbstractValue,\n  EmptyValue,\n  FunctionValue,\n  PrimitiveValue,\n  Value,\n  ObjectValue,\n  NativeFunctionValue,\n  ECMAScriptSourceFunctionValue,\n} from \"../values/index.js\";\nimport { TestIntegrityLevel } from \"../methods/index.js\";\nimport * as t from \"babel-types\";\nimport traverse from \"babel-traverse\";\nimport type { BabelTraversePath } from \"babel-traverse\";\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\ntype HavocedFunctionInfo = {\n  unboundReads: Set<string>,\n  unboundWrites: Set<string>,\n};\n\nfunction visitName(path: BabelTraversePath, state: HavocedFunctionInfo, name: string, read: boolean, write: boolean) {\n  // Is the name bound to some local identifier? If so, we don't need to do anything\n  if (path.scope.hasBinding(name, /*noGlobals*/ true)) return;\n\n  // Otherwise, let's record that there's an unbound identifier\n  if (read) state.unboundReads.add(name);\n  if (write) state.unboundWrites.add(name);\n}\n\nfunction ignorePath(path: BabelTraversePath) {\n  let parent = path.parent;\n  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);\n}\n\nlet HavocedClosureRefVisitor = {\n  ReferencedIdentifier(path: BabelTraversePath, state: HavocedFunctionInfo) {\n    if (ignorePath(path)) return;\n\n    let innerName = path.node.name;\n    if (innerName === \"arguments\") {\n      return;\n    }\n    visitName(path, state, innerName, true, false);\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: HavocedFunctionInfo) {\n    let doesRead = path.node.operator !== \"=\";\n    for (let name in path.getBindingIdentifiers()) {\n      visitName(path, state, name, doesRead, true);\n    }\n  },\n};\n\nfunction getHavocedFunctionInfo(value: FunctionValue) {\n  // TODO: This should really be cached on a per AST basis in case we have\n  // many uses of the same closure. It should ideally share this cache\n  // and data with ResidualHeapVisitor.\n  invariant(value instanceof ECMAScriptSourceFunctionValue);\n  invariant(value.constructor === ECMAScriptSourceFunctionValue);\n  let functionInfo = {\n    unboundReads: new Set(),\n    unboundWrites: new Set(),\n  };\n  let formalParameters = value.$FormalParameters;\n  invariant(formalParameters != null);\n  let code = value.$ECMAScriptCode;\n  invariant(code != null);\n\n  traverse(\n    t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])),\n    HavocedClosureRefVisitor,\n    null,\n    functionInfo\n  );\n  return functionInfo;\n}\n\nclass ObjectValueHavocingVisitor {\n  // ObjectValues to visit if they're reachable.\n  objectsTrackedForHavoc: Set<ObjectValue>;\n  // Values that has been visited.\n  visitedValues: Set<Value>;\n\n  constructor(objectsTrackedForHavoc: Set<ObjectValue>) {\n    this.objectsTrackedForHavoc = objectsTrackedForHavoc;\n    this.visitedValues = new Set();\n  }\n\n  mustVisit(val: Value): boolean {\n    if (val instanceof ObjectValue) {\n      // For Objects we only need to visit it if it is tracked\n      // as a newly created object that might still be mutated.\n      // Abstract values gets their arguments visited.\n      if (!this.objectsTrackedForHavoc.has(val)) return false;\n    }\n    if (this.visitedValues.has(val)) return false;\n    this.visitedValues.add(val);\n    return true;\n  }\n\n  visitObjectProperty(binding: PropertyBinding) {\n    let desc = binding.descriptor;\n    if (desc === undefined) return; //deleted\n    this.visitDescriptor(desc);\n  }\n\n  visitObjectProperties(obj: ObjectValue, kind?: ObjectKind): void {\n    // visit symbol properties\n    for (let [, propertyBindingValue] of obj.symbols) {\n      invariant(propertyBindingValue);\n      this.visitObjectProperty(propertyBindingValue);\n    }\n\n    // visit string properties\n    for (let [, propertyBindingValue] of obj.properties) {\n      invariant(propertyBindingValue);\n      this.visitObjectProperty(propertyBindingValue);\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        this.visitObjectPropertiesWithComputedNames(val);\n      }\n    }\n\n    // prototype\n    this.visitObjectPrototype(obj);\n\n    if (TestIntegrityLevel(obj.$Realm, obj, \"frozen\")) return;\n\n    // if this object wasn't already havoced, we need mark it as havoced\n    // so that any mutation and property access get tracked after this.\n    if (!obj.isHavocedObject()) {\n      obj.havoc();\n    }\n  }\n\n  visitObjectPrototype(obj: ObjectValue) {\n    let proto = obj.$Prototype;\n    this.visitValue(proto);\n  }\n\n  visitObjectPropertiesWithComputedNames(absVal: AbstractValue): void {\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      invariant(P instanceof AbstractValue);\n      let V = absVal.args[1];\n      let earlier_props = absVal.args[2];\n      if (earlier_props instanceof AbstractValue) this.visitObjectPropertiesWithComputedNames(earlier_props);\n      this.visitValue(P);\n      this.visitValue(V);\n    } else {\n      // conditional assignment\n      this.visitValue(cond);\n      let consequent = absVal.args[1];\n      invariant(consequent instanceof AbstractValue);\n      let alternate = absVal.args[2];\n      invariant(alternate instanceof AbstractValue);\n      this.visitObjectPropertiesWithComputedNames(consequent);\n      this.visitObjectPropertiesWithComputedNames(alternate);\n    }\n  }\n\n  visitDescriptor(desc: Descriptor): void {\n    invariant(desc.value === undefined || desc.value instanceof Value);\n    if (desc.value !== undefined) this.visitValue(desc.value);\n    if (desc.get !== undefined) this.visitValue(desc.get);\n    if (desc.set !== undefined) this.visitValue(desc.set);\n  }\n\n  visitDeclarativeEnvironmentRecordBinding(\n    record: DeclarativeEnvironmentRecord,\n    remainingHavocedBindings: HavocedFunctionInfo\n  ) {\n    let bindings = record.bindings;\n    for (let bindingName of Object.keys(bindings)) {\n      let binding = bindings[bindingName];\n      // Check if this binding is referenced, and if so delete it from the set.\n      let isRead = remainingHavocedBindings.unboundReads.delete(bindingName);\n      let isWritten = remainingHavocedBindings.unboundWrites.delete(bindingName);\n      if (isRead) {\n        // If this binding can be read from the closure, its value has now havoced.\n        let value = binding.value;\n        if (value) {\n          this.visitValue(value);\n        }\n      }\n      if (isWritten || isRead) {\n        // If this binding could have been mutated from the closure, then the\n        // binding itself has now leaked, but not necessarily the value in it.\n        // TODO: We could tag a leaked binding as read and/or write. That way\n        // we don't have to havoc values written to this binding if only the binding\n        // has been written to. We also don't have to havoc reads from this binding\n        // if it is only read from.\n        havocBinding(binding);\n      }\n    }\n  }\n\n  visitValueMap(val: ObjectValue): void {\n    let kind = val.getKind();\n\n    let entries;\n    if (kind === \"Map\") {\n      entries = val.$MapData;\n    } else {\n      invariant(kind === \"WeakMap\");\n      entries = val.$WeakMapData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined) continue;\n      this.visitValue(key);\n      this.visitValue(value);\n    }\n  }\n\n  visitValueSet(val: ObjectValue): void {\n    let kind = val.getKind();\n\n    let entries;\n    if (kind === \"Set\") {\n      entries = val.$SetData;\n    } else {\n      invariant(kind === \"WeakSet\");\n      entries = val.$WeakSetData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined) continue;\n      this.visitValue(entry);\n    }\n  }\n\n  visitValueFunction(val: FunctionValue): void {\n    if (val.isHavocedObject()) {\n      return;\n    }\n    this.visitObjectProperties(val);\n\n    if (val instanceof BoundFunctionValue) {\n      this.visitValue(val.$BoundTargetFunction);\n      this.visitValue(val.$BoundThis);\n      for (let boundArg of val.$BoundArguments) this.visitValue(boundArg);\n      return;\n    }\n\n    invariant(\n      !(val instanceof NativeFunctionValue),\n      \"all native function values should have already been created outside this pure function\"\n    );\n\n    let remainingHavocedBindings = getHavocedFunctionInfo(val);\n\n    let environment = val.$Environment.parent;\n    while (environment) {\n      let record = environment.environmentRecord;\n      if (record instanceof ObjectEnvironmentRecord) {\n        this.visitValue(record.object);\n        continue;\n      }\n      if (record instanceof GlobalEnvironmentRecord) {\n        break;\n      }\n\n      invariant(record instanceof DeclarativeEnvironmentRecord);\n      this.visitDeclarativeEnvironmentRecordBinding(record, remainingHavocedBindings);\n\n      if (record instanceof FunctionEnvironmentRecord) {\n        // If this is a function environment, which is not tracked for havocs,\n        // we can bail out because its bindings should not be mutated in a\n        // pure function.\n        let fn = record.$FunctionObject;\n        if (!this.objectsTrackedForHavoc.has(fn)) {\n          break;\n        }\n      }\n      environment = environment.parent;\n    }\n  }\n\n  visitValueObject(val: ObjectValue): void {\n    if (val.isHavocedObject()) {\n      return;\n    }\n\n    let kind = val.getKind();\n    this.visitObjectProperties(val, kind);\n\n    switch (kind) {\n      case \"RegExp\":\n      case \"Number\":\n      case \"String\":\n      case \"Boolean\":\n      case \"ReactElement\":\n      case \"ArrayBuffer\":\n      case \"Array\":\n        return;\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        this.visitValue(dateValue);\n        return;\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        let buf = val.$ViewedArrayBuffer;\n        invariant(buf !== undefined);\n        this.visitValue(buf);\n        return;\n      case \"Map\":\n      case \"WeakMap\":\n        this.visitValueMap(val);\n        return;\n      case \"Set\":\n      case \"WeakSet\":\n        this.visitValueSet(val);\n        return;\n      default:\n        invariant(kind === \"Object\", `Object of kind ${kind} is not supported in calls to abstract functions.`);\n        invariant(\n          this.$ParameterMap === undefined,\n          `Arguments object is not supported in calls to abstract functions.`\n        );\n        return;\n    }\n  }\n\n  visitValueProxy(val: ProxyValue): void {\n    this.visitValue(val.$ProxyTarget);\n    this.visitValue(val.$ProxyHandler);\n  }\n\n  visitAbstractValue(val: AbstractValue): void {\n    for (let i = 0, n = val.args.length; i < n; i++) {\n      this.visitValue(val.args[i]);\n    }\n  }\n\n  visitValue(val: Value): void {\n    if (val instanceof AbstractValue) {\n      if (this.mustVisit(val)) this.visitAbstractValue(val);\n    } else if (val.isIntrinsic()) {\n      // All intrinsic values exist from the beginning of time...\n      // ...except for a few that come into existance as templates for abstract objects.\n      this.mustVisit(val);\n    } else if (val instanceof EmptyValue) {\n      this.mustVisit(val);\n    } else if (val instanceof PrimitiveValue) {\n      this.mustVisit(val);\n    } else if (val instanceof ProxyValue) {\n      if (this.mustVisit(val)) this.visitValueProxy(val);\n    } else if (val instanceof FunctionValue) {\n      invariant(val instanceof FunctionValue);\n      if (this.mustVisit(val)) this.visitValueFunction(val);\n    } else {\n      invariant(val instanceof ObjectValue);\n      if (val.originalConstructor !== undefined) {\n        invariant(val instanceof ObjectValue);\n        if (this.mustVisit(val)) this.visitValueObject(val);\n      } else {\n        if (this.mustVisit(val)) this.visitValueObject(val);\n      }\n    }\n  }\n}\n\nfunction ensureFrozenValue(realm, value, loc) {\n  // TODO: This should really check if it is recursively immutability.\n  if (value instanceof ObjectValue && !TestIntegrityLevel(realm, value, \"frozen\")) {\n    let diag = new CompilerDiagnostic(\n      \"Unfrozen object leaked before end of global code\",\n      loc || realm.currentLocation,\n      \"PP0017\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(diag) !== \"Recover\") throw new FatalError();\n  }\n}\n\n// Ensure that a value is immutable. If it is not, set all its properties to abstract values\n// and all reachable bindings to abstract values.\nexport class HavocImplementation {\n  value(realm: Realm, value: Value, loc: ?BabelNodeSourceLocation) {\n    let objectsTrackedForHavoc = realm.createdObjectsTrackedForLeaks;\n    if (objectsTrackedForHavoc === undefined) {\n      // We're not tracking a pure function. That means that we would track\n      // everything as havoced. We'll assume that any object argument\n      // is invalid unless it's frozen.\n      ensureFrozenValue(realm, value, loc);\n    } else {\n      // If we're tracking a pure function, we can assume that only newly\n      // created objects and bindings, within it, are mutable. Any other\n      // object can safely be assumed to be deeply immutable as far as this\n      // pure function is concerned. However, any mutable object needs to\n      // be tainted as possibly having changed to anything.\n      let visitor = new ObjectValueHavocingVisitor(objectsTrackedForHavoc);\n      visitor.visitValue(value);\n    }\n  }\n}\n"]}