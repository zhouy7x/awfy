{"version":3,"sources":["../../src/utils/generator.js"],"names":["t","serializeBody","generator","context","statements","serializeGenerator","length","type","blockStatement","Generator","constructor","realm","name","useAbstractInterpretation","realmPreludeGenerator","preludeGenerator","_entries","id","nextGeneratorId","_name","getName","getAsPropertyNameExpression","key","canBeIdentifier","index","Number","parseInt","toString","numericLiteral","keyIsAscii","test","isValidIdentifier","identifier","stringLiteral","empty","emitGlobalDeclaration","value","declaredGlobals","add","emitGlobalAssignment","strictMode","_addEntry","args","buildNode","valueNode","expressionStatement","assignmentExpression","globalReference","emitConcreteModel","emitGlobalDelete","unaryExpression","emitBindingAssignment","binding","serializeBinding","emitPropertyAssignment","object","refuseSerialization","propName","objectNode","memberExpression","isIdentifier","emitDefineProperty","desc","isDescChanged","enumerable","configurable","writable","descValue","Object","assign","$Realm","intrinsics","undefined","get","set","_","emitDefinePropertyBody","emitPropertyDelete","emitCall","createCallee","values","callExpression","emitConsoleLog","method","map","v","emitDoWhileStatement","body","testId","intrinsicName","block","doWhileStatement","dependencies","emitFullInvariant","propertyIdentifier","computed","accessedPropertyOf","condition","isTop","concreteComparisons","typeComparisons","Set","populateComparisonsLists","absValue","kind","nestedValue","push","getType","checks","concreteValue","binaryExpression","valueToNode","serialize","concat","typeValue","typeString","typeToString","reduce","expr","newCondition","logicalExpression","emitInvariant","objnode","violationConditionFn","appendLastToInvariantFn","omitInvariants","nodes","throwString","last","pop","throwblock","throwStatement","newExpression","ifStatement","emitCallAndCaptureResult","types","derive","emitStatement","buildNode_","emitVoidExpression","Function","emitForInStatement","o","lh","sourceObject","targetObject","boundName","obj","tgt","src","obj1","tgt1","src1","forInStatement","optionalArgs","nameGenerator","generate","derivedIds","options","Constructor","isTypeCompatibleWith","res","isPure","declared","variableDeclaration","variableDeclarator","skipInvariant","typeofString","node","entry","canOmit","boundArg","i","serializeValue","emit","declare","visitEntry","callbacks","canSkip","recordDelayedEntry","recordDeclaration","visitValues","dependency","visitGenerator","visit","appendGenerator","other","leadingComment","statement","leadingComments","composeGenerators","generator1","generator2","statements1","statements2","joinGenerators","joinCondition","cond","block1","block2","replaceInvalidCharactersWithUnderscore","string","replace","base62characters","base62encode","n","s","f","NameGenerator","forbiddenNames","debugNames","uniqueSuffix","prefix","uidCounter","debugSuffix","has","PreludeGenerator","prelude","Map","memoizedRefs","usesThis","createNameGenerator","convertStringToMember","str","split","memoizeReference","thisExpression","prop","globalScope","keyNode","ref","init","includes","lastIndexOf","substr"],"mappings":"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","file":"generator.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { Binding } from \"../environment.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  FunctionValue,\n  NullValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport type { AbstractValueBuildNodeFunction } from \"../values/AbstractValue.js\";\nimport { hashString } from \"../methods/index.js\";\nimport type { Descriptor } from \"../types.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeIdentifier,\n  BabelNodeThisExpression,\n  BabelNodeStatement,\n  BabelNodeMemberExpression,\n  BabelNodeVariableDeclaration,\n  BabelNodeBlockStatement,\n} from \"babel-types\";\nimport { nullExpression } from \"./internalizer.js\";\nimport { Utils, concretize } from \"../singletons.js\";\n\nexport type SerializationContext = {\n  serializeValue: Value => BabelNodeExpression,\n  serializeBinding: Binding => BabelNodeIdentifier | BabelNodeMemberExpression,\n  serializeGenerator: Generator => Array<BabelNodeStatement>,\n  emitDefinePropertyBody: (ObjectValue, string | SymbolValue, Descriptor) => BabelNodeStatement,\n  emit: BabelNodeStatement => void,\n  canOmit: AbstractValue => boolean,\n  declare: AbstractValue => void,\n};\n\nexport type DerivedExpressionBuildNodeFunction = (\n  Array<BabelNodeExpression>,\n  SerializationContext\n) => BabelNodeExpression;\n\nexport type GeneratorBuildNodeFunction = (Array<BabelNodeExpression>, SerializationContext) => BabelNodeStatement;\n\nexport type GeneratorEntry = {\n  declared?: AbstractValue,\n  args: Array<Value>,\n  // If we're just trying to add roots for the serializer to notice, we don't need a buildNode.\n  buildNode?: GeneratorBuildNodeFunction,\n  dependencies?: Array<Generator>,\n  isPure?: boolean,\n};\n\nexport type VisitEntryCallbacks = {|\n  visitValues: (Array<Value>) => void,\n  visitGenerator: (Generator, Generator) => void,\n  canSkip: AbstractValue => boolean,\n  recordDeclaration: AbstractValue => void,\n  recordDelayedEntry: (Generator, GeneratorEntry) => void,\n|};\n\nfunction serializeBody(generator: Generator, context: SerializationContext): BabelNodeBlockStatement {\n  let statements = context.serializeGenerator(generator);\n  if (statements.length === 1 && statements[0].type === \"BlockStatement\") return (statements[0]: any);\n  return t.blockStatement(statements);\n}\n\nexport class Generator {\n  constructor(realm: Realm, name: void | string) {\n    invariant(realm.useAbstractInterpretation);\n    let realmPreludeGenerator = realm.preludeGenerator;\n    invariant(realmPreludeGenerator);\n    this.preludeGenerator = realmPreludeGenerator;\n    this.realm = realm;\n    this._entries = [];\n    this.id = realm.nextGeneratorId++;\n    this._name = name;\n  }\n\n  realm: Realm;\n  _entries: Array<GeneratorEntry>;\n  preludeGenerator: PreludeGenerator;\n\n  id: number;\n  _name: void | string;\n\n  getName(): string {\n    return this._name || `#${this.id}`;\n  }\n\n  getAsPropertyNameExpression(key: string, canBeIdentifier: boolean = true): BabelNodeExpression {\n    // If key is a non-negative numeric string literal, parse it and set it as a numeric index instead.\n    let index = Number.parseInt(key, 10);\n    if (index >= 0 && index.toString() === key) {\n      return t.numericLiteral(index);\n    }\n\n    if (canBeIdentifier) {\n      // TODO #1020: revert this when Unicode identifiers are supported by all targetted JavaScript engines\n      let keyIsAscii = /^[\\u0000-\\u007f]*$/.test(key);\n      if (t.isValidIdentifier(key) && keyIsAscii) return t.identifier(key);\n    }\n\n    return t.stringLiteral(key);\n  }\n\n  empty() {\n    return this._entries.length === 0;\n  }\n\n  emitGlobalDeclaration(key: string, value: Value) {\n    this.preludeGenerator.declaredGlobals.add(key);\n    if (!(value instanceof UndefinedValue)) this.emitGlobalAssignment(key, value, true);\n  }\n\n  emitGlobalAssignment(key: string, value: Value, strictMode: boolean) {\n    this._addEntry({\n      args: [value],\n      buildNode: ([valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", this.preludeGenerator.globalReference(key, !strictMode), valueNode)\n        ),\n    });\n  }\n\n  emitConcreteModel(key: string, value: Value) {\n    this._addEntry({\n      args: [concretize(this.realm, value)],\n      buildNode: ([valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", this.preludeGenerator.globalReference(key, false), valueNode)\n        ),\n    });\n  }\n\n  emitGlobalDelete(key: string, strictMode: boolean) {\n    this._addEntry({\n      args: [],\n      buildNode: ([]) =>\n        t.expressionStatement(t.unaryExpression(\"delete\", this.preludeGenerator.globalReference(key, !strictMode))),\n    });\n  }\n\n  emitBindingAssignment(binding: Binding, value: Value) {\n    this._addEntry({\n      args: [value],\n      buildNode: ([valueNode], context) =>\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            (context.serializeBinding(binding): BabelNodeIdentifier | BabelNodeMemberExpression),\n            valueNode\n          )\n        ),\n    });\n  }\n\n  emitPropertyAssignment(object: ObjectValue, key: string, value: Value) {\n    if (object.refuseSerialization) return;\n    let propName = this.getAsPropertyNameExpression(key);\n    this._addEntry({\n      args: [object, value],\n      buildNode: ([objectNode, valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", t.memberExpression(objectNode, propName, !t.isIdentifier(propName)), valueNode)\n        ),\n    });\n  }\n\n  emitDefineProperty(object: ObjectValue, key: string, desc: Descriptor, isDescChanged: boolean = true) {\n    if (object.refuseSerialization) return;\n    if (desc.enumerable && desc.configurable && desc.writable && desc.value && !isDescChanged) {\n      let descValue = desc.value;\n      invariant(descValue instanceof Value);\n      this.emitPropertyAssignment(object, key, descValue);\n    } else {\n      desc = Object.assign({}, desc);\n      let descValue = desc.value || object.$Realm.intrinsics.undefined;\n      invariant(descValue instanceof Value);\n      this._addEntry({\n        args: [\n          object,\n          descValue,\n          desc.get || object.$Realm.intrinsics.undefined,\n          desc.set || object.$Realm.intrinsics.undefined,\n        ],\n        buildNode: (_, context: SerializationContext) => context.emitDefinePropertyBody(object, key, desc),\n      });\n    }\n  }\n\n  emitPropertyDelete(object: ObjectValue, key: string) {\n    if (object.refuseSerialization) return;\n    let propName = this.getAsPropertyNameExpression(key);\n    this._addEntry({\n      args: [object],\n      buildNode: ([objectNode]) =>\n        t.expressionStatement(\n          t.unaryExpression(\"delete\", t.memberExpression(objectNode, propName, !t.isIdentifier(propName)))\n        ),\n    });\n  }\n\n  emitCall(createCallee: () => BabelNodeExpression, args: Array<Value>) {\n    this._addEntry({\n      args,\n      buildNode: values => t.expressionStatement(t.callExpression(createCallee(), [...values])),\n    });\n  }\n\n  emitConsoleLog(method: \"log\" | \"warn\" | \"error\", args: Array<string | ConcreteValue>) {\n    this.emitCall(\n      () => t.memberExpression(t.identifier(\"console\"), t.identifier(method)),\n      args.map(v => (typeof v === \"string\" ? new StringValue(this.realm, v) : v))\n    );\n  }\n\n  // test must be a temporal value, which means that it must have a defined intrinsicName\n  emitDoWhileStatement(test: AbstractValue, body: Generator) {\n    this._addEntry({\n      args: [],\n      buildNode: function([], context: SerializationContext) {\n        let testId = test.intrinsicName;\n        invariant(testId !== undefined);\n        let statements = context.serializeGenerator(body);\n        let block = t.blockStatement(statements);\n        return t.doWhileStatement(t.identifier(testId), block);\n      },\n      dependencies: [body],\n    });\n  }\n\n  // Checks the full set of possible concrete values as well as typeof\n  // for any AbstractValues\n  // e.g: (obj.property !== undefined && typeof obj.property !== \"object\")\n  // NB: if the type of the AbstractValue is top, skips the invariant\n  emitFullInvariant(object: ObjectValue | AbstractObjectValue, key: string, value: Value) {\n    let propertyIdentifier = this.getAsPropertyNameExpression(key);\n    let computed = !t.isIdentifier(propertyIdentifier);\n    let accessedPropertyOf = objectNode => t.memberExpression(objectNode, propertyIdentifier, computed);\n    let condition;\n    if (value instanceof AbstractValue) {\n      let isTop = false;\n      let concreteComparisons = [];\n      let typeComparisons = new Set();\n\n      function populateComparisonsLists(absValue: AbstractValue) {\n        if (absValue.kind === \"abstractConcreteUnion\") {\n          // recurse\n          for (let nestedValue of absValue.args)\n            if (nestedValue instanceof ConcreteValue) {\n              concreteComparisons.push(nestedValue);\n            } else {\n              invariant(nestedValue instanceof AbstractValue);\n              populateComparisonsLists(nestedValue);\n            }\n        } else if (absValue.getType().isTop || absValue.getType() === Value) {\n          isTop = true;\n        } else {\n          typeComparisons.add(absValue.getType());\n        }\n      }\n      populateComparisonsLists(value);\n\n      // No point in doing the invariant if we don't know the type\n      // of one of the nested abstract values\n      if (isTop) {\n        return;\n      } else {\n        condition = ([valueNode]) => {\n          // Create `object.property !== concreteValue`\n          let checks = concreteComparisons.map(concreteValue =>\n            t.binaryExpression(\"!==\", valueNode, t.valueToNode(concreteValue.serialize()))\n          );\n          // Create `typeof object.property !== typeValue`\n          checks = checks.concat(\n            [...typeComparisons].map(typeValue => {\n              let typeString = Utils.typeToString(typeValue);\n              invariant(typeString !== undefined, typeValue);\n              return t.binaryExpression(\n                \"!==\",\n                t.unaryExpression(\"typeof\", valueNode, true),\n                t.stringLiteral(typeString)\n              );\n            })\n          );\n          return checks.reduce((expr, newCondition) => t.logicalExpression(\"&&\", expr, newCondition));\n        };\n        this.emitInvariant([value, value], condition, valueNode => valueNode);\n      }\n    } else {\n      condition = ([objectNode, valueNode]) => t.binaryExpression(\"!==\", accessedPropertyOf(objectNode), valueNode);\n      this.emitInvariant([object, value, object], condition, objnode => accessedPropertyOf(objnode));\n    }\n  }\n\n  emitInvariant(\n    args: Array<Value>,\n    violationConditionFn: (Array<BabelNodeExpression>) => BabelNodeExpression,\n    appendLastToInvariantFn?: BabelNodeExpression => BabelNodeExpression\n  ): void {\n    if (this.realm.omitInvariants) return;\n    this._addEntry({\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>) => {\n        let throwString = t.stringLiteral(\"Prepack model invariant violation\");\n        if (appendLastToInvariantFn) {\n          let last = nodes.pop();\n          throwString = t.binaryExpression(\n            \"+\",\n            t.stringLiteral(\"Prepack model invariant violation: \"),\n            appendLastToInvariantFn(last)\n          );\n        }\n        let condition = violationConditionFn(nodes);\n        let throwblock = t.blockStatement([t.throwStatement(t.newExpression(t.identifier(\"Error\"), [throwString]))]);\n        return t.ifStatement(condition, throwblock);\n      },\n    });\n  }\n\n  emitCallAndCaptureResult(\n    types: TypesDomain,\n    values: ValuesDomain,\n    createCallee: () => BabelNodeExpression,\n    args: Array<Value>,\n    kind?: string\n  ): AbstractValue {\n    return this.derive(types, values, args, (nodes: any) => t.callExpression(createCallee(), nodes));\n  }\n\n  emitStatement(args: Array<Value>, buildNode_: (Array<BabelNodeExpression>) => BabelNodeStatement) {\n    this._addEntry({\n      args,\n      buildNode: buildNode_,\n    });\n  }\n\n  emitVoidExpression(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode_: AbstractValueBuildNodeFunction | BabelNodeExpression\n  ): UndefinedValue {\n    this._addEntry({\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>) =>\n        t.expressionStatement(\n          (buildNode_: any) instanceof Function\n            ? ((buildNode_: any): AbstractValueBuildNodeFunction)(nodes)\n            : ((buildNode_: any): BabelNodeExpression)\n        ),\n    });\n    return this.realm.intrinsics.undefined;\n  }\n\n  emitForInStatement(\n    o: ObjectValue | AbstractObjectValue,\n    lh: BabelNodeVariableDeclaration,\n    sourceObject: ObjectValue,\n    targetObject: ObjectValue,\n    boundName: BabelNodeIdentifier\n  ) {\n    this._addEntry({\n      // duplicate args to ensure refcount > 1\n      args: [o, targetObject, sourceObject, targetObject, sourceObject],\n      buildNode: ([obj, tgt, src, obj1, tgt1, src1]) => {\n        return t.forInStatement(\n          lh,\n          obj,\n          t.blockStatement([\n            t.expressionStatement(\n              t.assignmentExpression(\n                \"=\",\n                t.memberExpression(tgt, boundName, true),\n                t.memberExpression(src, boundName, true)\n              )\n            ),\n          ])\n        );\n      },\n    });\n  }\n\n  derive(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode_: DerivedExpressionBuildNodeFunction | BabelNodeExpression,\n    optionalArgs?: {| kind?: string, isPure?: boolean, skipInvariant?: boolean |}\n  ): AbstractValue {\n    invariant(buildNode_ instanceof Function || args.length === 0);\n    let id = t.identifier(this.preludeGenerator.nameGenerator.generate(\"derived\"));\n    this.preludeGenerator.derivedIds.set(id.name, args);\n    let options = {};\n    if (optionalArgs && optionalArgs.kind) options.kind = optionalArgs.kind;\n    let Constructor = Value.isTypeCompatibleWith(types.getType(), ObjectValue) ? AbstractObjectValue : AbstractValue;\n    let res = new Constructor(this.realm, types, values, hashString(id.name), [], id, options);\n    this._addEntry({\n      isPure: optionalArgs ? optionalArgs.isPure : undefined,\n      declared: res,\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>, context: SerializationContext) => {\n        return t.variableDeclaration(\"var\", [\n          t.variableDeclarator(\n            id,\n            (buildNode_: any) instanceof Function\n              ? ((buildNode_: any): DerivedExpressionBuildNodeFunction)(nodes, context)\n              : ((buildNode_: any): BabelNodeExpression)\n          ),\n        ]);\n      },\n    });\n    let type = types.getType();\n    res.intrinsicName = id.name;\n    if (optionalArgs && optionalArgs.skipInvariant) return res;\n    let typeofString;\n    if (type instanceof FunctionValue) typeofString = \"function\";\n    else if (type === UndefinedValue) invariant(false);\n    else if (type === NullValue) invariant(false);\n    else if (type === StringValue) typeofString = \"string\";\n    else if (type === BooleanValue) typeofString = \"boolean\";\n    else if (type === NumberValue) typeofString = \"number\";\n    else if (type === IntegralValue) typeofString = \"number\";\n    else if (type === SymbolValue) typeofString = \"symbol\";\n    else if (type === ObjectValue) typeofString = \"object\";\n    if (typeofString !== undefined) {\n      // Verify that the types are as expected, a failure of this invariant\n      // should mean the model is wrong.\n      this.emitInvariant(\n        [res, res],\n        nodes => {\n          invariant(typeofString !== undefined);\n          let condition = t.binaryExpression(\n            \"!==\",\n            t.unaryExpression(\"typeof\", nodes[0]),\n            t.stringLiteral(typeofString)\n          );\n          if (typeofString === \"object\") {\n            condition = t.logicalExpression(\n              \"&&\",\n              condition,\n              t.binaryExpression(\"!==\", t.unaryExpression(\"typeof\", nodes[0]), t.stringLiteral(\"function\"))\n            );\n            condition = t.logicalExpression(\"||\", condition, t.binaryExpression(\"===\", nodes[0], nullExpression));\n          }\n          return condition;\n        },\n        node => node\n      );\n    }\n\n    return res;\n  }\n\n  serialize(context: SerializationContext) {\n    for (let entry of this._entries) {\n      if (!entry.isPure || !entry.declared || !context.canOmit(entry.declared)) {\n        let nodes = entry.args.map((boundArg, i) => context.serializeValue(boundArg));\n        if (entry.buildNode) {\n          let node = entry.buildNode(nodes, context);\n          if (node.type === \"BlockStatement\") {\n            let block: BabelNodeBlockStatement = (node: any);\n            let statements = block.body;\n            if (statements.length === 0) continue;\n            if (statements.length === 1) {\n              node = statements[0];\n            }\n          }\n          context.emit(node);\n        }\n        if (entry.declared !== undefined) context.declare(entry.declared);\n      }\n    }\n  }\n\n  visitEntry(entry: GeneratorEntry, callbacks: VisitEntryCallbacks) {\n    if (entry.isPure && entry.declared && callbacks.canSkip(entry.declared)) {\n      callbacks.recordDelayedEntry(this, entry);\n    } else {\n      if (entry.declared) callbacks.recordDeclaration(entry.declared);\n      callbacks.visitValues(entry.args);\n      if (entry.dependencies) for (let dependency of entry.dependencies) callbacks.visitGenerator(dependency, this);\n    }\n  }\n\n  visit(callbacks: VisitEntryCallbacks) {\n    for (let entry of this._entries) this.visitEntry(entry, callbacks);\n  }\n\n  _addEntry(entry: GeneratorEntry) {\n    this._entries.push(entry);\n  }\n\n  appendGenerator(other: Generator, leadingComment: string): void {\n    if (other.empty()) return;\n    this._addEntry({\n      args: [],\n      buildNode: function(args, context: SerializationContext) {\n        let statements = context.serializeGenerator(other);\n        if (statements.length === 1) {\n          let statement = statements[0];\n          if (leadingComment.length > 0)\n            statement.leadingComments = [({ type: \"BlockComment\", value: leadingComment }: any)];\n          return statement;\n        }\n        let block = t.blockStatement(statements);\n        if (leadingComment.length > 0) block.leadingComments = [({ type: \"BlockComment\", value: leadingComment }: any)];\n        return block;\n      },\n      dependencies: [other],\n    });\n  }\n\n  composeGenerators(generator1: Generator, generator2: Generator): void {\n    this._addEntry({\n      args: [],\n      buildNode: function([], context) {\n        let statements1 = generator1.empty() ? [] : context.serializeGenerator(generator1);\n        let statements2 = generator2.empty() ? [] : context.serializeGenerator(generator2);\n        let statements = statements1.concat(statements2);\n        if (statements.length === 1) return statements[0];\n        return t.blockStatement(statements);\n      },\n      dependencies: [generator1, generator2],\n    });\n  }\n\n  joinGenerators(joinCondition: AbstractValue, generator1: Generator, generator2: Generator): void {\n    this._addEntry({\n      args: [joinCondition],\n      buildNode: function([cond], context) {\n        let block1 = generator1.empty() ? null : serializeBody(generator1, context);\n        let block2 = generator2.empty() ? null : serializeBody(generator2, context);\n        if (block1) return t.ifStatement(cond, block1, block2);\n        invariant(block2);\n        return t.ifStatement(t.unaryExpression(\"!\", cond), block2);\n      },\n      dependencies: [generator1, generator2],\n    });\n  }\n}\n\n// some characters are invalid within a JavaScript identifier,\n// such as: . , : ( ) ' \" ` [ ] -\n// so we replace these character instances with an underscore\nfunction replaceInvalidCharactersWithUnderscore(string: string) {\n  return string.replace(/[.,:\\(\\)\\\"\\'\\`\\[\\]\\-]/g, \"_\");\n}\n\nconst base62characters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\nfunction base62encode(n: number): string {\n  invariant((n | 0) === n && n >= 0);\n  if (n === 0) return \"0\";\n  let s = \"\";\n  while (n > 0) {\n    let f = n % base62characters.length;\n    s = base62characters[f] + s;\n    n = (n - f) / base62characters.length;\n  }\n  return s;\n}\n\nexport class NameGenerator {\n  constructor(forbiddenNames: Set<string>, debugNames: boolean, uniqueSuffix: string, prefix: string) {\n    this.prefix = prefix;\n    this.uidCounter = 0;\n    this.debugNames = debugNames;\n    this.forbiddenNames = forbiddenNames;\n    this.uniqueSuffix = uniqueSuffix;\n  }\n  prefix: string;\n  uidCounter: number;\n  debugNames: boolean;\n  forbiddenNames: Set<string>;\n  uniqueSuffix: string;\n  generate(debugSuffix: ?string): string {\n    let id;\n    do {\n      id = this.prefix + base62encode(this.uidCounter++);\n      if (this.uniqueSuffix.length > 0) id += this.uniqueSuffix;\n      if (this.debugNames) {\n        if (debugSuffix) id += \"_\" + replaceInvalidCharactersWithUnderscore(debugSuffix);\n        else id += \"_\";\n      }\n    } while (this.forbiddenNames.has(id));\n    return id;\n  }\n}\n\nexport class PreludeGenerator {\n  constructor(debugNames: ?boolean, uniqueSuffix: ?string) {\n    this.prelude = [];\n    this.derivedIds = new Map();\n    this.memoizedRefs = new Map();\n    this.nameGenerator = new NameGenerator(new Set(), !!debugNames, uniqueSuffix || \"\", \"_$\");\n    this.usesThis = false;\n    this.declaredGlobals = new Set();\n  }\n\n  prelude: Array<BabelNodeStatement>;\n  derivedIds: Map<string, Array<Value>>;\n  memoizedRefs: Map<string, BabelNodeIdentifier>;\n  nameGenerator: NameGenerator;\n  usesThis: boolean;\n  declaredGlobals: Set<string>;\n\n  createNameGenerator(prefix: string): NameGenerator {\n    return new NameGenerator(\n      this.nameGenerator.forbiddenNames,\n      this.nameGenerator.debugNames,\n      this.nameGenerator.uniqueSuffix,\n      prefix\n    );\n  }\n\n  convertStringToMember(str: string): BabelNodeIdentifier | BabelNodeThisExpression | BabelNodeMemberExpression {\n    return str\n      .split(\".\")\n      .map(name => {\n        if (name === \"global\") {\n          return this.memoizeReference(name);\n        } else if (name === \"this\") {\n          return t.thisExpression();\n        } else {\n          return t.identifier(name);\n        }\n      })\n      .reduce((obj, prop) => t.memberExpression(obj, prop));\n  }\n\n  globalReference(key: string, globalScope: boolean = false) {\n    if (globalScope && t.isValidIdentifier(key)) return t.identifier(key);\n    let keyNode = t.isValidIdentifier(key) ? t.identifier(key) : t.stringLiteral(key);\n    return t.memberExpression(this.memoizeReference(\"global\"), keyNode, !t.isIdentifier(keyNode));\n  }\n\n  memoizeReference(key: string): BabelNodeIdentifier {\n    let ref = this.memoizedRefs.get(key);\n    if (ref) return ref;\n\n    let init;\n    if (key.includes(\"(\") || key.includes(\"[\")) {\n      // Horrible but effective hack:\n      // Some internal object have intrinsic names such as\n      //    ([][Symbol.iterator]().__proto__.__proto__)\n      // and\n      //    RegExp.prototype[Symbol.match]\n      // which get turned into a babel node here.\n      // TODO: We should properly parse such a string, and memoize all references in it separately.\n      // Instead, we just turn it into a funky identifier, which Babel seems to accept.\n      init = t.identifier(key);\n    } else if (key === \"global\") {\n      this.usesThis = true;\n      init = t.thisExpression();\n    } else {\n      let i = key.lastIndexOf(\".\");\n      if (i === -1) {\n        init = t.memberExpression(this.memoizeReference(\"global\"), t.identifier(key));\n      } else {\n        init = t.memberExpression(this.memoizeReference(key.substr(0, i)), t.identifier(key.substr(i + 1)));\n      }\n    }\n    ref = t.identifier(this.nameGenerator.generate(key));\n    this.prelude.push(t.variableDeclaration(\"var\", [t.variableDeclarator(ref, init)]));\n    this.memoizedRefs.set(key, ref);\n    return ref;\n  }\n}\n"]}