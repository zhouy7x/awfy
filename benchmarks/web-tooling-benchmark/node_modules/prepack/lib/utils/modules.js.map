{"version":3,"sources":["../../src/utils/modules.js"],"names":["t","downgradeErrorsToWarnings","realm","f","savedHandler","errorHandler","handler","e","severity","handleError","ModuleTracer","constructor","modules","statistics","logModules","evaluateForEffectsNesting","requireStack","requireSequence","uninitializedModuleIdsRequiredInEvaluateForEffects","Set","log","message","console","map","_","join","beginEvaluateForEffects","state","push","undefined","endEvaluateForEffects","effects","popped","pop","_callRequireAndRecord","moduleIdValue","performCall","length","moduleIds","has","value","completion","incorporateSavedCompletion","stopEffectCapture","warning","location","recordModuleInitialized","_callRequireAndAccelerate","isTopLevelRequire","acceleratedModuleIds","evaluateForEffects","nestedModuleId","nestedEffects","tryInitializeModule","accelerateUnsupportedRequires","isModuleInitialized","clear","acceleratedModules","_callRequireAndDelayIfNeeded","diagnostic","currentLocation","add","result","requireSequenceStart","previousNumDelayedModules","delayedModules","nestedModulesIds","i","createTemporalFromBuildFunction","callExpression","identifier","valueToNode","applyEffects","_tryExtractDependencies","lengthValue","dependencies","logger","elementValue","tryQuery","intrinsics","detourCall","F","thisArgument","argumentsList","newTarget","getRequire","disallowDelayingRequiresOverride","moduleId","delayUnsupportedRequires","logError","getDefine","factoryFunction","factoryFunctionDependencies","set","Modules","_require","_define","Map","initializedModules","tracers","moduleTracer","resolveInitializedModules","globalInitializedModulesMap","_getGlobalProperty","properties","keys","property","get","moduleValue","descriptor","name","active","$GlobalObject","getGetModuleIdIfNodeIsRequireFunction","formalParameters","functions","scope","node","isIdentifier","callee","arguments","argument","isNumericLiteral","isStringLiteral","isMemberExpression","innerName","updateModuleId","newModuleId","getModuleId","memberExpression","object","scopedBinding","getBinding","path","dependencyIndex","Number","isInteger","dependency","kind","doesNotMatter","reference","ResolveBinding","$Environment","IsUnresolvableReference","referencedBase","base","referencedName","binding","bindings","initialized","assignToGlobal","previousDisallowDelayingRequiresOverride","evaluateNodeForEffectsInGlobalEnv","err","initializeMoreModules","count","oldReadOnly","setReadOnly","oldDisallowDelayingRequiresOverride","compl","generator","createdObjects","empty","escapes"],"mappings":"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","file":"modules.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { GlobalEnvironmentRecord, DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { Realm, Tracer } from \"../realm.js\";\nimport type { Effects } from \"../realm.js\";\nimport { Get } from \"../methods/index.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { Environment, Functions } from \"../singletons.js\";\nimport {\n  AbstractValue,\n  Value,\n  FunctionValue,\n  ObjectValue,\n  NumberValue,\n  StringValue,\n  ArrayValue,\n  UndefinedValue,\n  NullValue,\n} from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeIdentifier,\n  BabelNodeLVal,\n  BabelNodeCallExpression,\n  BabelNodeNumericLiteral,\n  BabelNodeStringLiteral,\n  BabelNodeMemberExpression,\n} from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Logger } from \"./logger.js\";\nimport { SerializerStatistics } from \"../serializer/types.js\";\n\nfunction downgradeErrorsToWarnings(realm: Realm, f: () => any) {\n  let savedHandler = realm.errorHandler;\n  function handler(e) {\n    e.severity = \"Warning\";\n    realm.errorHandler = savedHandler;\n    try {\n      return realm.handleError(e);\n    } finally {\n      realm.errorHandler = handler;\n    }\n  }\n  realm.errorHandler = handler;\n  try {\n    return f();\n  } finally {\n    realm.errorHandler = savedHandler;\n  }\n}\n\nexport class ModuleTracer extends Tracer {\n  constructor(modules: Modules, statistics: SerializerStatistics, logModules: boolean) {\n    super();\n    this.modules = modules;\n    this.evaluateForEffectsNesting = 0;\n    this.requireStack = [];\n    this.requireSequence = [];\n    this.logModules = logModules;\n    this.uninitializedModuleIdsRequiredInEvaluateForEffects = new Set();\n    this.statistics = statistics;\n  }\n\n  modules: Modules;\n  evaluateForEffectsNesting: number;\n  requireStack: Array<number | string | void>;\n  requireSequence: Array<number | string>;\n  uninitializedModuleIdsRequiredInEvaluateForEffects: Set<number | string>;\n  // We can't say that a module has been initialized if it was initialized in a\n  // evaluate for effects context until we know the effects are applied.\n  logModules: boolean;\n  statistics: SerializerStatistics;\n\n  log(message: string) {\n    if (this.logModules) console.log(`[modules] ${this.requireStack.map(_ => \"  \").join(\"\")}${message}`);\n  }\n\n  beginEvaluateForEffects(state: any) {\n    if (state !== this) {\n      this.log(\">evaluate for effects\");\n      this.evaluateForEffectsNesting++;\n      this.requireStack.push(undefined);\n    }\n  }\n\n  endEvaluateForEffects(state: any, effects: void | Effects) {\n    if (state !== this) {\n      let popped = this.requireStack.pop();\n      invariant(popped === undefined);\n      this.evaluateForEffectsNesting--;\n      this.log(\"<evaluate for effects\");\n    }\n  }\n\n  // If we don't delay unsupported requires, we simply want to record here\n  // when a module gets initialized, and then we return.\n  _callRequireAndRecord(moduleIdValue: number | string, performCall: () => Value) {\n    let realm = this.modules.realm;\n    if (\n      (this.requireStack.length === 0 || this.requireStack[this.requireStack.length - 1] !== moduleIdValue) &&\n      this.modules.moduleIds.has(moduleIdValue)\n    ) {\n      this.requireStack.push(moduleIdValue);\n      try {\n        let value = performCall();\n        // Make this into a join point by suppressing the conditional exception.\n        // TODO: delete this code and let the caller deal with the conditional exception.\n        let completion = Functions.incorporateSavedCompletion(realm, value);\n        if (completion instanceof PossiblyNormalCompletion) {\n          realm.stopEffectCapture(completion);\n          let warning = new CompilerDiagnostic(\n            \"Module import may fail with an exception\",\n            completion.location,\n            \"PP0018\",\n            \"Warning\"\n          );\n          realm.handleError(warning);\n        } else {\n          this.modules.recordModuleInitialized(moduleIdValue, value);\n        }\n        return value;\n      } finally {\n        invariant(this.requireStack.pop() === moduleIdValue);\n      }\n    }\n    return undefined;\n  }\n\n  _callRequireAndAccelerate(\n    isTopLevelRequire: boolean,\n    moduleIdValue: number | string,\n    performCall: () => Value\n  ): void | Effects {\n    let realm = this.modules.realm;\n    let acceleratedModuleIds, effects;\n    do {\n      try {\n        effects = realm.evaluateForEffects(() => performCall(), this);\n      } catch (e) {\n        e;\n      }\n\n      acceleratedModuleIds = [];\n      if (isTopLevelRequire && effects !== undefined && !(effects[0] instanceof AbruptCompletion)) {\n        // We gathered all effects, but didn't apply them yet.\n        // Let's check if there was any call to `require` in a\n        // evaluate-for-effects context. If so, try to initialize\n        // that module right now. Acceleration module initialization in this\n        // way might not actually be desirable, but it works around\n        // general prepack-limitations around joined abstract values involving\n        // conditionals. Long term, Prepack needs to implement a notion of refinement\n        // of conditional abstract values under the known path condition.\n        // Example:\n        //   if (*) require(1); else require(2);\n        //   let x = require(1).X;\n        // =>\n        //   require(1);\n        //   require(2);\n        //   if (*) require(1); else require(2);\n        //   let x = require(1).X;\n\n        for (let nestedModuleId of this.uninitializedModuleIdsRequiredInEvaluateForEffects) {\n          let nestedEffects = this.modules.tryInitializeModule(\n            nestedModuleId,\n            `accelerated initialization of conditional module ${nestedModuleId} as it's required in an evaluate-for-effects context by module ${moduleIdValue}`\n          );\n          if (\n            this.modules.accelerateUnsupportedRequires &&\n            nestedEffects !== undefined &&\n            nestedEffects[0] instanceof Value &&\n            this.modules.isModuleInitialized(nestedModuleId)\n          ) {\n            acceleratedModuleIds.push(nestedModuleId);\n          }\n        }\n        this.uninitializedModuleIdsRequiredInEvaluateForEffects.clear();\n        // Keep restarting for as long as we find additional modules to accelerate.\n        if (acceleratedModuleIds.length > 0) {\n          console.log(\n            `restarting require(${moduleIdValue}) after accelerating conditional require calls for ${acceleratedModuleIds.join()}`\n          );\n          this.statistics.acceleratedModules += acceleratedModuleIds.length;\n        }\n      }\n    } while (acceleratedModuleIds.length > 0);\n\n    return effects;\n  }\n\n  // If a require fails, recover from it and delay the factory call until runtime\n  // Also, only in this mode, consider \"accelerating\" require calls, see below.\n  _callRequireAndDelayIfNeeded(moduleIdValue: number | string, performCall: () => Value) {\n    let realm = this.modules.realm;\n    this.log(`>require(${moduleIdValue})`);\n    let isTopLevelRequire = this.requireStack.length === 0;\n    if (this.evaluateForEffectsNesting > 0) {\n      if (isTopLevelRequire) {\n        let diagnostic = new CompilerDiagnostic(\n          \"Non-deterministically conditional top-level require not currently supported\",\n          realm.currentLocation,\n          \"PP0017\",\n          \"FatalError\"\n        );\n        realm.handleError(diagnostic);\n        throw new FatalError();\n      } else if (!this.modules.isModuleInitialized(moduleIdValue))\n        // Nested require call: We record that this happened. Just so that\n        // if we discover later this this require call needs to get delayed,\n        // then we still know (some of) which modules it in turn required,\n        // and then we'll later \"accelerate\" requiring them to preserve the\n        // require ordering. See below for more details on acceleration.\n        this.uninitializedModuleIdsRequiredInEvaluateForEffects.add(moduleIdValue);\n\n      return undefined;\n    } else {\n      return downgradeErrorsToWarnings(realm, () => {\n        let result;\n        try {\n          this.requireStack.push(moduleIdValue);\n          let requireSequenceStart = this.requireSequence.length;\n          this.requireSequence.push(moduleIdValue);\n          const previousNumDelayedModules = this.statistics.delayedModules;\n          let effects = this._callRequireAndAccelerate(isTopLevelRequire, moduleIdValue, performCall);\n          if (effects === undefined || effects[0] instanceof AbruptCompletion) {\n            console.log(`delaying require(${moduleIdValue})`);\n            this.statistics.delayedModules = previousNumDelayedModules + 1;\n            // So we are about to emit a delayed require(...) call.\n            // However, before we do that, let's try to require all modules that we\n            // know this delayed require call will require.\n            // This way, we ensure that those modules will be fully initialized\n            // before the require call executes.\n            // TODO #690: More needs to be done to make the delayUnsupportedRequires\n            // feature completely safe. Open issues are:\n            // 1) Side-effects on the heap of delayed factory functions are not discovered or rejected.\n            // 2) While we do process an appropriate list of transitively required modules here,\n            //    it's likely just a subset / prefix of all transivitely required modules, as\n            //    more modules would have been required if the Introspection exception had not been thrown.\n            //    To be correct, those modules would have to be prepacked here as well.\n            //    TODO #798: Watch out for an upcoming change to the __d module declaration where the statically known\n            //    list of dependencies will be announced, so we'll no longer have to guess.\n            let nestedModulesIds = new Set();\n            for (let i = requireSequenceStart; i < this.requireSequence.length; i++) {\n              let nestedModuleId = this.requireSequence[i];\n              if (nestedModulesIds.has(nestedModuleId)) continue;\n              nestedModulesIds.add(nestedModuleId);\n              this.modules.tryInitializeModule(\n                nestedModuleId,\n                `initialization of module ${nestedModuleId} as it's required by module ${moduleIdValue}`\n              );\n            }\n\n            result = AbstractValue.createTemporalFromBuildFunction(realm, Value, [], ([]) =>\n              t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleIdValue)])\n            );\n          } else {\n            result = effects[0];\n            if (result instanceof Value) {\n              realm.applyEffects(effects, `initialization of module ${moduleIdValue}`);\n              this.modules.recordModuleInitialized(moduleIdValue, result);\n            } else if (result instanceof PossiblyNormalCompletion) {\n              let warning = new CompilerDiagnostic(\n                \"Module import may fail with an exception\",\n                result.location,\n                \"PP0018\",\n                \"Warning\"\n              );\n              realm.handleError(warning);\n              result = result.value;\n              realm.applyEffects(effects, `initialization of module ${moduleIdValue}`);\n            } else {\n              invariant(false);\n            }\n          }\n        } finally {\n          let popped = this.requireStack.pop();\n          invariant(popped === moduleIdValue);\n          this.log(`<require(${moduleIdValue})`);\n        }\n        invariant(result instanceof Value);\n        return result;\n      });\n    }\n  }\n\n  _tryExtractDependencies(value: void | Value): void | Array<Value> {\n    if (value === undefined || value instanceof NullValue || value instanceof UndefinedValue) return [];\n    if (value instanceof ArrayValue) {\n      const realm = this.modules.realm;\n      const lengthValue = Get(realm, value, \"length\");\n      if (lengthValue instanceof NumberValue) {\n        const dependencies = [];\n        const logger = this.modules.logger;\n        for (let i = 0; i < lengthValue.value; i++) {\n          const elementValue = logger.tryQuery(\n            () => Get(realm, ((value: any): ArrayValue), \"\" + i),\n            realm.intrinsics.undefined\n          );\n          dependencies.push(elementValue);\n        }\n        return dependencies;\n      }\n    }\n    return undefined;\n  }\n\n  detourCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    performCall: () => Value\n  ): void | Value {\n    if (\n      F === this.modules.getRequire() &&\n      !this.modules.disallowDelayingRequiresOverride &&\n      argumentsList.length === 1\n    ) {\n      // Here, we handle calls of the form\n      //   require(42)\n\n      let moduleId = argumentsList[0];\n      let moduleIdValue;\n      // Do some sanity checks and request require(...) calls with bad arguments\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue) {\n        moduleIdValue = moduleId.value;\n        if (!this.modules.moduleIds.has(moduleIdValue) && this.modules.delayUnsupportedRequires) {\n          this.modules.logger.logError(moduleId, \"Module referenced by require call has not been defined.\");\n        }\n      } else {\n        if (this.modules.delayUnsupportedRequires) {\n          this.modules.logger.logError(moduleId, \"First argument to require function is not a number or string value.\");\n        }\n        return undefined;\n      }\n\n      if (this.modules.delayUnsupportedRequires) return this._callRequireAndDelayIfNeeded(moduleIdValue, performCall);\n      else return this._callRequireAndRecord(moduleIdValue, performCall);\n    } else if (F === this.modules.getDefine()) {\n      // Here, we handle calls of the form\n      //   __d(factoryFunction, moduleId, dependencyArray)\n\n      if (this.evaluateForEffectsNesting !== 0)\n        this.modules.logger.logError(F, \"Defining a module in nested partial evaluation is not supported.\");\n      let factoryFunction = argumentsList[0];\n      if (factoryFunction instanceof FunctionValue) {\n        let dependencies = this._tryExtractDependencies(argumentsList[2]);\n        if (dependencies !== undefined) this.modules.factoryFunctionDependencies.set(factoryFunction, dependencies);\n        else\n          this.modules.logger.logError(\n            argumentsList[2],\n            \"Third argument to define function is present but not a concrete array.\"\n          );\n      } else\n        this.modules.logger.logError(factoryFunction, \"First argument to define function is not a function value.\");\n      let moduleId = argumentsList[1];\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue)\n        this.modules.moduleIds.add(moduleId.value);\n      else\n        this.modules.logger.logError(moduleId, \"Second argument to define function is not a number or string value.\");\n    }\n    return undefined;\n  }\n}\n\nexport class Modules {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    statistics: SerializerStatistics,\n    logModules: boolean,\n    delayUnsupportedRequires: boolean,\n    accelerateUnsupportedRequires: boolean\n  ) {\n    this.realm = realm;\n    this.logger = logger;\n    this._require = realm.intrinsics.undefined;\n    this._define = realm.intrinsics.undefined;\n    this.factoryFunctionDependencies = new Map();\n    this.moduleIds = new Set();\n    this.initializedModules = new Map();\n    realm.tracers.push((this.moduleTracer = new ModuleTracer(this, statistics, logModules)));\n    this.delayUnsupportedRequires = delayUnsupportedRequires;\n    this.accelerateUnsupportedRequires = accelerateUnsupportedRequires;\n    this.disallowDelayingRequiresOverride = false;\n  }\n\n  realm: Realm;\n  logger: Logger;\n  _require: Value;\n  _define: Value;\n  factoryFunctionDependencies: Map<FunctionValue, Array<Value>>;\n  moduleIds: Set<number | string>;\n  initializedModules: Map<number | string, Value>;\n  active: boolean;\n  delayUnsupportedRequires: boolean;\n  accelerateUnsupportedRequires: boolean;\n  disallowDelayingRequiresOverride: boolean;\n  moduleTracer: ModuleTracer;\n\n  resolveInitializedModules(): void {\n    this.initializedModules.clear();\n    let globalInitializedModulesMap = this._getGlobalProperty(\"__initializedModules\");\n    invariant(globalInitializedModulesMap instanceof ObjectValue);\n    for (let moduleId of globalInitializedModulesMap.properties.keys()) {\n      let property = globalInitializedModulesMap.properties.get(moduleId);\n      invariant(property);\n      let moduleValue = property.descriptor && property.descriptor.value;\n      if (moduleValue instanceof Value) this.initializedModules.set(moduleId, moduleValue);\n    }\n  }\n\n  _getGlobalProperty(name: string): Value {\n    if (this.active) return this.realm.intrinsics.undefined;\n    this.active = true;\n    try {\n      let realm = this.realm;\n      return this.logger.tryQuery(() => Get(realm, realm.$GlobalObject, name), realm.intrinsics.undefined);\n    } finally {\n      this.active = false;\n    }\n  }\n\n  getRequire(): Value {\n    if (!(this._require instanceof FunctionValue)) this._require = this._getGlobalProperty(\"require\");\n    return this._require;\n  }\n\n  getDefine(): Value {\n    if (!(this._define instanceof FunctionValue)) this._define = this._getGlobalProperty(\"__d\");\n    return this._define;\n  }\n\n  // Returns a function that checks if a call node represents a call to a\n  // known require function, and if so, what module id that call indicates.\n  // A known require function call is either of the form\n  //   ... require(42) ...\n  // where require resolves to the global require function, or\n  //   factoryFunction(, require, , , dependencies) {\n  //     ...\n  //       ... require(dependencies[3]) ...\n  // where factoryFunction and dependencies were announced as part of the\n  // global code execution via a global module declaration call such as\n  //   global.__d(factoryFunction, , [0,2,4,6,8])\n  getGetModuleIdIfNodeIsRequireFunction(\n    formalParameters: Array<BabelNodeLVal>,\n    functions: Array<FunctionValue>\n  ): (scope: any, node: BabelNodeCallExpression) => void | number | string {\n    let realm = this.realm;\n    let logger = this.logger;\n    let modules = this;\n    return (scope: any, node: BabelNodeCallExpression) => {\n      // Are we calling a function that has a single name and a single argument?\n      if (!t.isIdentifier(node.callee) || node.arguments.length !== 1) return undefined;\n      let argument = node.arguments[0];\n      if (!argument) return undefined;\n\n      if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument) && !t.isMemberExpression(argument))\n        return undefined;\n\n      invariant(node.callee);\n      let innerName = ((node.callee: any): BabelNodeIdentifier).name;\n\n      let moduleId;\n\n      // Helper function used to give up if we ever come up with different module ids for different functions\n      let updateModuleId = newModuleId => {\n        if (moduleId !== undefined && moduleId !== newModuleId) return false;\n        moduleId = newModuleId;\n        return true;\n      };\n\n      // Helper function that retrieves module id from call argument, possibly chasing dependency array indirection\n      const getModuleId = (dependencies?: Array<Value>): void | number | string => {\n        if (t.isMemberExpression(argument)) {\n          if (dependencies !== undefined) {\n            let memberExpression = ((argument: any): BabelNodeMemberExpression);\n            if (t.isIdentifier(memberExpression.object)) {\n              let scopedBinding = scope.getBinding(((memberExpression.object: any): BabelNodeIdentifier).name);\n              if (scopedBinding && formalParameters[4] === scopedBinding.path.node) {\n                if (t.isNumericLiteral(memberExpression.property)) {\n                  let dependencyIndex = memberExpression.property.value;\n                  if (\n                    Number.isInteger(dependencyIndex) &&\n                    dependencyIndex >= 0 &&\n                    dependencyIndex < dependencies.length\n                  ) {\n                    let dependency = dependencies[dependencyIndex];\n                    if (dependency instanceof NumberValue || dependency instanceof StringValue) return dependency.value;\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          return ((argument: any): BabelNodeNumericLiteral | BabelNodeStringLiteral).value;\n        }\n      };\n\n      // Let's consider each of the function instances (closures for the same code)\n      for (let f of functions) {\n        // 1. Let's check if we have a match for a factory function like\n        //      factoryFunction(, require, , , [dependencies])\n        //    which is used with the Metro bundler\n        let scopedBinding = scope.getBinding(innerName);\n        if (scopedBinding) {\n          let dependencies = modules.factoryFunctionDependencies.get(f);\n          if (dependencies !== undefined && formalParameters[1] === scopedBinding.path.node) {\n            invariant(scopedBinding.kind === \"param\");\n            let newModuleId = getModuleId(dependencies);\n            if (newModuleId !== undefined && !updateModuleId(newModuleId)) return undefined;\n            continue;\n          }\n\n          // The name binds to some local entity, but nothing we'd know what exactly it is\n          return undefined;\n        }\n\n        // 2. Let's check if we can resolve the called function just by looking at the\n        //    function instance environment.\n        //    TODO: We should not do this if the current node is in a nested function!\n\n        // We won't have a dependency map here, so this only works for literal arguments.\n        if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument)) return undefined;\n\n        let doesNotMatter = true;\n        let reference = logger.tryQuery(\n          () => Environment.ResolveBinding(realm, innerName, doesNotMatter, f.$Environment),\n          undefined\n        );\n        if (reference === undefined) {\n          // We couldn't resolve as we came across some behavior that we cannot deal with abstractly\n          return undefined;\n        }\n        if (Environment.IsUnresolvableReference(realm, reference)) return undefined;\n        let referencedBase = reference.base;\n        let referencedName: string = (reference.referencedName: any);\n        if (typeof referencedName !== \"string\") return undefined;\n        let value;\n        if (reference.base instanceof GlobalEnvironmentRecord) {\n          value = logger.tryQuery(() => Get(realm, realm.$GlobalObject, innerName), realm.intrinsics.undefined);\n        } else {\n          invariant(referencedBase instanceof DeclarativeEnvironmentRecord);\n          let binding = referencedBase.bindings[referencedName];\n          if (!binding.initialized) return undefined;\n          value = binding.value;\n        }\n        if (value !== modules.getRequire()) return undefined;\n        const newModuleId = getModuleId();\n        invariant(newModuleId !== undefined);\n        if (!updateModuleId(newModuleId)) return undefined;\n      }\n\n      return moduleId;\n    };\n  }\n\n  recordModuleInitialized(moduleId: number | string, value: Value) {\n    this.realm.assignToGlobal(\n      t.memberExpression(\n        t.memberExpression(t.identifier(\"global\"), t.identifier(\"__initializedModules\")),\n        t.identifier(\"\" + moduleId)\n      ),\n      value\n    );\n  }\n\n  tryInitializeModule(moduleId: number | string, message: string): void | Effects {\n    let realm = this.realm;\n    let previousDisallowDelayingRequiresOverride = this.disallowDelayingRequiresOverride;\n    this.disallowDelayingRequiresOverride = true;\n    return downgradeErrorsToWarnings(realm, () => {\n      try {\n        let node = t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleId)]);\n\n        let effects = realm.evaluateNodeForEffectsInGlobalEnv(node);\n        realm.applyEffects(effects, message);\n        return effects;\n      } catch (err) {\n        if (err instanceof FatalError) return undefined;\n        else throw err;\n      } finally {\n        this.disallowDelayingRequiresOverride = previousDisallowDelayingRequiresOverride;\n      }\n    });\n  }\n\n  initializeMoreModules() {\n    // partially evaluate all factory methods by calling require\n    let count = 0;\n    for (let moduleId of this.moduleIds) {\n      if (this.initializedModules.has(moduleId)) continue;\n      let effects = this.tryInitializeModule(moduleId, `Speculative initialization of module ${moduleId}`);\n      if (effects === undefined) continue;\n      let result = effects[0];\n      if (!(result instanceof Value)) continue; // module might throw\n      count++;\n      this.initializedModules.set(moduleId, result);\n    }\n    if (count > 0) console.log(`=== speculatively initialized ${count} additional modules`);\n  }\n\n  isModuleInitialized(moduleId: number | string): void | Value {\n    let realm = this.realm;\n    let oldReadOnly = realm.setReadOnly(true);\n    let oldDisallowDelayingRequiresOverride = this.disallowDelayingRequiresOverride;\n    this.disallowDelayingRequiresOverride = true;\n    try {\n      let node = t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleId)]);\n\n      let [compl, generator, bindings, properties, createdObjects] = realm.evaluateNodeForEffectsInGlobalEnv(node);\n      // for lint unused\n      invariant(bindings);\n\n      if (compl instanceof AbruptCompletion) return undefined;\n      invariant(compl instanceof Value);\n\n      if (!generator.empty() || (compl instanceof ObjectValue && createdObjects.has(compl))) return undefined;\n      // Check for escaping property assignments, if none escape, we got an existing object\n      let escapes = false;\n      for (let [binding] of properties) {\n        let object = binding.object;\n        invariant(object instanceof ObjectValue);\n        if (!createdObjects.has(object)) escapes = true;\n      }\n      if (escapes) return undefined;\n\n      return compl;\n    } catch (err) {\n      if (err instanceof FatalError) return undefined;\n      throw err;\n    } finally {\n      realm.setReadOnly(oldReadOnly);\n      this.disallowDelayingRequiresOverride = oldDisallowDelayingRequiresOverride;\n    }\n  }\n}\n"]}