{"version":3,"sources":["../../src/utils/ConcreteModelConverter.js"],"names":["concretize","t","reportCompileError","realm","message","loc","error","handleError","createEmptyFunction","concreteFunction","$ECMAScriptCode","blockStatement","$FormalParameters","uniqueOrderedTag","functionBodyUniqueTagSeed","val","kind","args","length","type","types","getType","isTop","prototype","values","getElements","expressionLocation","template","getTemplate","valIsPartial","isPartialObject","makeNotPartial","concreteObj","ObjectCreate","$GetPrototypeOf","keys","P","newElement","CreateDataProperty","makePartial"],"mappings":"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","file":"ConcreteModelConverter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\n/**\n * This file contains code that converts abstract models into concrete values.\n */\n\nimport type { Realm } from \"../realm.js\";\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  FunctionValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  PrimitiveValue,\n  ArrayValue,\n  ECMAScriptSourceFunctionValue,\n  Value,\n} from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport { CompilerDiagnostic } from \"../errors.js\";\nimport { EnumerableOwnProperties, Get } from \"../methods/index.js\";\nimport { Create } from \"../singletons.js\";\n\nfunction reportCompileError(realm: Realm, message: string, loc: ?BabelNodeSourceLocation) {\n  let error = new CompilerDiagnostic(message, loc, \"PP9000\", \"RecoverableError\");\n  realm.handleError(error);\n}\n\nfunction createEmptyFunction(realm: Realm) {\n  const concreteFunction = new ECMAScriptSourceFunctionValue(realm);\n  concreteFunction.$ECMAScriptCode = t.blockStatement([]);\n  concreteFunction.$FormalParameters = [];\n  ((concreteFunction.$ECMAScriptCode: any): FunctionBodyAstNode).uniqueOrderedTag = realm.functionBodyUniqueTagSeed++;\n  return concreteFunction;\n}\n\n/**\n * Convert abstract model value into concrete value.\n */\nexport function concretize(realm: Realm, val: Value): ConcreteValue {\n  if (val instanceof ConcreteValue) {\n    return val;\n  }\n  invariant(val instanceof AbstractValue);\n  if (val.kind === \"abstractConcreteUnion\") {\n    invariant(val.args.length > 0);\n    return concretize(realm, val.args[0]);\n  }\n  const type = val.types.getType();\n  if (val.types.isTop()) {\n    return new UndefinedValue(realm);\n  } else if (type.prototype instanceof PrimitiveValue) {\n    if (val.values.isTop()) {\n      switch (type) {\n        case StringValue:\n          return new StringValue(realm, \"__concreteModel\");\n        case NumberValue:\n          return new NumberValue(realm, 42);\n        case SymbolValue:\n          return new SymbolValue(realm, new StringValue(realm, \"__concreteModel\"));\n        case BooleanValue:\n          return new BooleanValue(realm, true);\n        case NullValue:\n          return new NullValue(realm);\n        case UndefinedValue:\n          return new UndefinedValue(realm);\n        default:\n          invariant(false, \"Not yet implemented\");\n      }\n    } else {\n      const values = val.values.getElements();\n      invariant(values.length === 1, \"Concrete model should only have one value\");\n      return values[0];\n    }\n  } else if (type === FunctionValue) {\n    return createEmptyFunction(realm);\n  } else if (type === ArrayValue) {\n    reportCompileError(\n      realm,\n      \"Emitting a concrete model for abstract array value is not supported yet.\",\n      val.expressionLocation\n    );\n  } else if (val instanceof AbstractObjectValue) {\n    if (val.values.isTop()) {\n      return new ObjectValue(realm);\n    } else {\n      let template = val.getTemplate();\n      let valIsPartial = false;\n      if (val.isPartialObject()) {\n        valIsPartial = true;\n        val.makeNotPartial();\n      }\n      let concreteObj = Create.ObjectCreate(realm, template.$GetPrototypeOf());\n      try {\n        let keys = EnumerableOwnProperties(realm, template, \"key\");\n        for (let P of keys) {\n          invariant(P instanceof StringValue);\n          let newElement = Get(realm, template, P);\n          Create.CreateDataProperty(realm, concreteObj, P, concretize(realm, newElement));\n        }\n      } finally {\n        if (valIsPartial) {\n          val.makePartial();\n        }\n      }\n      return concreteObj;\n    }\n  }\n  reportCompileError(\n    realm,\n    \"Emitting a concrete model for this abstract value is not supported yet.\",\n    val.expressionLocation\n  );\n  // Return undefined to make flow happy.\n  return new UndefinedValue(realm);\n}\n"]}