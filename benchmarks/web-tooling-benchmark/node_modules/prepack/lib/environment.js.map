{"version":3,"sources":["../src/environment.js"],"names":["havocBinding","mightBecomeAnObject","t","sourceMap","require","deriveGetBinding","realm","binding","types","topVal","values","generator","undefined","derive","_","context","serializeBinding","environment","hasLeaked","recordModifiedBinding","EnvironmentRecord","constructor","isReadOnly","DeclarativeEnvironmentRecord","bindings","Object","create","frozen","HasBinding","N","envRec","CreateMutableBinding","D","isGlobal","initialized","mutable","deletable","name","intrinsics","CreateImmutableBinding","S","strict","InitializeBinding","V","value","empty","SetMutableBinding","createErrorThrowCompletion","ReferenceError","emitBindingAssignment","TypeError","GetBindingValue","DeleteBinding","HasThisBinding","HasSuperBinding","WithBaseObject","ObjectEnvironmentRecord","obj","object","foundBinding","withEnvironment","unscopables","SymbolUnscopables","blocked","ToBooleanPartial","throwIfNotConcrete","configValue","DefinePropertyOrThrow","writable","enumerable","configurable","Set","$Delete","FunctionEnvironmentRecord","BindThisValue","$ThisBindingStatus","$ThisValue","$HomeObject","GetThisBinding","GetSuperBase","home","$GetPrototypeOf","GlobalEnvironmentRecord","DclRec","$DeclarativeRecord","ObjRec","$ObjectRecord","globalObject","existingProp","status","varNames","$VarNames","indexOf","splice","$GlobalThisValue","HasVarDeclaration","varDeclaredNames","HasLexicalDeclaration","HasRestrictedGlobalProperty","$GetOwnProperty","ThrowIfMightHaveBeenDeleted","CanDeclareGlobalVar","hasProperty","CanDeclareGlobalFunction","CreateGlobalVarBinding","extensible","push","CreateGlobalFunctionBinding","desc","uid","LexicalEnvironment","destroyed","_uid","destroy","environmentRecord","assignToGlobal","globalAst","rvalue","globalValue","evaluate","PutValue","partiallyEvaluateCompletionDeref","ast","strictCode","metadata","result","partial_ast","partial_io","partiallyEvaluateCompletion","Reference","GetValue","partiallyEvaluate","err","Error","evaluateCompletionDeref","evaluateCompletion","containsBreakOrContinue","reportIntrospectionError","joinCondition","evaluateAbstractCompletion","evaluateAbstract","concatenateAndParse","sources","sourceType","asts","code","directives","source","node","fileContents","filePath","sourceMapContents","length","fixup_source_locations","fixup_filenames","concat","program","body","e","error","message","$Get","location","start","line","column","end","diagnostic","handleError","file","executeSources","onParse","lexicalEnvironment","variableEnvironment","pushContext","res","popContext","onDestroyScope","activeLexicalEnvironments","size","executePartialEvaluator","options","partialAST","type","fileAst","prog","sourceMaps","execute","filename","map","smc","SourceMapConsumer","loc","fixup","fixup_comments","leadingComments","innerComments","trailingComments","new_loc","new_pos","old_pos","originalPositionFor","comments","c","cloc","debuggerInstance","checkForActions","currentLocation","testTimeout","evaluator","evaluators","partialEvaluator","partialEvaluators","base","getType","refName","thisValue","referencedName","mightNotBeString","mightNotBeNumber","isSimpleObject"],"mappings":"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","file":"environment.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelNode,\n  BabelNodeComment,\n  BabelNodeFile,\n  BabelNodeLVal,\n  BabelNodePosition,\n  BabelNodeStatement,\n  BabelNodeSourceLocation,\n} from \"babel-types\";\nimport type { Realm } from \"./realm.js\";\nimport type { SourceFile, SourceMap, SourceType } from \"./types.js\";\n\nimport {\n  AbruptCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  PossiblyNormalCompletion,\n  ThrowCompletion,\n} from \"./completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"./errors.js\";\nimport { defaultOptions } from \"./options\";\nimport type { PartialEvaluatorOptions } from \"./options\";\nimport { ExecutionContext } from \"./realm.js\";\nimport {\n  AbstractValue,\n  NullValue,\n  SymbolValue,\n  BooleanValue,\n  FunctionValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  AbstractObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"./values/index.js\";\nimport generate from \"babel-generator\";\nimport parse from \"./utils/parse.js\";\nimport invariant from \"./invariant.js\";\nimport traverseFast from \"./utils/traverse-fast.js\";\nimport { HasProperty, Get, IsExtensible, HasOwnProperty, IsDataDescriptor } from \"./methods/index.js\";\nimport { Environment, Havoc, Properties, To } from \"./singletons.js\";\nimport * as t from \"babel-types\";\nimport { TypesDomain, ValuesDomain } from \"./domains/index.js\";\nimport PrimitiveValue from \"./values/PrimitiveValue\";\n\nconst sourceMap = require(\"source-map\");\n\nfunction deriveGetBinding(realm: Realm, binding: Binding) {\n  let types = TypesDomain.topVal;\n  let values = ValuesDomain.topVal;\n  invariant(realm.generator !== undefined);\n  return realm.generator.derive(types, values, [], (_, context) => context.serializeBinding(binding));\n}\n\nexport function havocBinding(binding: Binding) {\n  let realm = binding.environment.realm;\n  if (!binding.hasLeaked) {\n    realm.recordModifiedBinding(binding).hasLeaked = true;\n  }\n}\n\n// ECMA262 8.1.1\nexport class EnvironmentRecord {\n  realm: Realm;\n  isReadOnly: boolean;\n  $NewTarget: void | ObjectValue;\n\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n    this.isReadOnly = false;\n  }\n\n  +HasBinding: (N: string) => boolean;\n  +CreateMutableBinding: (N: string, D: boolean, isGlobal?: boolean) => Value;\n  +CreateImmutableBinding: (N: string, S: boolean, isGlobal?: boolean) => Value;\n  +InitializeBinding: (N: string, V: Value) => Value;\n  +SetMutableBinding: (N: string, V: Value, S: boolean) => Value;\n  +GetBindingValue: (N: string, S: boolean) => Value;\n  +DeleteBinding: (N: string) => boolean;\n  +HasThisBinding: () => boolean;\n  +GetThisBinding: () => NullValue | ObjectValue | AbstractObjectValue | UndefinedValue;\n  +HasSuperBinding: () => boolean;\n  +WithBaseObject: () => Value;\n  +BindThisValue: (\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ) => NullValue | ObjectValue | AbstractObjectValue | UndefinedValue;\n}\n\nexport type Binding = {\n  value?: Value,\n  initialized?: boolean,\n  mutable?: boolean,\n  deletable?: boolean,\n  // back-references to the environment containing the binding and the key\n  // used to access this binding\n  environment: EnvironmentRecord,\n  name: string,\n  isGlobal: boolean,\n  // bindings that are assigned to inside loops with abstract termination conditions need temporal locations\n  phiNode?: AbstractValue,\n  hasLeaked: boolean,\n};\n\n// ECMA262 8.1.1.1\nexport class DeclarativeEnvironmentRecord extends EnvironmentRecord {\n  constructor(realm: Realm) {\n    super(realm);\n    this.bindings = (Object.create(null): any);\n    this.frozen = false;\n  }\n\n  bindings: { [name: string]: Binding };\n  // Frozen Records cannot have bindings created or deleted but can have bindings updated\n  frozen: boolean;\n\n  // ECMA262 8.1.1.1.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec has a binding for the name that is the value of N, return true.\n    if (envRec.bindings[N]) return true;\n\n    // 3. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.2\n  CreateMutableBinding(N: string, D: boolean, isGlobal: boolean = false): Value {\n    invariant(!this.frozen);\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n    this.bindings[N] = realm.recordModifiedBinding({\n      initialized: false,\n      mutable: true,\n      deletable: D,\n      environment: envRec,\n      name: N,\n      isGlobal: isGlobal,\n      hasLeaked: false,\n    });\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.3\n  CreateImmutableBinding(N: string, S: boolean, isGlobal: boolean = false): Value {\n    invariant(!this.frozen);\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that the newly created binding is a strict binding.\n    this.bindings[N] = realm.recordModifiedBinding({\n      initialized: false,\n      strict: S,\n      deletable: false,\n      environment: envRec,\n      name: N,\n      isGlobal: isGlobal,\n      hasLeaked: false,\n    });\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    invariant(binding && !binding.initialized, `shouldn't have the binding ${N}`);\n\n    // 3. Set the bound value for N in envRec to V.\n    this.realm.recordModifiedBinding(binding).value = V;\n\n    // 4. Record that the binding for N in envRec has been initialized.\n    binding.initialized = true;\n\n    // 5. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    // We can mutate frozen bindings because of captured bindings.\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. If envRec does not have a binding for N, then\n    if (!binding) {\n      // a. If S is true, throw a ReferenceError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} not found`);\n      }\n\n      // b. Perform envRec.CreateMutableBinding(N, true).\n      envRec.CreateMutableBinding(N, true);\n\n      // c. Perform envRec.InitializeBinding(N, V).\n      envRec.InitializeBinding(N, V);\n\n      // d. Return NormalCompletion(empty).\n      return this.realm.intrinsics.empty;\n    }\n\n    // 3. If the binding for N in envRec is a strict binding, let S be true.\n    if (binding.strict) S = true;\n\n    // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} has not yet been initialized`);\n    } else if (binding.mutable) {\n      // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.\n      if (binding.hasLeaked) {\n        Havoc.value(realm, V);\n        invariant(realm.generator);\n        realm.generator.emitBindingAssignment(binding, V);\n      } else {\n        realm.recordModifiedBinding(binding).value = V;\n      }\n    } else {\n      // 6. Else,\n      // a. Assert: This is an attempt to change the value of an immutable binding.\n\n      // b. If S is true, throw a TypeError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"attempt to change immutable binding\");\n      }\n    }\n\n    // 7. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec has a binding for N.\n    invariant(binding, \"expected binding\");\n\n    // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return the value currently bound to N in envRec.\n    if (binding.hasLeaked) {\n      return deriveGetBinding(realm, binding);\n    }\n    invariant(binding.value);\n    return binding.value;\n  }\n\n  // ECMA262 8.1.1.1.7\n  DeleteBinding(N: string): boolean {\n    invariant(!this.frozen);\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec has a binding for the name that is the value of N.\n    invariant(envRec.bindings[N], \"expected binding to exist\");\n\n    // 3. If the binding for N in envRec cannot be deleted, return false.\n    if (!envRec.bindings[N].deletable) return false;\n\n    // 4. Remove the binding for N from envRec.\n    this.realm.recordModifiedBinding(envRec.bindings[N]).value = undefined;\n    delete envRec.bindings[N];\n\n    // 5. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.1.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.2\nexport class ObjectEnvironmentRecord extends EnvironmentRecord {\n  object: ObjectValue | AbstractObjectValue;\n  withEnvironment: boolean;\n\n  constructor(realm: Realm, obj: ObjectValue | AbstractObjectValue) {\n    super(realm);\n    this.object = obj;\n  }\n\n  // ECMA262 8.1.1.2.1\n  HasBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = this.object;\n\n    // 3. Let foundBinding be ? HasProperty(bindings, N).\n    let foundBinding = HasProperty(realm, bindings, N);\n\n    // 4. If foundBinding is false, return false.\n    if (!foundBinding) return false;\n\n    // 5. If the withEnvironment flag of envRec is false, return true.\n    if (!envRec.withEnvironment) return true;\n\n    // 6. Let unscopables be ? Get(bindings, @@unscopables).\n    let unscopables = Get(realm, bindings, realm.intrinsics.SymbolUnscopables);\n\n    // 7. If Type(unscopables) is Object, then\n    if (unscopables instanceof ObjectValue || unscopables instanceof AbstractObjectValue) {\n      // a. Let blocked be ToBoolean(? Get(unscopables, N)).\n      let blocked = To.ToBooleanPartial(realm, Get(realm, unscopables, N));\n\n      // b. If blocked is true, return false.\n      if (blocked) return false;\n    }\n    unscopables.throwIfNotConcrete();\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.2.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. If D is true, let configValue be true; otherwise let configValue be false.\n    let configValue = D ? true : false;\n\n    // 4. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: configValue}).\n    return new BooleanValue(\n      realm,\n      Properties.DefinePropertyOrThrow(realm, bindings, N, {\n        value: realm.intrinsics.undefined,\n        writable: true,\n        enumerable: true,\n        configurable: configValue,\n      })\n    );\n  }\n\n  // ECMA262 8.1.1.2.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    // The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.\n    invariant(false);\n  }\n\n  // ECMA262 8.1.1.2.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    // 3. Record that the binding for N in envRec has been initialized.\n\n    // 4. Return ? envRec.SetMutableBinding(N, V, false).\n    return envRec.SetMutableBinding(N, V, false);\n  }\n\n  // ECMA262 8.1.1.2.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? Set(bindings, N, V, S).\n    return new BooleanValue(realm, Properties.Set(realm, bindings, N, V, S));\n  }\n\n  // ECMA262 8.1.1.2.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Let value be ? HasProperty(bindings, N).\n    let value = HasProperty(realm, bindings, N);\n\n    // 4. If value is false, then\n    if (!value) {\n      // a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.\n      if (!S) {\n        return realm.intrinsics.undefined;\n      } else {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n    }\n\n    // 5. Return ? Get(bindings, N).\n    return Get(realm, bindings, N);\n  }\n\n  // ECMA262 8.1.1.2.7\n  DeleteBinding(N: string): boolean {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? bindings.[[Delete]](N).\n    return bindings.$Delete(N);\n  }\n\n  // ECMA262 8.1.1.2.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.10\n  WithBaseObject(): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.\n    if (envRec.withEnvironment) return envRec.object;\n\n    // 3. Otherwise, return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.3\nexport class FunctionEnvironmentRecord extends DeclarativeEnvironmentRecord {\n  $ThisBindingStatus: \"lexical\" | \"initialized\" | \"uninitialized\";\n  $ThisValue: UndefinedValue | NullValue | ObjectValue | AbstractObjectValue;\n  $HomeObject: void | ObjectValue;\n  $FunctionObject: FunctionValue;\n\n  // ECMA262 8.1.1.3.1\n  BindThisValue(\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"initialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"initialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Set envRec.[[ThisValue]] to V.\n    envRec.$ThisValue = V;\n\n    // 5. Set envRec.[[ThisBindingStatus]] to \"initialized\".\n    envRec.$ThisBindingStatus = \"initialized\";\n\n    // 6. Return V.\n    return V;\n  }\n\n  // ECMA262 8.1.1.3.2\n  HasThisBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false; otherwise, return true.\n    return envRec.$ThisBindingStatus === \"lexical\" ? false : true;\n  }\n\n  // ECMA262 8.1.1.3.3\n  HasSuperBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false.\n    if (envRec.$ThisBindingStatus === \"lexical\") return false;\n\n    // 3. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.\n    if (envRec.$HomeObject === undefined) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  // ECMA262 8.1.1.3.4\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"uninitialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"uninitialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return envRec.[[ThisValue]].\n    return envRec.$ThisValue;\n  }\n\n  // ECMA262 8.1.1.3.5\n  GetSuperBase(): ObjectValue | NullValue | UndefinedValue {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let home be the value of envRec.[[HomeObject]].\n    let home = envRec.$HomeObject;\n\n    // 3. If home has the value undefined, return undefined.\n    if (home === undefined) return this.realm.intrinsics.undefined;\n\n    // 4. Assert: Type(home) is Object.\n    invariant(home instanceof ObjectValue, \"expected object value\");\n\n    // 5. Return ? home.[[GetPrototypeOf]]().\n    return home.$GetPrototypeOf();\n  }\n}\n\n// ECMA262 8.1.1.4\nexport class GlobalEnvironmentRecord extends EnvironmentRecord {\n  $DeclarativeRecord: EnvironmentRecord;\n  $ObjectRecord: ObjectEnvironmentRecord;\n  $VarNames: Array<string>;\n  $GlobalThisValue: ObjectValue;\n\n  // ECMA262 8.1.1.4.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, return true.\n    if (DclRec.HasBinding(N)) return true;\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.HasBinding(N).\n    return ObjRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateMutableBinding(N, D).\n    return DclRec.CreateMutableBinding(N, D, true);\n  }\n\n  // ECMA262 8.1.1.4.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateImmutableBinding(N, S).\n    return DclRec.CreateImmutableBinding(N, S, true);\n  }\n\n  // ECMA262 8.1.1.4.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.InitializeBinding(N, V).\n      return DclRec.InitializeBinding(N, V);\n    }\n\n    // 4. Assert: If the binding exists, it must be in the object Environment Record.\n\n    // 5. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 6. Return ? ObjRec.InitializeBinding(N, V).\n    return ObjRec.InitializeBinding(N, V);\n  }\n\n  // ECMA262 8.1.1.4.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.SetMutableBinding(N, V, S).\n      return DclRec.SetMutableBinding(N, V, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.SetMutableBinding(N, V, S).\n    return ObjRec.SetMutableBinding(N, V, S);\n  }\n\n  // ECMA262 8.1.1.4.6\n  GetBindingValue(N: string, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.GetBindingValue(N, S).\n      return DclRec.GetBindingValue(N, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.GetBindingValue(N, S).\n    return ObjRec.GetBindingValue(N, S);\n  }\n\n  // ECMA262 8.1.1.4.7\n  DeleteBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.DeleteBinding(N).\n      return DclRec.DeleteBinding(N);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 6. Let existingProp be ? HasOwnProperty(globalObject, N).\n    let existingProp = HasOwnProperty(realm, globalObject, N);\n\n    // 7. If existingProp is true, then\n    if (existingProp) {\n      // a. Let status be ? ObjRec.DeleteBinding(N).\n      let status = ObjRec.DeleteBinding(N);\n\n      // b. If status is true, then\n      if (status) {\n        // i. Let varNames be envRec.[[VarNames]].\n        let varNames = envRec.$VarNames;\n\n        // ii. If N is an element of varNames, remove that element from the varNames.\n        if (varNames.indexOf(N) >= 0) {\n          varNames.splice(varNames.indexOf(N), 1);\n        }\n      }\n\n      // c. Return status.\n      return status;\n    }\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.8\n  HasThisBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.9\n  HasSuperBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.4.11\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    invariant(envRec.$GlobalThisValue);\n    // 2. Return envRec.[[GlobalThisValue]].\n    return envRec.$GlobalThisValue;\n  }\n\n  // ECMA262 8.1.1.4.12\n  HasVarDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 3. If varDeclaredNames contains the value of N, return true.\n    if (varDeclaredNames.indexOf(N) >= 0) return true;\n\n    // 4. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.13\n  HasLexicalDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. Return DclRec.HasBinding(N).\n    return DclRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.14\n  HasRestrictedGlobalProperty(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return false.\n    if (!existingProp) return false;\n    Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return false.\n    if (existingProp.configurable) return false;\n\n    // 7. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.15\n  CanDeclareGlobalVar(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. If hasProperty is true, return true.\n    if (hasProperty) return true;\n\n    // 6. Return ? IsExtensible(globalObject).\n    return IsExtensible(realm, globalObject);\n  }\n\n  // ECMA262 8.1.1.4.16\n  CanDeclareGlobalFunction(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return ? IsExtensible(globalObject).\n    if (!existingProp) return IsExtensible(realm, globalObject);\n    Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return true.\n    if (existingProp.configurable) return true;\n\n    // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values {[[Writable]]: true, [[Enumerable]]: true}, return true.\n    if (IsDataDescriptor(realm, existingProp) && existingProp.writable && existingProp.enumerable) {\n      return true;\n    }\n\n    // 8. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.17\n  CreateGlobalVarBinding(N: string, D: boolean) {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. Let extensible be ? IsExtensible(globalObject).\n    let extensible = IsExtensible(realm, globalObject);\n\n    // 6. If hasProperty is false and extensible is true, then\n    if (!hasProperty && extensible) {\n      // a. Perform ? ObjRec.CreateMutableBinding(N, D).\n      ObjRec.CreateMutableBinding(N, D);\n\n      // b. Perform ? ObjRec.InitializeBinding(N, undefined).\n      ObjRec.InitializeBinding(N, this.realm.intrinsics.undefined);\n    }\n\n    // 7. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 8. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 9. Return NormalCompletion(empty).\n  }\n\n  // ECMA262 8.1.1.4.18\n  CreateGlobalFunctionBinding(N: string, V: Value, D: boolean) {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then\n    let desc;\n    if (!existingProp || existingProp.configurable) {\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D}.\n      desc = { value: V, writable: true, enumerable: true, configurable: D };\n    } else {\n      // 6. Else,\n      Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V }.\n      desc = { value: V };\n    }\n\n    // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).\n    Properties.DefinePropertyOrThrow(this.realm, globalObject, N, desc);\n\n    // 8. Record that the binding for N in ObjRec has been initialized.\n\n    // 9. Perform ? Set(globalObject, N, V, false).\n    Properties.Set(this.realm, globalObject, N, V, false);\n\n    // 10. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 11. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 12. Return NormalCompletion(empty).\n  }\n}\n\n// ECMA262 8.1\nlet uid = 0;\nexport class LexicalEnvironment {\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n    this.destroyed = false;\n    this._uid = uid++;\n  }\n\n  // For debugging it is convenient to have an ID for each of these.\n  _uid: number;\n  destroyed: boolean;\n  environmentRecord: EnvironmentRecord;\n  parent: null | LexicalEnvironment;\n  realm: Realm;\n\n  destroy() {\n    this.destroyed = true;\n    // Once the containing environment is destroyed, we can no longer add or remove entries from the environmentRecord\n    // (but we can update existing values).\n    if (this.environmentRecord instanceof DeclarativeEnvironmentRecord) {\n      this.environmentRecord.frozen = true;\n    }\n  }\n\n  assignToGlobal(globalAst: BabelNodeLVal, rvalue: Value) {\n    let globalValue = this.evaluate(globalAst, false);\n    Properties.PutValue(this.realm, globalValue, rvalue);\n  }\n\n  partiallyEvaluateCompletionDeref(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Value, BabelNode, Array<BabelNodeStatement>] {\n    let [result, partial_ast, partial_io] = this.partiallyEvaluateCompletion(ast, strictCode, metadata);\n    if (result instanceof Reference) {\n      result = Environment.GetValue(this.realm, result);\n    }\n    return [result, partial_ast, partial_io];\n  }\n\n  partiallyEvaluateCompletion(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>] {\n    try {\n      return this.partiallyEvaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof Completion) return [err, ast, []];\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new FatalError(err);\n    }\n  }\n\n  evaluateCompletionDeref(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value {\n    let result = this.evaluateCompletion(ast, strictCode, metadata);\n    if (result instanceof Reference) result = Environment.GetValue(this.realm, result);\n    return result;\n  }\n\n  evaluateCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value | Reference {\n    try {\n      return this.evaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (\n        (err instanceof JoinedAbruptCompletions || err instanceof PossiblyNormalCompletion) &&\n        err.containsBreakOrContinue()\n      ) {\n        AbstractValue.reportIntrospectionError(err.joinCondition);\n        throw new FatalError();\n      }\n      if (err instanceof AbruptCompletion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new FatalError(err);\n    }\n  }\n\n  evaluateAbstractCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): Completion | Value | Reference {\n    try {\n      return this.evaluateAbstract(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof Completion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      if (err instanceof Object) throw new FatalError(err.constructor.name + \": \" + err);\n      throw new FatalError(err);\n    }\n  }\n\n  concatenateAndParse(\n    sources: Array<SourceFile>,\n    sourceType: SourceType = \"script\"\n  ): [BabelNodeFile, { [string]: string }] {\n    let asts = [];\n    let code = {};\n    let directives = [];\n    for (let source of sources) {\n      try {\n        let node = parse(this.realm, source.fileContents, source.filePath, sourceType);\n        if (source.sourceMapContents && source.sourceMapContents.length > 0)\n          this.fixup_source_locations(node, source.sourceMapContents);\n        this.fixup_filenames(node);\n        asts = asts.concat(node.program.body);\n        code[source.filePath] = source.fileContents;\n        directives = directives.concat(node.program.directives);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) {\n          let error = e.value;\n          if (error instanceof ObjectValue) {\n            let message = error.$Get(\"message\", error);\n            message.value = `Syntax error: ${message.value}`;\n            e.location.source = source.filePath;\n            // the position was not located properly on the\n            // syntax errors happen on one given position, so start position = end position\n            e.location.start = { line: e.location.line, column: e.location.column };\n            e.location.end = { line: e.location.line, column: e.location.column };\n            let diagnostic = new CompilerDiagnostic(message.value, e.location, \"PP1004\", \"FatalError\");\n            this.realm.handleError(diagnostic);\n            throw new FatalError(message.value);\n          }\n        }\n        throw e;\n      }\n    }\n    return [t.file(t.program(asts, directives)), code];\n  }\n\n  executeSources(\n    sources: Array<SourceFile>,\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): [AbruptCompletion | Value, { [string]: string }] {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n    this.realm.pushContext(context);\n    let res, code;\n    try {\n      let ast;\n      [ast, code] = this.concatenateAndParse(sources, sourceType);\n      if (onParse) onParse(ast);\n      res = this.evaluateCompletion(ast, false);\n    } finally {\n      this.realm.popContext(context);\n      this.realm.onDestroyScope(context.lexicalEnvironment);\n      if (!this.destroyed) this.realm.onDestroyScope(this);\n      invariant(this.realm.activeLexicalEnvironments.size === 0);\n    }\n    if (res instanceof AbruptCompletion) return [res, code];\n\n    return [Environment.GetValue(this.realm, res), code];\n  }\n\n  executePartialEvaluator(\n    sources: Array<SourceFile>,\n    options: PartialEvaluatorOptions = defaultOptions,\n    sourceType: SourceType = \"script\"\n  ): AbruptCompletion | { code: string, map?: SourceMap } {\n    let [ast, code] = this.concatenateAndParse(sources, sourceType);\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n    this.realm.pushContext(context);\n    let partialAST;\n    try {\n      [, partialAST] = this.partiallyEvaluateCompletionDeref(ast, false);\n    } finally {\n      this.realm.popContext(context);\n      this.realm.onDestroyScope(context.lexicalEnvironment);\n      if (!this.destroyed) this.realm.onDestroyScope(this);\n      invariant(this.realm.activeLexicalEnvironments.size === 0);\n    }\n    invariant(partialAST.type === \"File\");\n    let fileAst = ((partialAST: any): BabelNodeFile);\n    let prog = t.program(fileAst.program.body, ast.program.directives);\n    this.fixup_filenames(prog);\n    // The type signature for generate is not complete, hence the any\n    return generate(prog, { sourceMaps: options.sourceMaps }, (code: any));\n  }\n\n  execute(\n    code: string,\n    filename: string,\n    map: string = \"\",\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): AbruptCompletion | Value {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n\n    this.realm.pushContext(context);\n\n    let ast, res;\n    try {\n      try {\n        ast = parse(this.realm, code, filename, sourceType);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) return e;\n        throw e;\n      }\n      if (onParse) onParse(ast);\n      if (map.length > 0) this.fixup_source_locations(ast, map);\n      this.fixup_filenames(ast);\n      res = this.evaluateCompletion(ast, false);\n    } finally {\n      this.realm.popContext(context);\n      // Avoid destroying \"this\" scope as execute may be called many times.\n      if (context.lexicalEnvironment !== this) this.realm.onDestroyScope(context.lexicalEnvironment);\n      invariant(this.realm.activeLexicalEnvironments.size === 1);\n    }\n    if (res instanceof AbruptCompletion) return res;\n\n    return Environment.GetValue(this.realm, res);\n  }\n\n  fixup_source_locations(ast: BabelNode, map: string) {\n    const smc = new sourceMap.SourceMapConsumer(map);\n    traverseFast(ast, node => {\n      let loc = node.loc;\n      if (!loc) return false;\n      fixup(loc, loc.start);\n      fixup(loc, loc.end);\n      fixup_comments(node.leadingComments);\n      fixup_comments(node.innerComments);\n      fixup_comments(node.trailingComments);\n      return false;\n\n      function fixup(new_loc: BabelNodeSourceLocation, new_pos: BabelNodePosition) {\n        let old_pos = smc.originalPositionFor({ line: new_pos.line, column: new_pos.column });\n        if (old_pos.source === null) return;\n        new_pos.line = old_pos.line;\n        new_pos.column = old_pos.column;\n        new_loc.source = old_pos.source;\n      }\n\n      function fixup_comments(comments: ?Array<BabelNodeComment>) {\n        if (!comments) return;\n        for (let c of comments) {\n          let cloc = c.loc;\n          if (!cloc) continue;\n          fixup(cloc, cloc.start);\n          fixup(cloc, cloc.end);\n        }\n      }\n    });\n  }\n\n  fixup_filenames(ast: BabelNode) {\n    traverseFast(ast, node => {\n      let loc = node.loc;\n      if (!loc || !loc.source) {\n        node.leadingComments = null;\n        node.innerComments = null;\n        node.trailingComments = null;\n        node.loc = null;\n      } else {\n        let filename = loc.source;\n        (loc: any).filename = filename;\n        fixup_comments(node.leadingComments, filename);\n        fixup_comments(node.innerComments, filename);\n        fixup_comments(node.trailingComments, filename);\n      }\n      return false;\n\n      function fixup_comments(comments: ?Array<BabelNodeComment>, filename: string) {\n        if (!comments) return;\n        for (let c of comments) {\n          if (c.loc) {\n            (c.loc: any).filename = filename;\n            c.loc.source = filename;\n          }\n        }\n      }\n    });\n  }\n\n  evaluate(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    if (this.realm.debuggerInstance) {\n      this.realm.debuggerInstance.checkForActions(ast);\n    }\n    let res = this.evaluateAbstract(ast, strictCode, metadata);\n    invariant(res instanceof Value || res instanceof Reference, ast.type);\n    return res;\n  }\n\n  evaluateAbstract(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    this.realm.currentLocation = ast.loc;\n    this.realm.testTimeout();\n\n    let evaluator = this.realm.evaluators[(ast.type: string)];\n    if (evaluator) {\n      let result = evaluator(ast, strictCode, this, this.realm, metadata);\n      return result;\n    }\n\n    throw new TypeError(`Unsupported node type ${ast.type}`);\n  }\n\n  partiallyEvaluate(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>] {\n    let partialEvaluator = this.realm.partialEvaluators[(ast.type: string)];\n    if (partialEvaluator) {\n      return partialEvaluator(ast, strictCode, this, this.realm, metadata);\n    }\n\n    let err = new TypeError(`Unsupported node type ${ast.type}`);\n    throw err;\n  }\n}\n\n// ECMA262 6.2.3\n// A Reference is a resolved name or property binding. A Reference consists of three components, the base value,\n// the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object,\n// a Boolean, a String, a Symbol, a Number, or an Environment Record. A base value of undefined indicates that the\n// Reference could not be resolved to a binding. The referenced name is a String or Symbol value.\nexport type BaseValue =\n  | void\n  | ObjectValue\n  | BooleanValue\n  | StringValue\n  | SymbolValue\n  | NumberValue\n  | IntegralValue\n  | EnvironmentRecord;\nexport type ReferenceName = string | SymbolValue;\n\nexport function mightBecomeAnObject(base: Value): boolean {\n  let type = base.getType();\n  // The top Value type might be able to become an object. We let it\n  // pass and error later if it can't.\n  return (\n    type === Value ||\n    type === PrimitiveValue ||\n    type === BooleanValue ||\n    type === StringValue ||\n    type === SymbolValue ||\n    type === NumberValue ||\n    type === IntegralValue\n  );\n}\n\nexport class Reference {\n  base: BaseValue | AbstractValue;\n  referencedName: ReferenceName | AbstractValue;\n  strict: boolean;\n  thisValue: void | Value;\n\n  constructor(\n    base: BaseValue | AbstractValue,\n    refName: ReferenceName | AbstractValue,\n    strict: boolean,\n    thisValue?: void | Value\n  ) {\n    invariant(\n      base instanceof AbstractObjectValue ||\n        base === undefined ||\n        base instanceof ObjectValue ||\n        base instanceof EnvironmentRecord ||\n        mightBecomeAnObject(base)\n    );\n    this.base = base;\n    this.referencedName = refName;\n    invariant(\n      !(refName instanceof AbstractValue) ||\n        !(\n          refName.mightNotBeString() &&\n          refName.mightNotBeNumber() &&\n          !refName.isSimpleObject() &&\n          // if the base is a simple abstract object but\n          // the refName is not simple, this is also okay\n          (base instanceof AbstractValue && !base.isSimpleObject())\n        )\n    );\n    this.strict = strict;\n    this.thisValue = thisValue;\n    invariant(thisValue === undefined || !(base instanceof EnvironmentRecord));\n  }\n}\n"]}