{"version":3,"sources":["../src/realm.js"],"names":["construct_empty_effects","t","Tracer","beginEvaluateForEffects","state","endEvaluateForEffects","effects","detourCall","F","thisArgument","argumentsList","newTarget","performCall","beforeCall","afterCall","result","ExecutionContext","setCaller","context","caller","setFunction","isStrict","$Strict","function","setLocation","loc","setRealm","realm","setReadOnly","value","oldReadOnly","isReadOnly","variableEnvironment","environmentRecord","lexicalEnvironment","suspend","resume","intrinsics","undefined","empty","Map","Set","Realm","constructor","opts","contextStack","MOBILE_JSC_VERSION","objectCount","symbolCount","functionBodyUniqueTagSeed","nextGeneratorId","useAbstractInterpretation","serialize","residual","check","trackLeaks","abstractEffectsInAdditionalFunctions","ignoreLeakLogic","isInPureTryStatement","mathRandomSeed","mathRandomGenerator","strictlyMonotonicDateNow","timeout","timeoutCounter","timeoutCounterThreshold","start","Date","now","compatibility","maxStackDepth","omitInvariants","emitConcreteModel","$TemplateMap","preludeGenerator","debugNames","uniqueSuffix","pathConditions","setupTrackedPropertyAccessors","trackedPropertyNames","tracers","$GlobalObject","evaluators","Object","create","partialEvaluators","$GlobalEnv","react","abstractHints","WeakMap","classComponentMetadata","currentOwner","enabled","reactEnabled","output","reactOutput","hoistableFunctions","hoistableReactElements","reactElements","WeakSet","symbols","stripFlow","fbLibraries","other","reactRelay","errorHandler","globalSymbolRegistry","activeLexicalEnvironments","_abstractValuesDefined","isCompatibleWith","getGlobalLetBinding","key","globrec","dclrec","$DeclarativeRecord","HasBinding","GetBindingValue","e","readOnlyValue","forEach","ctx","testTimeout","total","hasRunningContext","length","getRunningContext","clearBlockBindings","modifiedBindings","b","keys","bindings","name","delete","clearBlockBindingsFromCompletion","completion","alternateEffects","consequentEffects","savedEffects","alternate","consequent","onDestroyScope","has","savedCompletion","destroy","pushContext","push","clearFunctionBindings","funcVal","environment","$FunctionObject","clearFunctionBindingsFromCompletion","popContext","c","pop","wrapInGlobalEnv","callback","assignToGlobal","deleteGlobalBinding","DeleteBinding","evaluatePure","f","saved_createdObjectsTrackedForLeaks","createdObjectsTrackedForLeaks","isInPureScope","evaluateWithoutLeakLogic","evaluateWithPossibleThrowCompletion","thrownTypes","thrownValues","diag","currentLocation","handleError","evaluateNodeForEffects","ast","strictCode","env","generatorName","evaluateForEffects","evaluateCompletionDeref","evaluateForEffectsInGlobalEnv","func","withEffectsAppliedInGlobalEnv","applyEffects","restoreBindings","restoreProperties","evaluateNodeForEffectsInGlobalEnv","node","partiallyEvaluateNodeForEffects","nodeAst","nodeIO","partialEval","partiallyEvaluateCompletionDeref","savedBindings","savedProperties","getAndResetModifiedMaps","saved_generator","generator","saved_createdObjects","createdObjects","saved_completion","t1","GetValue","incorporateSavedCompletion","subsequentEffects","getCapturedEffects","stopEffectCaptureAndUndoEffects","updatePossiblyNormalCompletionWithSubsequentEffects","modifiedProperties","astGenerator","astBindings","astProperties","astCreatedObjects","t2","evaluateWithUndo","defaultValue","oldErrorHandler","d","severity","evaluateWithUndoForDiagnostic","savedHandler","diagnostic","resultVal","composeWithSavedCompletion","evaluateForFixpointEffects","loopContinueTest","loopBody","effects1","effects2","test","containsEffects","gen","bindings2","pbindings2","_emitPropertAssignments","_emitLocalAssignments","widenEffects","tvalFor","binding","map","val","_buildNode","tval","derive","types","values","n","skipInvariant","set","phiNode","get","emitStatement","v","id","buildNode","expressionStatement","assignmentExpression","pbindings","isSelfReferential","pathNode","args","object","o","mightHaveBeenDeleted","inTest","binaryExpression","stringLiteral","addEmpty","conditionalExpression","logicalExpression","path","mightBeUndefined","lh","identifier","r","emptyTest","undefinedTest","unaryExpression","guard","deleteIt","ifStatement","p","composeEffects","priorEffects","pg","pb","pp","po","sc","sg","sb","sp","so","rb","rp","ro","composeGenerators","m","desc","propertyBinding","ob","a","add","updateAbruptCompletions","savedPathConditions","captureEffects","composePossiblyNormalCompletions","pushInverseAndRefine","joinCondition","pushAndRefine","incorporatePriorSavedCompletion","priorCompletion","stopEffectCapture","g","leadingComment","properties","appendGenerator","realmModifiedBindings","realmModifiedProperties","size","realmCreatedObjects","outputToConsole","method","emitConsoleLog","console","getString","res","next","shift","nextString","ToString","recordModifiedBinding","hasLeaked","callReportObjectGetOwnProperties","reportObjectGetOwnProperties","callReportPropertyAccess","reportPropertyAccess","recordModifiedProperty","isNewObject","descriptor","recordNewObject","l","setModifiedMaps","rebuildObjectProperty","propertyValue","kind","absVal","find","isIntrinsic","intrinsicName","memberExpression","rebuildNestedProperties","abstractValue","isTop","template","getTemplate","intrinsicNameGenerated","ThrowIfMightHaveBeenDeleted","reportIntrospectionError","createExecutionContext","nextContextLocation","setNextExecutionContextLocation","message","error","createErrorThrowCompletion","type","__IntrospectionError","realmGenerator","callStack","Error","stack","$Get","msg","errorCode","location","loc_start","loc_end","end","line","column","log","warn","saveNameString","nameString","isNameStringUnique"],"mappings":"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","file":"realm.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  Intrinsics,\n  PropertyBinding,\n  Descriptor,\n  DebugServerType,\n  ClassComponentMetadata,\n  ReactHint,\n} from \"./types.js\";\nimport { CompilerDiagnostic, type ErrorHandlerResult, type ErrorHandler, FatalError } from \"./errors.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ConcreteValue,\n  ECMAScriptSourceFunctionValue,\n  FunctionValue,\n  NativeFunctionValue,\n  ObjectValue,\n  ProxyValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"./values/index.js\";\nimport type { TypesDomain, ValuesDomain } from \"./domains/index.js\";\nimport { LexicalEnvironment, Reference, GlobalEnvironmentRecord, DeclarativeEnvironmentRecord } from \"./environment.js\";\nimport type { Binding } from \"./environment.js\";\nimport { cloneDescriptor, Construct } from \"./methods/index.js\";\nimport {\n  AbruptCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  PossiblyNormalCompletion,\n  ThrowCompletion,\n} from \"./completions.js\";\nimport type { Compatibility, RealmOptions, ReactOutputTypes } from \"./options.js\";\nimport invariant from \"./invariant.js\";\nimport seedrandom from \"seedrandom\";\nimport { Generator, PreludeGenerator } from \"./utils/generator.js\";\nimport { emptyExpression, voidExpression } from \"./utils/internalizer.js\";\nimport { Environment, Functions, Join, Properties, To, Widen, Path } from \"./singletons.js\";\nimport type { ReactSymbolTypes } from \"./react/utils.js\";\nimport type { BabelNode, BabelNodeSourceLocation, BabelNodeLVal, BabelNodeStatement } from \"babel-types\";\nimport * as t from \"babel-types\";\n\nexport type BindingEntry = { hasLeaked: boolean, value: void | Value };\nexport type Bindings = Map<Binding, BindingEntry>;\nexport type EvaluationResult = Completion | Reference | Value;\nexport type PropertyBindings = Map<PropertyBinding, void | Descriptor>;\n\nexport type CreatedObjects = Set<ObjectValue>;\nexport type Effects = [EvaluationResult, Generator, Bindings, PropertyBindings, CreatedObjects];\n\nexport class Tracer {\n  beginEvaluateForEffects(state: any) {}\n  endEvaluateForEffects(state: any, effects: void | Effects) {}\n  detourCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    performCall: () => Value\n  ): void | Value {}\n  beforeCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue\n  ) {}\n  afterCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    result: void | Reference | Value | AbruptCompletion\n  ) {}\n}\n\nexport class ExecutionContext {\n  function: ?FunctionValue;\n  caller: ?ExecutionContext;\n  loc: ?BabelNodeSourceLocation;\n  ScriptOrModule: any;\n  realm: Realm;\n  variableEnvironment: LexicalEnvironment;\n  lexicalEnvironment: LexicalEnvironment;\n  isReadOnly: boolean;\n  isStrict: boolean;\n\n  setCaller(context: ExecutionContext): void {\n    this.caller = context;\n  }\n\n  setFunction(F: null | FunctionValue) {\n    if (F instanceof ECMAScriptSourceFunctionValue) this.isStrict = F.$Strict;\n    this.function = F;\n  }\n\n  setLocation(loc: null | BabelNodeSourceLocation) {\n    if (!loc) return;\n    this.loc = loc;\n  }\n\n  setRealm(realm: Realm): void {\n    this.realm = realm;\n  }\n\n  /*\n   Read-only envs disallow:\n   - creating bindings in their scope\n   - creating or modifying objects when they are current running context\n  */\n  setReadOnly(value: boolean): boolean {\n    let oldReadOnly = this.isReadOnly;\n    if (this.variableEnvironment) this.variableEnvironment.environmentRecord.isReadOnly = value;\n    if (this.lexicalEnvironment) this.lexicalEnvironment.environmentRecord.isReadOnly = value;\n    this.isReadOnly = value;\n    return oldReadOnly;\n  }\n\n  suspend(): void {\n    // TODO #712: suspend\n  }\n\n  resume(): Value {\n    // TODO #712: resume\n    return this.realm.intrinsics.undefined;\n  }\n}\n\nexport function construct_empty_effects(realm: Realm): Effects {\n  return [realm.intrinsics.empty, new Generator(realm), new Map(), new Map(), new Set()];\n}\n\nexport class Realm {\n  constructor(opts: RealmOptions) {\n    this.isReadOnly = false;\n    this.useAbstractInterpretation = !!opts.serialize || !!opts.residual || !!opts.check;\n    this.trackLeaks = !!opts.abstractEffectsInAdditionalFunctions;\n    this.ignoreLeakLogic = false;\n    this.isInPureTryStatement = false;\n    if (opts.mathRandomSeed !== undefined) {\n      this.mathRandomGenerator = seedrandom(opts.mathRandomSeed);\n    }\n    this.strictlyMonotonicDateNow = !!opts.strictlyMonotonicDateNow;\n\n    this.timeout = opts.timeout;\n    if (this.timeout) {\n      // We'll call Date.now for every this.timeoutCounterThreshold'th AST node.\n      // The threshold is there to reduce the cost of the surprisingly expensive Date.now call.\n      this.timeoutCounter = this.timeoutCounterThreshold = 1024;\n    }\n\n    this.start = Date.now();\n    this.compatibility = opts.compatibility || \"browser\";\n    this.maxStackDepth = opts.maxStackDepth || 225;\n    this.omitInvariants = !!opts.omitInvariants;\n    this.emitConcreteModel = !!opts.emitConcreteModel;\n\n    this.$TemplateMap = [];\n\n    if (this.useAbstractInterpretation) {\n      this.preludeGenerator = new PreludeGenerator(opts.debugNames, opts.uniqueSuffix);\n      this.pathConditions = [];\n      ObjectValue.setupTrackedPropertyAccessors(ObjectValue.trackedPropertyNames);\n      ObjectValue.setupTrackedPropertyAccessors(NativeFunctionValue.trackedPropertyNames);\n      ObjectValue.setupTrackedPropertyAccessors(ProxyValue.trackedPropertyNames);\n    }\n\n    this.tracers = [];\n\n    // These get initialized in construct_realm to avoid the dependency\n    this.intrinsics = ({}: any);\n    this.$GlobalObject = (({}: any): ObjectValue);\n    this.evaluators = (Object.create(null): any);\n    this.partialEvaluators = (Object.create(null): any);\n    this.$GlobalEnv = ((undefined: any): LexicalEnvironment);\n\n    this.react = {\n      abstractHints: new WeakMap(),\n      classComponentMetadata: new Map(),\n      currentOwner: undefined,\n      enabled: opts.reactEnabled || false,\n      output: opts.reactOutput || \"create-element\",\n      hoistableFunctions: new WeakMap(),\n      hoistableReactElements: new WeakMap(),\n      reactElements: new WeakSet(),\n      symbols: new Map(),\n    };\n\n    this.stripFlow = opts.stripFlow || false;\n\n    this.fbLibraries = {\n      other: new Map(),\n      react: undefined,\n      reactRelay: undefined,\n    };\n\n    this.errorHandler = opts.errorHandler;\n\n    this.globalSymbolRegistry = [];\n    this.activeLexicalEnvironments = new Set();\n    this._abstractValuesDefined = new Set(); // A set of nameStrings to ensure abstract values have unique names\n    this.debugNames = opts.debugNames;\n  }\n\n  start: number;\n  isReadOnly: boolean;\n  isStrict: boolean;\n  useAbstractInterpretation: boolean;\n  trackLeaks: boolean;\n  debugNames: void | boolean;\n  isInPureTryStatement: boolean; // TODO(1264): Remove this once we implement proper exception handling in abstract calls.\n  timeout: void | number;\n  mathRandomGenerator: void | (() => number);\n  strictlyMonotonicDateNow: boolean;\n  maxStackDepth: number;\n  omitInvariants: boolean;\n  ignoreLeakLogic: boolean;\n  emitConcreteModel: boolean;\n\n  modifiedBindings: void | Bindings;\n  modifiedProperties: void | PropertyBindings;\n  createdObjects: void | CreatedObjects;\n  createdObjectsTrackedForLeaks: void | CreatedObjects;\n  reportObjectGetOwnProperties: void | (ObjectValue => void);\n  reportPropertyAccess: void | (PropertyBinding => void);\n  savedCompletion: void | PossiblyNormalCompletion;\n\n  activeLexicalEnvironments: Set<LexicalEnvironment>;\n\n  // A list of abstract conditions that are known to be true in the current execution path.\n  // For example, the abstract condition of an if statement is known to be true inside its true branch.\n  pathConditions: Array<AbstractValue>;\n\n  currentLocation: ?BabelNodeSourceLocation;\n  nextContextLocation: ?BabelNodeSourceLocation;\n  contextStack: Array<ExecutionContext> = [];\n  $GlobalEnv: LexicalEnvironment;\n  intrinsics: Intrinsics;\n\n  react: {\n    // reactHints are generated to help improve the effeciency of the React reconciler when\n    // operating on a tree of React components. We can use reactHint to mark AbstractValues\n    // with extra data that helps us traverse through the tree that would otherwise not be possible\n    // (for example, when we use Relay's React containers with \"fb-www\" – which are AbstractObjectValues,\n    // we need to know what React component was passed to this AbstractObjectValue so we can visit it next)\n    abstractHints: WeakMap<AbstractValue | ObjectValue, ReactHint>,\n    classComponentMetadata: Map<ECMAScriptSourceFunctionValue, ClassComponentMetadata>,\n    currentOwner?: ObjectValue,\n    enabled: boolean,\n    hoistableFunctions: WeakMap<FunctionValue, boolean>,\n    hoistableReactElements: WeakMap<ObjectValue, boolean>,\n    output?: ReactOutputTypes,\n    reactElements: WeakSet<ObjectValue>,\n    symbols: Map<ReactSymbolTypes, SymbolValue>,\n  };\n  stripFlow: boolean;\n\n  fbLibraries: {\n    other: Map<string, AbstractValue>,\n    react: void | ObjectValue,\n    reactRelay: void | ObjectValue,\n  };\n\n  $GlobalObject: ObjectValue | AbstractObjectValue;\n  compatibility: Compatibility;\n\n  $TemplateMap: Array<{ $Strings: Array<string>, $Array: ObjectValue }>;\n\n  generator: void | Generator;\n  preludeGenerator: void | PreludeGenerator;\n  timeoutCounter: number;\n  timeoutCounterThreshold: number;\n  evaluators: {\n    [key: string]: (\n      ast: BabelNode,\n      strictCode: boolean,\n      env: LexicalEnvironment,\n      realm: Realm,\n      metadata?: any\n    ) => Value | Reference,\n  };\n  partialEvaluators: {\n    [key: string]: (\n      ast: BabelNode,\n      strictCode: boolean,\n      env: LexicalEnvironment,\n      realm: Realm,\n      metadata?: any\n    ) => [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>],\n  };\n  simplifyAndRefineAbstractValue: AbstractValue => Value;\n  simplifyAndRefineAbstractCondition: AbstractValue => Value;\n\n  tracers: Array<Tracer>;\n\n  MOBILE_JSC_VERSION = \"jsc-600-1-4-17\";\n\n  errorHandler: ?ErrorHandler;\n  objectCount = 0;\n  symbolCount = 867501803871088;\n  // Unique tag for identifying function body ast node. It is neeeded\n  // instead of ast node itself because we may perform ast tree deep clone\n  // during serialization which changes the ast identity.\n  functionBodyUniqueTagSeed = 1;\n\n  globalSymbolRegistry: Array<{ $Key: string, $Symbol: SymbolValue }>;\n\n  debuggerInstance: DebugServerType | void;\n\n  nextGeneratorId: number = 0;\n  _abstractValuesDefined: Set<string>;\n\n  // to force flow to type the annotations\n  isCompatibleWith(compatibility: Compatibility): boolean {\n    return compatibility === this.compatibility;\n  }\n\n  // Checks if there is a let binding at global scope with the given name\n  // returning it if so\n  getGlobalLetBinding(key: string): void | Value {\n    let globrec = this.$GlobalEnv.environmentRecord;\n    // GlobalEnv should have a GlobalEnvironmentRecord\n    invariant(globrec instanceof GlobalEnvironmentRecord);\n    let dclrec = globrec.$DeclarativeRecord;\n\n    try {\n      return dclrec.HasBinding(key) ? dclrec.GetBindingValue(key, false) : undefined;\n    } catch (e) {\n      if (e instanceof FatalError) return undefined;\n      throw e;\n    }\n  }\n\n  /*\n   Read only realms disallow:\n   - using console.log\n   - creating bindings in any existing scopes\n   - modifying object properties in any existing scopes\n   Setting a realm read-only sets all contained environments to read-only, but\n   all new environments (e.g. new ExecutionContexts) will be writeable.\n   */\n  setReadOnly(readOnlyValue: boolean) {\n    this.isReadOnly = readOnlyValue;\n    this.$GlobalEnv.environmentRecord.isReadOnly = readOnlyValue;\n    this.contextStack.forEach(ctx => {\n      ctx.setReadOnly(readOnlyValue);\n    });\n  }\n\n  testTimeout() {\n    let timeout = this.timeout;\n    if (timeout && !--this.timeoutCounter) {\n      this.timeoutCounter = this.timeoutCounterThreshold;\n      let total = Date.now() - this.start;\n      if (total > timeout) {\n        throw new FatalError(\"Timed out\");\n      }\n    }\n  }\n\n  hasRunningContext(): boolean {\n    return this.contextStack.length !== 0;\n  }\n\n  getRunningContext(): ExecutionContext {\n    let context = this.contextStack[this.contextStack.length - 1];\n    invariant(context, \"There's no running execution context\");\n    return context;\n  }\n\n  clearBlockBindings(modifiedBindings: void | Bindings, environmentRecord: DeclarativeEnvironmentRecord) {\n    if (modifiedBindings === undefined) return;\n    for (let b of modifiedBindings.keys())\n      if (environmentRecord.bindings[b.name] && environmentRecord.bindings[b.name] === b) modifiedBindings.delete(b);\n  }\n\n  clearBlockBindingsFromCompletion(completion: Completion, environmentRecord: DeclarativeEnvironmentRecord) {\n    if (completion instanceof PossiblyNormalCompletion) {\n      this.clearBlockBindings(completion.alternateEffects[2], environmentRecord);\n      this.clearBlockBindings(completion.consequentEffects[2], environmentRecord);\n      if (completion.savedEffects !== undefined) this.clearBlockBindings(completion.savedEffects[2], environmentRecord);\n      if (completion.alternate instanceof Completion)\n        this.clearBlockBindingsFromCompletion(completion.alternate, environmentRecord);\n      if (completion.consequent instanceof Completion)\n        this.clearBlockBindingsFromCompletion(completion.consequent, environmentRecord);\n    } else if (completion instanceof JoinedAbruptCompletions) {\n      this.clearBlockBindings(completion.alternateEffects[2], environmentRecord);\n      this.clearBlockBindings(completion.consequentEffects[2], environmentRecord);\n      if (completion.alternate instanceof Completion)\n        this.clearBlockBindingsFromCompletion(completion.alternate, environmentRecord);\n      if (completion.consequent instanceof Completion)\n        this.clearBlockBindingsFromCompletion(completion.consequent, environmentRecord);\n    }\n  }\n\n  // Call when a scope falls out of scope and should be destroyed.\n  // Clears the Bindings corresponding to the disappearing Scope from ModifiedBindings\n  onDestroyScope(lexicalEnvironment: LexicalEnvironment) {\n    invariant(this.activeLexicalEnvironments.has(lexicalEnvironment));\n    let modifiedBindings = this.modifiedBindings;\n    if (modifiedBindings) {\n      // Don't undo things to global scope because it's needed past its destruction point (for serialization)\n      let environmentRecord = lexicalEnvironment.environmentRecord;\n      if (environmentRecord instanceof DeclarativeEnvironmentRecord) {\n        this.clearBlockBindings(modifiedBindings, environmentRecord);\n        if (this.savedCompletion !== undefined)\n          this.clearBlockBindingsFromCompletion(this.savedCompletion, environmentRecord);\n      }\n    }\n\n    // Ensures if we call onDestroyScope too early, there will be a failure.\n    this.activeLexicalEnvironments.delete(lexicalEnvironment);\n    lexicalEnvironment.destroy();\n  }\n\n  pushContext(context: ExecutionContext): void {\n    if (this.contextStack.length >= this.maxStackDepth) {\n      throw new FatalError(\"Maximum stack depth exceeded\");\n    }\n    this.contextStack.push(context);\n  }\n\n  clearFunctionBindings(modifiedBindings: void | Bindings, funcVal: FunctionValue) {\n    if (modifiedBindings === undefined) return;\n    for (let b of modifiedBindings.keys()) {\n      if (b.environment.$FunctionObject === funcVal) modifiedBindings.delete(b);\n    }\n  }\n\n  clearFunctionBindingsFromCompletion(completion: Completion, funcVal: FunctionValue) {\n    if (completion instanceof PossiblyNormalCompletion) {\n      this.clearFunctionBindings(completion.alternateEffects[2], funcVal);\n      this.clearFunctionBindings(completion.consequentEffects[2], funcVal);\n      if (completion.savedEffects !== undefined) this.clearFunctionBindings(completion.savedEffects[2], funcVal);\n      if (completion.alternate instanceof Completion)\n        this.clearFunctionBindingsFromCompletion(completion.alternate, funcVal);\n      if (completion.consequent instanceof Completion)\n        this.clearFunctionBindingsFromCompletion(completion.consequent, funcVal);\n    } else if (completion instanceof JoinedAbruptCompletions) {\n      this.clearFunctionBindings(completion.alternateEffects[2], funcVal);\n      this.clearFunctionBindings(completion.consequentEffects[2], funcVal);\n      if (completion.alternate instanceof Completion)\n        this.clearFunctionBindingsFromCompletion(completion.alternate, funcVal);\n      if (completion.consequent instanceof Completion)\n        this.clearFunctionBindingsFromCompletion(completion.consequent, funcVal);\n    }\n  }\n\n  popContext(context: ExecutionContext): void {\n    let funcVal = context.function;\n    if (funcVal) {\n      this.clearFunctionBindings(this.modifiedBindings, funcVal);\n      if (this.savedCompletion !== undefined) this.clearFunctionBindingsFromCompletion(this.savedCompletion, funcVal);\n    }\n    let c = this.contextStack.pop();\n    invariant(c === context);\n  }\n\n  wrapInGlobalEnv<T>(callback: () => T): T {\n    let context = new ExecutionContext();\n    context.isStrict = this.isStrict;\n    context.lexicalEnvironment = this.$GlobalEnv;\n    context.variableEnvironment = this.$GlobalEnv;\n    context.realm = this;\n\n    this.pushContext(context);\n    try {\n      return callback();\n    } finally {\n      this.popContext(context);\n    }\n  }\n\n  assignToGlobal(name: BabelNodeLVal, value: Value) {\n    this.wrapInGlobalEnv(() => this.$GlobalEnv.assignToGlobal(name, value));\n  }\n\n  deleteGlobalBinding(name: string) {\n    this.$GlobalEnv.environmentRecord.DeleteBinding(name);\n  }\n\n  // Evaluate a context as if it won't have any side-effects outside of any objects\n  // that it created itself. This promises that any abstract functions inside of it\n  // also won't have effects on any objects or bindings that weren't created in this\n  // call.\n  evaluatePure<T>(f: () => T) {\n    if (!this.trackLeaks) {\n      return f();\n    }\n    let saved_createdObjectsTrackedForLeaks = this.createdObjectsTrackedForLeaks;\n    // Track all objects (including function closures) created during\n    // this call. This will be used to make the assumption that every\n    // *other* object is unchanged (pure). These objects are marked\n    // as leaked if they're passed to abstract functions.\n    this.createdObjectsTrackedForLeaks = new Set();\n    try {\n      return f();\n    } finally {\n      this.createdObjectsTrackedForLeaks = saved_createdObjectsTrackedForLeaks;\n    }\n  }\n\n  isInPureScope() {\n    return !!this.createdObjectsTrackedForLeaks;\n  }\n\n  evaluateWithoutLeakLogic(f: () => Value): Value {\n    invariant(!this.ignoreLeakLogic, \"Nesting evaluateWithoutLeakLogic() calls is not supported.\");\n    this.ignoreLeakLogic = true;\n    try {\n      return f();\n    } finally {\n      this.ignoreLeakLogic = false;\n    }\n  }\n\n  // Evaluate some code that might generate temporal values knowing that it might end in an abrupt\n  // completion. We only need to support ThrowCompletion for now but this can be expanded to support other\n  // abrupt completions.\n  evaluateWithPossibleThrowCompletion(f: () => Value, thrownTypes: TypesDomain, thrownValues: ValuesDomain): Value {\n    // The cases when we need this are only when we might invoke unknown code such as abstract\n    // funtions, getters, custom coercion etc. It is possible we can use this in other cases\n    // where something might throw a built-in error but can never issue arbitrary code such as\n    // calling something that might not be a function. For now we only use it in pure functions.\n    invariant(this.isInPureScope(), \"only abstract abrupt completion in pure functions\");\n\n    // TODO(1264): We should create a new generator for this scope and wrap it in a try/catch.\n    // We could use the outcome of that as the join condition for a PossiblyNormalCompletion.\n    // We should then compose that with the saved completion and move on to the normal route.\n    // Currently we just issue a recoverable error instead if this might matter.\n    let value = f();\n    if (this.isInPureTryStatement) {\n      let diag = new CompilerDiagnostic(\n        \"Possible throw inside try/catch is not yet supported\",\n        this.currentLocation,\n        \"PP0021\",\n        \"RecoverableError\"\n      );\n      if (this.handleError(diag) !== \"Recover\") throw new FatalError();\n    }\n    return value;\n  }\n\n  // Evaluate the given ast in a sandbox and return the evaluation results\n  // in the form of a completion, a code generator, a map of changed variable\n  // bindings and a map of changed property bindings.\n  evaluateNodeForEffects(\n    ast: BabelNode,\n    strictCode: boolean,\n    env: LexicalEnvironment,\n    state?: any,\n    generatorName?: string\n  ): Effects {\n    return this.evaluateForEffects(() => env.evaluateCompletionDeref(ast, strictCode), state, generatorName);\n  }\n\n  evaluateForEffectsInGlobalEnv(func: () => Value, state?: any, generatorName?: string): Effects {\n    return this.wrapInGlobalEnv(() => this.evaluateForEffects(func, state, generatorName));\n  }\n\n  // NB: does not apply generators because there's no way to cleanly revert them.\n  // func should not return undefined\n  withEffectsAppliedInGlobalEnv<T>(func: Effects => T, effects: Effects): T {\n    let result: T;\n    this.evaluateForEffectsInGlobalEnv(() => {\n      try {\n        this.applyEffects(effects);\n        result = func(effects);\n        return this.intrinsics.undefined;\n      } finally {\n        this.restoreBindings(effects[2]);\n        this.restoreProperties(effects[3]);\n      }\n    });\n    invariant(result !== undefined, \"If we get here, func must have returned undefined.\");\n    return result;\n  }\n\n  evaluateNodeForEffectsInGlobalEnv(node: BabelNode, state?: any, generatorName?: string): Effects {\n    return this.wrapInGlobalEnv(() => this.evaluateNodeForEffects(node, false, this.$GlobalEnv, state, generatorName));\n  }\n\n  partiallyEvaluateNodeForEffects(\n    ast: BabelNode,\n    strictCode: boolean,\n    env: LexicalEnvironment\n  ): [Effects, BabelNode, Array<BabelNodeStatement>] {\n    let nodeAst, nodeIO;\n    function partialEval() {\n      let result;\n      [result, nodeAst, nodeIO] = env.partiallyEvaluateCompletionDeref(ast, strictCode);\n      return result;\n    }\n    let effects = this.evaluateForEffects(partialEval);\n    invariant(nodeAst !== undefined && nodeIO !== undefined);\n    return [effects, nodeAst, nodeIO];\n  }\n\n  evaluateForEffects(f: () => Completion | Value, state: any, generatorName: void | string): Effects {\n    // Save old state and set up empty state for ast\n    let [savedBindings, savedProperties] = this.getAndResetModifiedMaps();\n    let saved_generator = this.generator;\n    let saved_createdObjects = this.createdObjects;\n    let saved_completion = this.savedCompletion;\n    this.generator = new Generator(this, generatorName);\n    this.createdObjects = new Set();\n    this.savedCompletion = undefined; // while in this call, we only explore the normal path.\n\n    let result;\n    try {\n      for (let t1 of this.tracers) t1.beginEvaluateForEffects(state);\n\n      let c;\n      try {\n        try {\n          c = f();\n          if (c instanceof Reference) c = Environment.GetValue(this, c);\n        } catch (e) {\n          if (e instanceof AbruptCompletion) c = e;\n          else throw e;\n        }\n        // This is a join point for the normal branch of a PossiblyNormalCompletion.\n        if (c instanceof Value || c instanceof AbruptCompletion) c = Functions.incorporateSavedCompletion(this, c);\n        invariant(c !== undefined);\n        if (c instanceof PossiblyNormalCompletion) {\n          // The current state may have advanced since the time control forked into the various paths recorded in c.\n          // Update the normal path and restore the global state to what it was at the time of the fork.\n          let subsequentEffects = this.getCapturedEffects(c, c.value);\n          invariant(subsequentEffects !== undefined);\n          this.stopEffectCaptureAndUndoEffects(c);\n          Join.updatePossiblyNormalCompletionWithSubsequentEffects(this, c, subsequentEffects);\n          this.savedCompletion = undefined;\n        }\n\n        invariant(this.generator !== undefined);\n        invariant(this.modifiedBindings !== undefined);\n        invariant(this.modifiedProperties !== undefined);\n        invariant(this.createdObjects !== undefined);\n        let astGenerator = this.generator;\n        let astBindings = this.modifiedBindings;\n        let astProperties = this.modifiedProperties;\n        let astCreatedObjects = this.createdObjects;\n\n        // Return the captured state changes and evaluation result\n        result = [c, astGenerator, astBindings, astProperties, astCreatedObjects];\n        return result;\n      } finally {\n        // Roll back the state changes\n        if (this.savedCompletion !== undefined) this.stopEffectCaptureAndUndoEffects(this.savedCompletion);\n        if (result !== undefined) {\n          this.restoreBindings(result[2]);\n          this.restoreProperties(result[3]);\n        } else {\n          this.restoreBindings(this.modifiedBindings);\n          this.restoreProperties(this.modifiedProperties);\n        }\n        this.generator = saved_generator;\n        this.modifiedBindings = savedBindings;\n        this.modifiedProperties = savedProperties;\n        this.createdObjects = saved_createdObjects;\n        this.savedCompletion = saved_completion;\n      }\n    } finally {\n      for (let t2 of this.tracers) t2.endEvaluateForEffects(state, result);\n    }\n  }\n\n  evaluateWithUndo(f: () => Value, defaultValue: Value = this.intrinsics.undefined): Value {\n    if (!this.useAbstractInterpretation) return f();\n    let oldErrorHandler = this.errorHandler;\n    this.errorHandler = d => {\n      if (d.severity === \"Information\" || d.severity === \"Warning\") return \"Recover\";\n      return \"Fail\";\n    };\n    try {\n      let effects = this.evaluateForEffects(() => {\n        try {\n          return f();\n        } catch (e) {\n          if (e instanceof Completion) {\n            return defaultValue;\n          } else if (e instanceof FatalError) {\n            return defaultValue;\n          } else {\n            throw e;\n          }\n        }\n      });\n      return effects[0] instanceof Value ? effects[0] : defaultValue;\n    } finally {\n      this.errorHandler = oldErrorHandler;\n    }\n  }\n\n  evaluateWithUndoForDiagnostic(f: () => Value): CompilerDiagnostic | Value {\n    if (!this.useAbstractInterpretation) return f();\n    let savedHandler = this.errorHandler;\n    let diagnostic;\n    try {\n      this.errorHandler = d => {\n        diagnostic = d;\n        return \"Fail\";\n      };\n      let effects = this.evaluateForEffects(f);\n      this.applyEffects(effects);\n      let resultVal = effects[0];\n      if (resultVal instanceof AbruptCompletion) throw resultVal;\n      if (resultVal instanceof PossiblyNormalCompletion) {\n        // in this case one of the branches may complete abruptly, which means that\n        // not all control flow branches join into one flow at this point.\n        // Consequently we have to continue tracking changes until the point where\n        // all the branches come together into one.\n        resultVal = this.composeWithSavedCompletion(resultVal);\n      }\n      invariant(resultVal instanceof Value);\n      return resultVal;\n    } catch (e) {\n      if (diagnostic !== undefined) return diagnostic;\n      throw e;\n    } finally {\n      this.errorHandler = savedHandler;\n    }\n  }\n\n  evaluateForFixpointEffects(\n    loopContinueTest: () => Value,\n    loopBody: () => EvaluationResult\n  ): void | [Effects, Effects] {\n    try {\n      let effects1 = this.evaluateForEffects((loopBody: any));\n      while (true) {\n        this.restoreBindings(effects1[2]);\n        this.restoreProperties(effects1[3]);\n        let effects2 = this.evaluateForEffects(() => {\n          let test = loopContinueTest();\n          if (!(test instanceof AbstractValue)) throw new FatalError(\"loop terminates before fixed point\");\n          return (loopBody(): any);\n        });\n        this.restoreBindings(effects1[2]);\n        this.restoreProperties(effects1[3]);\n        if (Widen.containsEffects(effects1, effects2)) {\n          // effects1 includes every value present in effects2, so doing another iteration using effects2 will not\n          // result in any more values being added to abstract domains and hence a fixpoint has been reached.\n          // Generate code using effects2 because its expressions have not been widened away.\n          let [, gen, bindings2, pbindings2] = effects2;\n          this._emitPropertAssignments(gen, pbindings2);\n          this._emitLocalAssignments(gen, bindings2);\n          return [effects1, effects2];\n        }\n        effects1 = Widen.widenEffects(this, effects1, effects2);\n      }\n    } catch (e) {\n      return undefined;\n    }\n  }\n\n  // populate the loop body generator with assignments that will update the phiNodes\n  _emitLocalAssignments(gen: Generator, bindings: Bindings) {\n    let tvalFor: Map<any, AbstractValue> = new Map();\n    bindings.forEach((binding, key, map) => {\n      let val = binding.value;\n      if (val instanceof AbstractValue) {\n        invariant(val._buildNode !== undefined);\n        let tval = gen.derive(val.types, val.values, [val], ([n]) => n, {\n          skipInvariant: true,\n        });\n        tvalFor.set(key, tval);\n      }\n    });\n    bindings.forEach((binding, key, map) => {\n      let val = binding.value;\n      if (val instanceof AbstractValue) {\n        let phiNode = key.phiNode;\n        let tval = tvalFor.get(key);\n        invariant(tval !== undefined);\n        gen.emitStatement([tval], ([v]) => {\n          invariant(phiNode !== undefined);\n          let id = phiNode.buildNode([]);\n          return t.expressionStatement(t.assignmentExpression(\"=\", (id: any), v));\n        });\n      }\n    });\n  }\n\n  // populate the loop body generator with assignments that will update properties modified inside the loop\n  _emitPropertAssignments(gen: Generator, pbindings: PropertyBindings) {\n    function isSelfReferential(value: Value, pathNode: void | AbstractValue): boolean {\n      if (value === pathNode) return true;\n      if (value instanceof AbstractValue && pathNode !== undefined) {\n        for (let v of value.args) {\n          if (isSelfReferential(v, pathNode)) return true;\n        }\n      }\n      return false;\n    }\n\n    let tvalFor: Map<any, AbstractValue> = new Map();\n    pbindings.forEach((val, key, map) => {\n      let value = val && val.value;\n      if (value instanceof AbstractValue) {\n        invariant(value._buildNode !== undefined);\n        let tval = gen.derive(\n          value.types,\n          value.values,\n          [key.object, value],\n          ([o, n]) => {\n            invariant(value instanceof Value);\n            if (typeof key.key === \"string\" && value.mightHaveBeenDeleted() && isSelfReferential(value, key.pathNode)) {\n              let inTest = t.binaryExpression(\"in\", t.stringLiteral(key.key), o);\n              let addEmpty = t.conditionalExpression(inTest, n, emptyExpression);\n              n = t.logicalExpression(\"||\", n, addEmpty);\n            }\n            return n;\n          },\n          {\n            skipInvariant: true,\n          }\n        );\n        tvalFor.set(key, tval);\n      }\n    });\n    pbindings.forEach((val, key, map) => {\n      let path = key.pathNode;\n      let tval = tvalFor.get(key);\n      invariant(val !== undefined);\n      let value = val.value;\n      invariant(value instanceof Value);\n      let mightHaveBeenDeleted = value.mightHaveBeenDeleted();\n      let mightBeUndefined = value.mightBeUndefined();\n      if (typeof key.key === \"string\") {\n        gen.emitStatement([key.object, tval || value, this.intrinsics.empty], ([o, v, e]) => {\n          invariant(path !== undefined);\n          let lh = path.buildNode([o, t.identifier(key.key)]);\n          let r = t.expressionStatement(t.assignmentExpression(\"=\", (lh: any), v));\n          if (mightHaveBeenDeleted) {\n            // If v === __empty || (v === undefined  && !(key.key in o))  then delete it\n            let emptyTest = t.binaryExpression(\"===\", v, e);\n            let undefinedTest = t.binaryExpression(\"===\", v, voidExpression);\n            let inTest = t.unaryExpression(\"!\", t.binaryExpression(\"in\", t.stringLiteral(key.key), o));\n            let guard = t.logicalExpression(\"||\", emptyTest, t.logicalExpression(\"&&\", undefinedTest, inTest));\n            let deleteIt = t.expressionStatement(t.unaryExpression(\"delete\", (lh: any)));\n            return t.ifStatement(mightBeUndefined ? emptyTest : guard, deleteIt, r);\n          }\n          return r;\n        });\n      } else {\n        gen.emitStatement([key.object, key.key, tval || value, this.intrinsics.empty], ([o, p, v, e]) => {\n          invariant(path !== undefined);\n          let lh = path.buildNode([o, p]);\n          return t.expressionStatement(t.assignmentExpression(\"=\", (lh: any), v));\n        });\n      }\n    });\n  }\n\n  composeEffects(priorEffects: Effects, subsequentEffects: Effects): Effects {\n    let [, pg, pb, pp, po] = priorEffects;\n    let [sc, sg, sb, sp, so] = subsequentEffects;\n    let result = construct_empty_effects(this);\n    let [, , rb, rp, ro] = result;\n\n    result[0] = sc;\n\n    result[1] = Join.composeGenerators(this, pg || result[1], sg);\n\n    if (pb) {\n      pb.forEach((val, key, m) => rb.set(key, val));\n    }\n    sb.forEach((val, key, m) => rb.set(key, val));\n\n    if (pp) {\n      pp.forEach((desc, propertyBinding, m) => rp.set(propertyBinding, desc));\n    }\n    sp.forEach((val, key, m) => rp.set(key, val));\n\n    if (po) {\n      po.forEach((ob, a) => ro.add(ob));\n    }\n    so.forEach((ob, a) => ro.add(ob));\n\n    return result;\n  }\n\n  updateAbruptCompletions(priorEffects: Effects, c: PossiblyNormalCompletion) {\n    if (c.consequent instanceof AbruptCompletion) {\n      c.consequentEffects = this.composeEffects(priorEffects, c.consequentEffects);\n      let alternate = c.alternate;\n      if (alternate instanceof PossiblyNormalCompletion) this.updateAbruptCompletions(priorEffects, alternate);\n    } else {\n      invariant(c.alternate instanceof AbruptCompletion);\n      c.alternateEffects = this.composeEffects(priorEffects, c.alternateEffects);\n      let consequent = c.consequent;\n      if (consequent instanceof PossiblyNormalCompletion) this.updateAbruptCompletions(priorEffects, consequent);\n    }\n  }\n\n  composeWithSavedCompletion(completion: PossiblyNormalCompletion): Value {\n    if (this.savedCompletion === undefined) {\n      this.savedCompletion = completion;\n      this.savedCompletion.savedPathConditions = this.pathConditions;\n      this.captureEffects(completion);\n    } else {\n      this.savedCompletion = Join.composePossiblyNormalCompletions(this, this.savedCompletion, completion);\n    }\n    if (completion.consequent instanceof AbruptCompletion) {\n      Path.pushInverseAndRefine(completion.joinCondition);\n      if (completion.alternate instanceof PossiblyNormalCompletion) {\n        completion.alternate.pathConditions.forEach(Path.pushAndRefine);\n      }\n    } else if (completion.alternate instanceof AbruptCompletion) {\n      Path.pushAndRefine(completion.joinCondition);\n      if (completion.consequent instanceof PossiblyNormalCompletion) {\n        completion.consequent.pathConditions.forEach(Path.pushAndRefine);\n      }\n    }\n    return completion.value;\n  }\n\n  incorporatePriorSavedCompletion(priorCompletion: void | PossiblyNormalCompletion) {\n    if (priorCompletion === undefined) return;\n    if (this.savedCompletion === undefined) {\n      this.savedCompletion = priorCompletion;\n      this.captureEffects(priorCompletion);\n    } else {\n      invariant(priorCompletion.savedEffects !== undefined);\n      let savedEffects = this.savedCompletion.savedEffects;\n      invariant(savedEffects !== undefined);\n      this.restoreBindings(savedEffects[2]);\n      this.restoreProperties(savedEffects[3]);\n      Join.updatePossiblyNormalCompletionWithSubsequentEffects(this, priorCompletion, savedEffects);\n      this.restoreBindings(savedEffects[2]);\n      this.restoreProperties(savedEffects[3]);\n      invariant(this.savedCompletion !== undefined);\n      this.savedCompletion.savedEffects = undefined;\n      this.savedCompletion = Join.composePossiblyNormalCompletions(this, priorCompletion, this.savedCompletion);\n    }\n  }\n\n  captureEffects(completion: PossiblyNormalCompletion) {\n    if (completion.savedEffects !== undefined) {\n      // Already called captureEffects, just carry on\n      return;\n    }\n    completion.savedEffects = [\n      this.intrinsics.undefined,\n      (this.generator: any),\n      (this.modifiedBindings: any),\n      (this.modifiedProperties: any),\n      (this.createdObjects: any),\n    ];\n    this.generator = new Generator(this);\n    this.modifiedBindings = new Map();\n    this.modifiedProperties = new Map();\n    this.createdObjects = new Set();\n  }\n\n  getCapturedEffects(completion: PossiblyNormalCompletion, v?: Value): void | Effects {\n    if (completion.savedEffects === undefined) return undefined;\n    if (v === undefined) v = this.intrinsics.undefined;\n    invariant(this.generator !== undefined);\n    invariant(this.modifiedBindings !== undefined);\n    invariant(this.modifiedProperties !== undefined);\n    invariant(this.createdObjects !== undefined);\n    return [v, this.generator, this.modifiedBindings, this.modifiedProperties, this.createdObjects];\n  }\n\n  stopEffectCapture(completion: PossiblyNormalCompletion) {\n    let e = this.getCapturedEffects(completion);\n    if (e !== undefined) {\n      this.stopEffectCaptureAndUndoEffects(completion);\n      this.applyEffects(e);\n    }\n  }\n\n  stopEffectCaptureAndUndoEffects(completion: PossiblyNormalCompletion) {\n    // Roll back the state changes\n    this.restoreBindings(this.modifiedBindings);\n    this.restoreProperties(this.modifiedProperties);\n\n    // Restore saved state\n    if (completion.savedEffects !== undefined) {\n      let [c, g, b, p, o] = completion.savedEffects;\n      c;\n      completion.savedEffects = undefined;\n      this.generator = g;\n      this.modifiedBindings = b;\n      this.modifiedProperties = p;\n      this.createdObjects = o;\n    } else {\n      invariant(false);\n    }\n  }\n\n  // Apply the given effects to the global state\n  applyEffects(effects: Effects, leadingComment: string = \"\") {\n    let [, generator, bindings, properties, createdObjects] = effects;\n\n    // Add generated code for property modifications\n    this.appendGenerator(generator, leadingComment);\n\n    // Restore bindings\n    this.restoreBindings(bindings);\n    this.restoreProperties(properties);\n\n    // track bindings\n    let realmModifiedBindings = this.modifiedBindings;\n    if (realmModifiedBindings !== undefined) {\n      bindings.forEach((val, key, m) => {\n        invariant(realmModifiedBindings !== undefined);\n        if (!realmModifiedBindings.has(key)) {\n          realmModifiedBindings.set(key, val);\n        }\n      });\n    }\n    let realmModifiedProperties = this.modifiedProperties;\n    if (realmModifiedProperties !== undefined) {\n      properties.forEach((desc, propertyBinding, m) => {\n        invariant(realmModifiedProperties !== undefined);\n        if (!realmModifiedProperties.has(propertyBinding)) {\n          realmModifiedProperties.set(propertyBinding, desc);\n        }\n      });\n    }\n\n    // add created objects\n    if (createdObjects.size > 0) {\n      let realmCreatedObjects = this.createdObjects;\n      if (realmCreatedObjects === undefined) this.createdObjects = new Set(createdObjects);\n      else {\n        createdObjects.forEach((ob, a) => {\n          invariant(realmCreatedObjects !== undefined);\n          realmCreatedObjects.add(ob);\n        });\n      }\n    }\n  }\n\n  outputToConsole(method: \"log\" | \"warn\" | \"error\", args: Array<string | ConcreteValue>): void {\n    if (this.isReadOnly) {\n      // This only happens during speculative execution and is reported elsewhere\n      throw new FatalError(\"Trying to create console output in read-only realm\");\n    }\n    if (this.useAbstractInterpretation) {\n      invariant(this.generator !== undefined);\n      this.generator.emitConsoleLog(method, args);\n    } else {\n      console[method](getString(this, args));\n    }\n\n    function getString(realm: Realm, values: Array<string | ConcreteValue>) {\n      let res = \"\";\n      while (values.length) {\n        let next = values.shift();\n        let nextString = To.ToString(realm, next);\n        res += nextString;\n      }\n      return res;\n    }\n  }\n\n  // Record the current value of binding in this.modifiedBindings unless\n  // there is already an entry for binding.\n  recordModifiedBinding(binding: Binding): Binding {\n    if (binding.environment.isReadOnly) {\n      // This only happens during speculative execution and is reported elsewhere\n      throw new FatalError(\"Trying to modify a binding in read-only realm\");\n    }\n    if (this.modifiedBindings !== undefined && !this.modifiedBindings.has(binding))\n      this.modifiedBindings.set(binding, {\n        hasLeaked: binding.hasLeaked,\n        value: binding.value,\n      });\n    return binding;\n  }\n\n  callReportObjectGetOwnProperties(ob: ObjectValue): void {\n    if (this.reportObjectGetOwnProperties !== undefined) {\n      this.reportObjectGetOwnProperties(ob);\n    }\n  }\n\n  callReportPropertyAccess(binding: PropertyBinding): void {\n    if (this.reportPropertyAccess !== undefined) {\n      this.reportPropertyAccess(binding);\n    }\n  }\n\n  // Record the current value of binding in this.modifiedProperties unless\n  // there is already an entry for binding.\n  recordModifiedProperty(binding: void | PropertyBinding): void {\n    if (binding === undefined) return;\n    if (this.isReadOnly && (this.getRunningContext().isReadOnly || !this.isNewObject(binding.object))) {\n      // This only happens during speculative execution and is reported elsewhere\n      throw new FatalError(\"Trying to modify a property in read-only realm\");\n    }\n    this.callReportPropertyAccess(binding);\n    if (this.modifiedProperties !== undefined && !this.modifiedProperties.has(binding)) {\n      this.modifiedProperties.set(binding, cloneDescriptor(binding.descriptor));\n    }\n  }\n\n  isNewObject(object: AbstractObjectValue | ObjectValue): boolean {\n    if (object instanceof AbstractObjectValue) return false;\n    return this.createdObjects === undefined || this.createdObjects.has(object);\n  }\n\n  recordNewObject(object: ObjectValue): void {\n    if (this.createdObjects !== undefined) {\n      this.createdObjects.add(object);\n    }\n    if (this.createdObjectsTrackedForLeaks !== undefined) {\n      this.createdObjectsTrackedForLeaks.add(object);\n    }\n  }\n\n  // Returns the current values of modifiedBindings and modifiedProperties\n  // and then assigns new empty maps to them.\n  getAndResetModifiedMaps(): [void | Bindings, void | PropertyBindings] {\n    let result = [this.modifiedBindings, this.modifiedProperties];\n    this.modifiedBindings = new Map();\n    this.modifiedProperties = new Map();\n    return result;\n  }\n\n  // Restores each Binding in the given map to the value it\n  // had when it was entered into the map and updates the map to record\n  // the value the Binding had just before the call to this method.\n  restoreBindings(modifiedBindings: void | Bindings) {\n    if (modifiedBindings === undefined) return;\n    modifiedBindings.forEach(({ hasLeaked, value }, binding, m) => {\n      let l = binding.hasLeaked;\n      let v = binding.value;\n      binding.hasLeaked = hasLeaked;\n      binding.value = value;\n      m.set(binding, {\n        hasLeaked: l,\n        value: v,\n      });\n    });\n  }\n\n  // Restores each PropertyBinding in the given map to the value it\n  // had when it was entered into the map and updates the map to record\n  // the value the Binding had just before the call to this method.\n  restoreProperties(modifiedProperties: void | PropertyBindings) {\n    if (modifiedProperties === undefined) return;\n    modifiedProperties.forEach((desc, propertyBinding, m) => {\n      let d = propertyBinding.descriptor;\n      propertyBinding.descriptor = desc;\n      m.set(propertyBinding, d);\n    });\n  }\n\n  // Provide the realm with maps in which to track modifications.\n  // A map can be set to undefined if no tracking is required.\n  setModifiedMaps(modifiedBindings: void | Bindings, modifiedProperties: void | PropertyBindings) {\n    this.modifiedBindings = modifiedBindings;\n    this.modifiedProperties = modifiedProperties;\n  }\n\n  rebuildObjectProperty(object: Value, key: string, propertyValue: Value, path: string) {\n    if (!(propertyValue instanceof AbstractValue)) return;\n    if (propertyValue.kind === \"abstractConcreteUnion\") {\n      let absVal = propertyValue.args.find(e => e instanceof AbstractValue);\n      invariant(absVal instanceof AbstractValue);\n      propertyValue = absVal;\n    }\n    if (!propertyValue.isIntrinsic()) {\n      propertyValue.intrinsicName = `${path}.${key}`;\n      propertyValue.kind = \"rebuiltProperty\";\n      propertyValue.args = [object];\n      propertyValue._buildNode = ([node]) => t.memberExpression(node, t.identifier(key));\n      this.rebuildNestedProperties(propertyValue, propertyValue.intrinsicName);\n    }\n  }\n\n  rebuildNestedProperties(abstractValue: AbstractValue | UndefinedValue, path: string) {\n    if (!(abstractValue instanceof AbstractObjectValue)) return;\n    if (abstractValue.values.isTop()) return;\n    let template = abstractValue.getTemplate();\n    invariant(!template.intrinsicName || template.intrinsicName === path);\n    template.intrinsicName = path;\n    template.intrinsicNameGenerated = true;\n    for (let [key, binding] of template.properties) {\n      if (binding === undefined || binding.descriptor === undefined) continue; // deleted\n      invariant(binding.descriptor !== undefined);\n      let value = binding.descriptor.value;\n      Properties.ThrowIfMightHaveBeenDeleted(value);\n      if (value === undefined) {\n        AbstractValue.reportIntrospectionError(abstractValue, key);\n        throw new FatalError();\n      }\n      invariant(value instanceof Value);\n      this.rebuildObjectProperty(abstractValue, key, value, path);\n    }\n  }\n\n  createExecutionContext(): ExecutionContext {\n    let context = new ExecutionContext();\n\n    let loc = this.nextContextLocation;\n    if (loc) {\n      context.setLocation(loc);\n      this.nextContextLocation = null;\n    }\n\n    return context;\n  }\n\n  setNextExecutionContextLocation(loc: ?BabelNodeSourceLocation) {\n    if (!loc) return;\n\n    //if (this.nextContextLocation) {\n    //  throw new ThrowCompletion(\n    //    Construct(this, this.intrinsics.TypeError, [new StringValue(this, \"Already have a context location that we haven't used yet\")])\n    //  );\n    //} else {\n    this.nextContextLocation = loc;\n    //}\n  }\n\n  reportIntrospectionError(message?: void | string | StringValue) {\n    if (message === undefined) message = \"\";\n    if (typeof message === \"string\") message = new StringValue(this, message);\n    invariant(message instanceof StringValue);\n    this.nextContextLocation = this.currentLocation;\n    let error = new CompilerDiagnostic(message.value, this.currentLocation, \"PP0001\", \"FatalError\");\n    this.handleError(error);\n  }\n\n  createErrorThrowCompletion(type: NativeFunctionValue, message?: void | string | StringValue): ThrowCompletion {\n    invariant(type !== this.intrinsics.__IntrospectionError);\n    if (message === undefined) message = \"\";\n    if (typeof message === \"string\") message = new StringValue(this, message);\n    invariant(message instanceof StringValue);\n    this.nextContextLocation = this.currentLocation;\n    return new ThrowCompletion(Construct(this, type, [message]), this.currentLocation);\n  }\n\n  appendGenerator(generator: Generator, leadingComment: string = \"\"): void {\n    let realmGenerator = this.generator;\n    if (realmGenerator === undefined) {\n      invariant(generator.empty());\n      return;\n    }\n    realmGenerator.appendGenerator(generator, leadingComment);\n  }\n\n  // Pass the error to the realm's error-handler\n  // Return value indicates whether the caller should try to recover from the error or not.\n  handleError(diagnostic: CompilerDiagnostic): ErrorHandlerResult {\n    if (!diagnostic.callStack && this.contextStack.length > 0) {\n      let error = Construct(this, this.intrinsics.Error);\n      let stack = error.$Get(\"stack\", error);\n      if (stack instanceof StringValue) diagnostic.callStack = stack.value;\n    }\n    // Default behaviour is to bail on the first error\n    let errorHandler = this.errorHandler;\n    if (!errorHandler) {\n      let msg = `${diagnostic.errorCode}: ${diagnostic.message}`;\n      if (diagnostic.location) {\n        let loc_start = diagnostic.location.start;\n        let loc_end = diagnostic.location.end;\n        msg += ` at ${loc_start.line}:${loc_start.column} to ${loc_end.line}:${loc_end.column}`;\n      }\n      try {\n        switch (diagnostic.severity) {\n          case \"Information\":\n            console.log(`Info: ${msg}`);\n            return \"Recover\";\n          case \"Warning\":\n            console.warn(`Warn: ${msg}`);\n            return \"Recover\";\n          case \"RecoverableError\":\n            console.error(`Error: ${msg}`);\n            return \"Fail\";\n          case \"FatalError\":\n            console.error(`Fatal Error: ${msg}`);\n            return \"Fail\";\n          default:\n            invariant(false, \"Unexpected error type\");\n        }\n      } finally {\n        console.log(diagnostic.callStack);\n      }\n    }\n    return errorHandler(diagnostic);\n  }\n\n  saveNameString(nameString: string): void {\n    this._abstractValuesDefined.add(nameString);\n  }\n\n  isNameStringUnique(nameString: string): boolean {\n    return !this._abstractValuesDefined.has(nameString);\n  }\n}\n"]}