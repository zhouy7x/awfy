'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  var _matchPrototypeObject = matchPrototypeObjectAssignment(node),
      className = _matchPrototypeObject.className,
      properties = _matchPrototypeObject.properties;

  if (className) {
    return {
      className: className,
      methods: properties.map(function (prop) {
        return {
          propertyNode: prop,
          methodName: prop.key.name,
          methodNode: prop.value
        };
      })
    };
  }
};

var _matchesAst = require('../../utils/matchesAst');

var _isFunctionProperty = require('./isFunctionProperty');

var _isFunctionProperty2 = _interopRequireDefault(_isFunctionProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var matchPrototypeObjectAssignment = (0, _matchesAst.matchesAst)({
  type: 'ExpressionStatement',
  expression: {
    type: 'AssignmentExpression',
    left: {
      type: 'MemberExpression',
      computed: false,
      object: {
        type: 'Identifier',
        name: (0, _matchesAst.extract)('className')
      },
      property: {
        type: 'Identifier',
        name: 'prototype'
      }
    },
    operator: '=',
    right: {
      type: 'ObjectExpression',
      properties: (0, _matchesAst.extract)('properties', function (props) {
        return props.every(_isFunctionProperty2.default);
      })
    }
  }
});

/**
 * Matches: <className>.prototype = {
 *              <methodName>: <methodNode>,
 *              ...
 *          };
 *
 * When node matches returns the extracted fields:
 *
 * - className
 * - methods
 *     - propertyNode
 *     - methodName
 *     - methodNode
 *
 * @param  {Object} node
 * @return {Object}
 */
module.exports = exports['default'];