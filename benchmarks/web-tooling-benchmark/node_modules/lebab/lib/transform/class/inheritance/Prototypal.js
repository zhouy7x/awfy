'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _matchesAst = require('../../../utils/matchesAst');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Processes nodes to detect super classes and return information for later
 * transformation.
 *
 * Detects:
 *
 *   Class1.prototype = Object.create(Class2.prototype);
 *
 * or:
 *
 *   Class1.prototype = new Class2();
 *
 * optionally followed by:
 *
 *   Class1.prototype.constructor = Class1;
 */
var Prototypal = function () {
  function Prototypal() {
    _classCallCheck(this, Prototypal);

    this.foundSuperclasses = {};
  }

  /**
   * Process a node and return inheritance details if found.
   * @param {Object} node
   * @param {Object} parent
   * @returns {Object/undefined} m
   *                    {String}   m.className
   *                    {Node}     m.superClass
   *                    {Object[]} m.relatedExpressions
   */


  _createClass(Prototypal, [{
    key: 'process',
    value: function process(node, parent) {
      var m = void 0;
      if (m = this.matchNewAssignment(node) || this.matchObjectCreateAssignment(node)) {
        this.foundSuperclasses[m.className] = m.superClass;

        return {
          className: m.className,
          superClass: m.superClass,
          relatedExpressions: [{ node: node, parent: parent }]
        };
      } else if (m = this.matchConstructorAssignment(node)) {
        var superClass = this.foundSuperclasses[m.className];
        if (superClass && m.className === m.constructorClassName) {
          return {
            className: m.className,
            superClass: superClass,
            relatedExpressions: [{ node: node, parent: parent }]
          };
        }
      }
    }

    // Matches: <className>.prototype = new <superClass>();

  }, {
    key: 'matchNewAssignment',
    value: function matchNewAssignment(node) {
      return (0, _matchesAst.isAstMatch)(node, {
        type: 'ExpressionStatement',
        expression: {
          type: 'AssignmentExpression',
          left: {
            type: 'MemberExpression',
            object: {
              type: 'Identifier',
              name: (0, _matchesAst.extract)('className')
            },
            property: {
              type: 'Identifier',
              name: 'prototype'
            }
          },
          right: {
            type: 'NewExpression',
            callee: (0, _matchesAst.extract)('superClass')
          }
        }
      });
    }

    // Matches: <className>.prototype = Object.create(<superClass>);

  }, {
    key: 'matchObjectCreateAssignment',
    value: function matchObjectCreateAssignment(node) {
      return (0, _matchesAst.isAstMatch)(node, {
        type: 'ExpressionStatement',
        expression: {
          type: 'AssignmentExpression',
          left: {
            type: 'MemberExpression',
            object: {
              type: 'Identifier',
              name: (0, _matchesAst.extract)('className')
            },
            property: {
              type: 'Identifier',
              name: 'prototype'
            }
          },
          right: {
            type: 'CallExpression',
            callee: {
              type: 'MemberExpression',
              object: {
                type: 'Identifier',
                name: 'Object'
              },
              property: {
                type: 'Identifier',
                name: 'create'
              }
            },
            arguments: (0, _matchesAst.matchesLength)([{
              type: 'MemberExpression',
              object: (0, _matchesAst.extract)('superClass'),
              property: {
                type: 'Identifier',
                name: 'prototype'
              }
            }])
          }
        }
      });
    }

    // Matches: <className>.prototype.constructor = <constructorClassName>;

  }, {
    key: 'matchConstructorAssignment',
    value: function matchConstructorAssignment(node) {
      return (0, _matchesAst.isAstMatch)(node, {
        type: 'ExpressionStatement',
        expression: {
          type: 'AssignmentExpression',
          left: {
            type: 'MemberExpression',
            object: {
              type: 'MemberExpression',
              object: {
                type: 'Identifier',
                name: (0, _matchesAst.extract)('className')
              },
              property: {
                type: 'Identifier',
                name: 'prototype'
              }
            },
            property: {
              type: 'Identifier',
              name: 'constructor'
            }
          },
          right: {
            type: 'Identifier',
            name: (0, _matchesAst.extract)('constructorClassName')
          }
        }
      });
    }
  }]);

  return Prototypal;
}();

exports.default = Prototypal;
module.exports = exports['default'];