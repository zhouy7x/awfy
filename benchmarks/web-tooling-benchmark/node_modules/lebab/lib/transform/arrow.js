'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, logger) {
  _traverser2.default.replace(ast, {
    enter: function enter(node, parent) {
      if (isFunctionConvertableToArrow(node, parent)) {
        if (hasArguments(node.body)) {
          logger.warn(node, 'Can not use arguments in arrow function', 'arrow');
          return;
        }
        return functionToArrow(node);
      }

      var _matchBoundFunction = matchBoundFunction(node),
          func = _matchBoundFunction.func;

      if (func) {
        return functionToArrow(func);
      }
    }
  });
};

var _fp = require('lodash/fp');

var _traverser = require('../traverser');

var _traverser2 = _interopRequireDefault(_traverser);

var _ArrowFunctionExpression = require('../syntax/ArrowFunctionExpression');

var _ArrowFunctionExpression2 = _interopRequireDefault(_ArrowFunctionExpression);

var _matchesAst = require('../utils/matchesAst');

var _copyComments = require('../utils/copyComments');

var _copyComments2 = _interopRequireDefault(_copyComments);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isFunctionConvertableToArrow(node, parent) {
  return node.type === 'FunctionExpression' && parent.type !== 'Property' && parent.type !== 'MethodDefinition' && !node.id && !node.generator && !hasThis(node.body);
}

// Matches: function(){}.bind(this)
function matchBoundFunction(node) {
  return (0, _matchesAst.isAstMatch)(node, {
    type: 'CallExpression',
    callee: {
      type: 'MemberExpression',
      computed: false,
      object: (0, _matchesAst.extract)('func', {
        type: 'FunctionExpression',
        id: null, // eslint-disable-line no-null/no-null
        body: function body(_body) {
          return !hasArguments(_body);
        },
        generator: false
      }),
      property: {
        type: 'Identifier',
        name: 'bind'
      }
    },
    arguments: [{
      type: 'ThisExpression'
    }]
  });
}

function hasThis(ast) {
  return hasInFunctionBody(ast, { type: 'ThisExpression' });
}

function hasArguments(ast) {
  return hasInFunctionBody(ast, { type: 'Identifier', name: 'arguments' });
}

// Returns true when pattern matches any node in given function body,
// excluding any nested functions
function hasInFunctionBody(ast, pattern) {
  return _traverser2.default.find(ast, (0, _fp.matches)(pattern), {
    skipTypes: ['FunctionExpression', 'FunctionDeclaration']
  });
}

function functionToArrow(func) {
  return new _ArrowFunctionExpression2.default({
    body: extractArrowBody(func.body),
    params: func.params,
    defaults: func.defaults,
    rest: func.rest,
    async: func.async
  });
}

var matchesReturnBlock = (0, _matchesAst.matchesAst)({
  type: 'BlockStatement',
  body: (0, _matchesAst.matchesLength)([(0, _matchesAst.extract)('returnStatement', {
    type: 'ReturnStatement',
    argument: (0, _matchesAst.extract)('returnVal')
  })])
});

function extractArrowBody(block) {
  var _ref = matchesReturnBlock(block) || {},
      returnStatement = _ref.returnStatement,
      returnVal = _ref.returnVal;

  if (returnVal) {
    // preserve return statement comments
    (0, _copyComments2.default)({ from: returnStatement, to: returnVal });
    return returnVal;
  } else {
    return block;
  }
}
module.exports = exports['default'];