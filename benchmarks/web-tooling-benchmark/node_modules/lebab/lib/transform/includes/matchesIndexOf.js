'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isZero = exports.isMinusOne = undefined;

exports.default = function (node) {
  return matchesIndexOfNormal(node) || reverseOperatorField(matchesIndexOfReversed(node));
};

var _matchesAst = require('../../utils/matchesAst');

/**
 * Matches: -1
 */
var isMinusOne = exports.isMinusOne = (0, _matchesAst.matchesAst)({
  type: 'UnaryExpression',
  operator: '-',
  argument: {
    type: 'Literal',
    value: 1
  },
  prefix: true
});

/**
 * Matches: 0
 */
var isZero = exports.isZero = (0, _matchesAst.matchesAst)({
  type: 'Literal',
  value: 0
});

// Matches: object.indexOf(searchElement)
var matchesCallIndexOf = (0, _matchesAst.matchesAst)({
  type: 'CallExpression',
  callee: {
    type: 'MemberExpression',
    computed: false,
    object: (0, _matchesAst.extract)('object'),
    property: {
      type: 'Identifier',
      name: 'indexOf'
    }
  },
  arguments: (0, _matchesAst.matchesLength)([(0, _matchesAst.extract)('searchElement')])
});

// Matches: -1 or 0
var matchesIndex = (0, _matchesAst.extract)('index', function (v) {
  return isMinusOne(v) || isZero(v);
});

// Matches: object.indexOf(searchElement) <operator> index
var matchesIndexOfNormal = (0, _matchesAst.matchesAst)({
  type: 'BinaryExpression',
  operator: (0, _matchesAst.extract)('operator'),
  left: matchesCallIndexOf,
  right: matchesIndex
});

// Matches: index <operator> object.indexOf(searchElement)
var matchesIndexOfReversed = (0, _matchesAst.matchesAst)({
  type: 'BinaryExpression',
  operator: (0, _matchesAst.extract)('operator'),
  left: matchesIndex,
  right: matchesCallIndexOf
});

// Reverses the direction of comparison operator
function reverseOperator(operator) {
  return operator.replace(/[><]/, function (op) {
    return op === '>' ? '<' : '>';
  });
}

function reverseOperatorField(matches) {
  if (!matches) {
    return false;
  }

  return Object.assign({}, matches, {
    operator: reverseOperator(matches.operator)
  });
}

/**
 * Matches:
 *
 *    object.indexOf(searchElement) <operator> index
 *
 * or
 *
 *    index <operator> object.indexOf(searchElement)
 *
 * On success returns object with keys:
 *
 * - object
 * - searchElement
 * - operator
 * - index
 *
 * @param  {Object} node
 * @return {Object}
 */